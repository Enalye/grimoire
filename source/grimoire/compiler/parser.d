/** 
 * Copyright: Enalye
 * License: Zlib
 * Authors: Enalye
 */
module grimoire.compiler.parser;

import std.stdio;
import std.string;
import std.array;
import std.conv;
import std.math;
import std.file;
import std.meta;

import grimoire.runtime;
import grimoire.assembly;
import grimoire.compiler.lexer;
import grimoire.compiler.mangle;
import grimoire.compiler.type;
import grimoire.compiler.primitive;
import grimoire.compiler.data;
import grimoire.compiler.error;

/**
Analyses the syntax and produce the data for the VM
The parser analyses the lexemes generated by the lexer and produce machine code.
*/
class GrParser {
	int[] iconsts;
	float[] fconsts;
	dstring[] sconsts;

	uint scopeLevel;

	GrVariable[dstring] globalVariables;
	GrFunction[dstring] functions, events;
	GrFunction[dstring] anonymousFunctions;

	uint current;
	GrFunction currentFunction;
	GrFunction[] functionStack;
	GrFunctionCall[] functionCalls;

	uint[][] breaksJumps;
	uint[][] continuesJumps;
	uint[] continuesDestinations;

	GrLexeme[] lexemes;

    bool isTypeChecking;

    private GrData _data;

    /// Number of int based global variables declared.
    uint iglobalsCount,
    /// Number of float based global variables declared.
        fglobalsCount,
    /// Number of string based global variables declared.
        sglobalsCount,
    /// Number of ptr based global variables declared.
        oglobalsCount;

    private {
        uint _lastAssignationScopeLevel, _blockLevel;
        bool _isProfiling;
    }

    void setProfiling(bool isProfiling) {
        _isProfiling = true;
    }

    /// Reset to the start of the sequence.
	void reset() {
		current = 0u;
	}

    /// Advance to the next lexeme.
	void advance() {
		if(current < lexemes.length)
			current ++;
	}

    /// Return to the last lexeme.
    void goBack() {
        if(current > 0u)
            current --;
    }

    /// Check for the end the sequence, then advance to the next lexeme.
	bool checkAdvance() {
		if(isEnd())
			return false;
		
		advance();
		return true;
	}

    /// Start of a block with `{`
	void openBlock() {
		scopeLevel ++;
	}

    /// End of a block with '}'
	void closeBlock() {
		scopeLevel --;
	}

    /// Check for the end of the sequence.
	bool isEnd(int offset = 0) {
		return (current + offset) >= cast(uint)lexemes.length;
	}

    /// Return the lexeme at the current position.
	GrLexeme get(int offset = 0) {
		uint position = current + offset;
		if(position < 0 || position >= cast(uint)lexemes.length) {
			logError("Unexpected end of file", "Unexpected end of file");
		}
		return lexemes[position];
	}

    /// Register an integral value and returns its id.
	uint registerIntConstant(int value) {
		foreach(size_t index, int iconst; iconsts) {
			if(iconst == value)
				return cast(uint)index;
		}
		iconsts ~= value;
		return cast(uint)iconsts.length - 1;
	}

    /// Register an floating point value and returns its id.
	uint registerFloatConstant(float value) {
		foreach(size_t index, float fconst; fconsts) {
			if(fconst == value)
				return cast(uint)index;
		}
		fconsts ~= value;
		return cast(uint)fconsts.length - 1;
	}

    /// Register an string value and returns its id.
	uint registerStringConstant(dstring value) {
		foreach(size_t index, dstring sconst; sconsts) {
			if(sconst == value)
				return cast(uint)index;
		}
		sconsts ~= value;
		return cast(uint)sconsts.length - 1;
	}

    /// Register a special local variable, used for iterators, etc.
	GrVariable registerSpecialVariable(dstring name, GrType type) {
		name = "~"d ~ name;
		GrVariable specialVariable;
		auto previousVariable = (name in currentFunction.localVariables);
		if(previousVariable is null)
			specialVariable = registerLocalVariable(name, type);
		else
			specialVariable = *previousVariable;
        specialVariable.isAuto = false;
        specialVariable.isInitialized = true; //We shortcut this check
		return specialVariable;
	}

    /// Register a global variable
    GrVariable registerGlobalVariable(dstring name, GrType type, bool isAuto) {
        //Check if declared globally.
		auto previousVariable = (name in globalVariables);
		if(previousVariable !is null)
			logError("Multiple declaration", "The global variable \'" ~ to!string(name) ~ "\' is already declared.");

		GrVariable variable = new GrVariable;
        variable.isAuto = isAuto;
		variable.isGlobal = true;
        variable.isInitialized = false;
		variable.type = type;
        variable.name = name;
        if(!isAuto)
            setVariableRegister(variable);
		globalVariables[name] = variable;

		return variable;
    }

    private void setVariableRegister(GrVariable variable) {
        final switch(variable.type.baseType) with(GrBaseType) {
        case IntType:
        case BoolType:
        case FunctionType:
        case TaskType:
            if(variable.isGlobal) {
                variable.register = iglobalsCount;
                iglobalsCount ++;
            }
            else {
                variable.register = currentFunction.ilocalsCount;
                currentFunction.ilocalsCount ++;
            }
            break;
        case FloatType:
            if(variable.isGlobal) {
                variable.register = fglobalsCount;
                fglobalsCount ++;
            }
            else {
                variable.register = currentFunction.flocalsCount;
                currentFunction.flocalsCount ++;
            }
            break;
        case StringType:
            if(variable.isGlobal) {
                variable.register = sglobalsCount;
                sglobalsCount ++;
            }
            else {
                variable.register = currentFunction.slocalsCount;
                currentFunction.slocalsCount ++;
            }
            break;
        case ArrayType:
        case ObjectType:
        case UserType:
        case ChanType:
            if(variable.isGlobal) {
                variable.register = oglobalsCount;
                oglobalsCount ++;
            }
            else {
                variable.register = currentFunction.olocalsCount;
                currentFunction.olocalsCount ++;
            }
            break;
        case InternalTupleType:
        case ReferenceType:
        case VoidType:
            logError("Invalid type", "Cannot declare a variable of type " ~ grGetPrettyType(variable.type));
            break;
        }
    }

    /// Register a local variable
	GrVariable registerLocalVariable(dstring name, GrType type) {
		//Check if declared globally
        if(name in globalVariables)
			logError("Multiple declaration", "The local variable \'" ~ to!string(name) ~ "\' is already declared in a global scope.");

		//Check if declared locally.
		auto previousVariable = (name in currentFunction.localVariables);
		if(previousVariable !is null)
			logError("Multiple declaration", "The local variable \'" ~ to!string(name) ~ "\' is already declared.");

		GrVariable variable = new GrVariable;
		variable.isGlobal = false;
		variable.type = type;
        variable.name = name;
        if(variable.type.baseType != GrBaseType.VoidType)
            setVariableRegister(variable);
		currentFunction.localVariables[name] = variable;

		return variable;
	}

    void beginGlobalScope() {
        auto globalScope = "@global"d in functions;
        if(globalScope) {
            functionStack ~= currentFunction;
            currentFunction = *globalScope;
        }
        else {
            GrFunction func = new GrFunction;
            func.name = "@global"d;
            func.isTask = false;
            func.inSignature = [];
            func.outSignature = [];
            functions["@global"d] = func;
            functionStack ~= currentFunction;
            currentFunction = func;
        }
    }

    void endGlobalScope() {
        if(!functionStack.length)
			logError("Global Scope", "Global scope mismatch");
        
		currentFunction = functionStack[$ - 1];
        functionStack.length --;
    }

	void beginFunction(dstring name, GrType[] signature, bool isEvent = false) {
        const dstring mangledName = grMangleNamedFunction(name, signature);

		GrFunction* func;
        if(isEvent)
            func = mangledName in events;
        else
            func = mangledName in functions;

		if(func is null)
			logError("Undeclared function", "The function \'" ~ to!string(name) ~ "\' is not declared.");

		functionStack ~= currentFunction;
		currentFunction = *func;
	}

	void preBeginFunction(dstring name, GrType[] signature, dstring[] inputVariables, bool isTask, GrType[] outSignature = [], bool isAnonymous = false, bool isEvent = false) {
		GrFunction func = new GrFunction;
		func.isTask = isTask;
		func.inSignature = signature;
		func.outSignature = outSignature;

		if(isAnonymous) {
			func.index = cast(uint)anonymousFunctions.length;
			func.anonParent = currentFunction;
			func.anonReference = cast(uint)currentFunction.instructions.length;
			func.name = currentFunction.name ~ "@anon"d ~ to!dstring(func.index);
            dstring mangledName = grMangleNamedFunction(func.name, func.inSignature);
			anonymousFunctions[mangledName] = func;

			//Is replaced by the addr of the function later (see solveFunctionCalls).
			addInstruction(GrOpcode.Const_Int, 0u);
		}
		else {
			func.index = cast(uint)functions.length;
			func.name = name;

			dstring mangledName = grMangleNamedFunction(name, signature);
			auto previousFunc = (mangledName in functions);
			if(previousFunc !is null)
				logError("Multiple declaration", "The function \'" ~ to!string(name) ~ "\' is already declared.");
		
            if(isEvent)
                events[mangledName] = func;
            else
                functions[mangledName] = func;
		}

		functionStack ~= currentFunction;
		currentFunction = func;

		void fetchParameter(dstring name, GrType type) {
            final switch(type.baseType) with(GrBaseType) {
            case VoidType:
                logError("Invalid type", "Void is not a valid parameter type");
                break;
            case IntType:
            case BoolType:
            case FunctionType:
            case TaskType:
                func.nbIntegerParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Int, 0u);
                break;
            case FloatType:
                func.nbFloatParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Float, 0u);
                break;
            case StringType:
                func.nbStringParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_String, 0u);
                break;
            case ObjectType:
            case ArrayType:
            case UserType:
            case ChanType:
            case ReferenceType:
                func.nbObjectParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Object, 0u);
                break;
            case InternalTupleType:
                throw new Exception("Tuples should not exist here.");
            }

            GrVariable newVar = new GrVariable;
            newVar.type = type;
            newVar.isInitialized = true;
            newVar.isGlobal = false;
            newVar.name = name;
            func.localVariables[name] = newVar;
            setVariableRegister(newVar);
            addSetInstruction(newVar);
        }
        
        foreach_reverse(size_t i, inputVariable; inputVariables) {
            fetchParameter(inputVariables[i], signature[i]);
        }
	}

	void endFunction() {
        int prependInstructionCount;
        if(_isProfiling) {
            prependInstructionCount ++;
            const uint index = registerStringConstant(to!dstring(grGetPrettyFunction(currentFunction)));
            addInstructionInFront(GrOpcode.Debug_ProfileBegin, index);
        }

        if(currentFunction.ilocalsCount > 0) {
            addInstructionInFront(GrOpcode.LocalStack_Int, currentFunction.ilocalsCount);
            prependInstructionCount ++;
        }
        
        if(currentFunction.flocalsCount > 0) {
            addInstructionInFront(GrOpcode.LocalStack_Float, currentFunction.flocalsCount);
            prependInstructionCount ++;
        }

        if(currentFunction.slocalsCount > 0) {
            addInstructionInFront(GrOpcode.LocalStack_String, currentFunction.slocalsCount);
            prependInstructionCount ++;
        }

        if(currentFunction.olocalsCount > 0) {
            addInstructionInFront(GrOpcode.LocalStack_Object, currentFunction.olocalsCount);
            prependInstructionCount ++;
        }

		foreach(call; currentFunction.functionCalls)
            call.position += prependInstructionCount;

        currentFunction.offset += prependInstructionCount;

		if(!functionStack.length)
			logError("Missing symbol", "A \'}\' is missing, causing a mismatch");
        
		currentFunction = functionStack[$ - 1];
        functionStack.length --;
	}

	void preEndFunction() {
		if(!functionStack.length)
			logError("Missing symbol", "A \'}\' is missing, causing a mismatch");
		currentFunction = functionStack[$ - 1];
        functionStack.length --;
	}

	GrFunction* getFunction(dstring name) {
		auto func = (name in functions);
		if(func is null)
			logError("Undeclared function", "The function \'" ~ to!string(name) ~ "\' is not declared");
		return func;
	}

    /// Retrieve a declared variable
	GrVariable getVariable(dstring name) {
        auto var = (name in globalVariables);
		if(var !is null)
            return *var;

		var = (name in currentFunction.localVariables);
		if(var is null)
            logError("Undeclared variable", "The variable \'" ~ to!string(name) ~ "\' is not declared", -1);
        return *var;
	}

    bool hasVariable(dstring name) {
        auto var = (name in globalVariables);
		if(var !is null)
            return true;

		var = (name in currentFunction.localVariables);
		if(var !is null)
            return true;
        return false;
    }

	void addIntConstant(int value) {
		addInstruction(GrOpcode.Const_Int, registerIntConstant(value));
	}

	void addFloatConstant(float value) {
		addInstruction(GrOpcode.Const_Float, registerFloatConstant(value));
	}

	void addBoolConstant(bool value) {
		addInstruction(GrOpcode.Const_Bool, value);
	}

	void addStringConstant(dstring value) {
		addInstruction(GrOpcode.Const_String, registerStringConstant(value));
	}

    void addMetaConstant(dstring value) {
		addInstruction(GrOpcode.Const_Meta, registerStringConstant(value));
    }

	void addInstruction(GrOpcode opcode, int value = 0, bool isSigned = false) {
		if(currentFunction is null)
			logError("Not in function", "The expression is located outside of a function or task, which is forbidden");

		GrInstruction instruction;
		instruction.opcode = opcode;
		if(isSigned) {
			if((value >= 0x800000) || (-value >= 0x800000))
				logError("Internal failure", "An opcode\'s signed value is exceeding limits");		
			instruction.value = value + 0x800000;
		}
		else
			instruction.value = value;
		currentFunction.instructions ~= instruction;
	}

    void addInstructionInFront(GrOpcode opcode, int value = 0, bool isSigned = false) {
		if(currentFunction is null)
			logError("Not in function", "The expression is located outside of a function or task, which is forbidden");

		GrInstruction instruction;
		instruction.opcode = opcode;
		if(isSigned) {
			if((value >= 0x800000) || (-value >= 0x800000))
				logError("Internal failure", "An opcode\'s signed value is exceeding limits");		
			instruction.value = value + 0x800000;
		}
		else
			instruction.value = value;
		currentFunction.instructions = instruction ~ currentFunction.instructions;
	}

	void setInstruction(GrOpcode opcode, uint index, int value = 0u, bool isSigned = false) {
		if(currentFunction is null)
			logError("Not in function", "The expression is located outside of a function or task, which is forbidden");

		if(index >= currentFunction.instructions.length)
			logError("Internal failure", "An instruction's index is exeeding the function size");

		GrInstruction instruction;
		instruction.opcode = opcode;
		if(isSigned) {
			if((value >= 0x800000) || (-value >= 0x800000))
				logError("Internal failure", "An opcode\'s signed value is exceeding limits");				
			instruction.value = value + 0x800000;
		}
		else
			instruction.value = value;
		currentFunction.instructions[index] = instruction;
	}

    bool isBinaryOperator(GrLexemeType lexType) {
        if(lexType >= GrLexemeType.Add && lexType <= GrLexemeType.Xor)
            return true;
        else if(lexType == GrLexemeType.Send)
            return true;
        else
            return false;
    }

    bool isUnaryOperator(GrLexemeType lexType) {
        if(lexType >= GrLexemeType.Plus && lexType <= GrLexemeType.Minus)
            return true;
        else if(lexType >= GrLexemeType.Increment && lexType <= GrLexemeType.Decrement)
            return true;
        else if(lexType == GrLexemeType.Not)
            return true;
        else if(lexType == GrLexemeType.Receive)
            return true;
        else
            return false;
    }

    GrType addCustomBinaryOperator(GrLexemeType lexType, GrType leftType, GrType rightType) {
        GrType resultType = GrBaseType.VoidType;
        dstring mangledName = grMangleNamedFunction("@op_" ~ grGetPrettyLexemeType(lexType), [leftType, rightType]);
        
        //GrPrimitive check
        if(_data.isPrimitiveDeclared(mangledName)) {
            GrPrimitive primitive = _data.getPrimitive(mangledName);
            addInstruction(GrOpcode.PrimitiveCall, primitive.index);
            if(primitive.outSignature.length != 1uL)
                    logError("Return signature error", "An operator can only have one return value");
            resultType = primitive.outSignature[0];
        }

        //GrFunction check
        if(resultType.baseType == GrBaseType.VoidType) {
            const auto func = (mangledName in functions);
            if(func !is null) {
                auto outSignature = addFunctionCall(mangledName);
                if(outSignature.length != 1uL)
                    logError("Return signature error", "An operator can only have one return value");
                resultType = outSignature[0];
            }
        }

        return resultType;     
    }

    GrType addCustomUnaryOperator(GrLexemeType lexType, const GrType type) {
        GrType resultType = GrBaseType.VoidType;
        dstring mangledName = grMangleNamedFunction("@op_" ~ grGetPrettyLexemeType(lexType), [type]);
        
        //GrPrimitive check
        if(_data.isPrimitiveDeclared(mangledName)) {
            GrPrimitive primitive = _data.getPrimitive(mangledName);
            addInstruction(GrOpcode.PrimitiveCall, primitive.index);
            if(primitive.outSignature.length != 1uL)
                    logError("Return signature error", "An operator can only have one return value");
            resultType = primitive.outSignature[0];
        }

        //GrFunction check
        if(resultType.baseType == GrBaseType.VoidType) {
            const auto func = (mangledName in functions);
            if(func !is null) {
                auto outSignature = addFunctionCall(mangledName);
                if(outSignature.length != 1uL)
                    logError("Return signature error", "An operator can only have one return value");
                resultType = outSignature[0];
            }
        }

        return resultType;     
    }

    GrType addBinaryOperator(GrLexemeType lexType, const GrType leftType, const GrType rightType) {
        if(leftType.baseType == GrBaseType.InternalTupleType || rightType.baseType == GrBaseType.InternalTupleType)
            logError("Multiple values operation", "Cannot use an operator on an expression list");
        GrType resultType = GrBaseType.VoidType;

        if(leftType.baseType == GrBaseType.ChanType) {
            GrType chanType = grUnmangle(leftType.mangledType);
            convertType(rightType, chanType);
            resultType = addInternalOperator(lexType, leftType);
            if(resultType.baseType == GrBaseType.VoidType) {
                resultType = addCustomBinaryOperator(lexType, leftType, rightType);
            }
        }
        else if(lexType == GrLexemeType.Concatenate && leftType.baseType == GrBaseType.ArrayType && leftType != rightType) {
            const GrType subType = grUnmangle(leftType.mangledType);
            convertType(rightType, subType);
            switch(subType.baseType) with(GrBaseType) {
            case IntType:
            case BoolType:
            case FunctionType:
            case TaskType:
                addInstruction(GrOpcode.Append_Int);
                break;
            case FloatType:
                addInstruction(GrOpcode.Append_Float);
                break;
            case StringType:
                addInstruction(GrOpcode.Append_String);
                break;
            case ObjectType:
            case ArrayType:
            case UserType:
            case ChanType:
                addInstruction(GrOpcode.Append_Object);
                break;
            default:
                break;
            }
            resultType = leftType;
        }
        else if(lexType == GrLexemeType.Concatenate && rightType.baseType == GrBaseType.ArrayType && leftType != rightType) {
            const GrType subType = grUnmangle(rightType.mangledType);
            convertType(leftType, subType);
            switch(subType.baseType) with(GrBaseType) {
            case IntType:
            case BoolType:
            case FunctionType:
            case TaskType:
                addInstruction(GrOpcode.Prepend_Int);
                break;
            case FloatType:
                addInstruction(GrOpcode.Prepend_Float);
                break;
            case StringType:
                addInstruction(GrOpcode.Prepend_String);
                break;
            case ObjectType:
            case ArrayType:
            case UserType:
            case ChanType:
                addInstruction(GrOpcode.Prepend_Object);
                break;
            default:
                break;
            }
            resultType = rightType;
        }
        else if(leftType.baseType == GrBaseType.IntType && rightType.baseType == GrBaseType.FloatType) {
            // Special case, we need to convert int to float, then swap the 2 values when needed.
            convertType(leftType, rightType);
            resultType = addInternalOperator(lexType, rightType, true);
        }
        else if(leftType != rightType) {
            //Check custom operator
            resultType = addCustomBinaryOperator(lexType, leftType, rightType);

            //If there is no custom operator defined, we try to convert and then try again
            if(resultType.baseType == GrBaseType.VoidType) {
                resultType = convertType(rightType, leftType, true);
                if(resultType.baseType != GrBaseType.VoidType) {
                    resultType = addBinaryOperator(lexType, resultType, resultType);
                }
            }
        }
        else {
            resultType = addInternalOperator(lexType, leftType);
            if(resultType.baseType == GrBaseType.VoidType) {
                resultType = addCustomBinaryOperator(lexType, leftType, rightType);
            }
        }
        if(resultType.baseType == GrBaseType.VoidType)
            logError("Operator Undefined", "There is no "
                ~ to!string(grGetPrettyLexemeType(lexType))
                ~ " operator defined for \'"
                ~ grGetPrettyType(leftType)
                ~ "\' and \'"
                ~ grGetPrettyType(rightType)
                ~ "\'", -1);
        return resultType;
    }

    GrType addUnaryOperator(GrLexemeType lexType, const GrType type) {
        if(type.baseType == GrBaseType.InternalTupleType)
            logError("Multiple values operation", "Cannot use an operator on an expression list");
        GrType resultType = GrBaseType.VoidType;
        
        resultType = addInternalOperator(lexType, type);
        if(resultType.baseType == GrBaseType.VoidType) {
            resultType = addCustomUnaryOperator(lexType, type);
        }
    
        if(resultType.baseType == GrBaseType.VoidType)
            logError("Operator Undefined", "There is no "
                ~ to!string(grGetPrettyLexemeType(lexType))
                ~ " operator defined for \'"
                ~ grGetPrettyType(type)
                ~ "\'");
        return resultType;
    }

	GrType addOperator(GrLexemeType lexType, ref GrType[] typeStack) {
        if(isBinaryOperator(lexType)) {
            typeStack[$ - 2] = addBinaryOperator(lexType, typeStack[$ - 2], typeStack[$ - 1]);
            typeStack.length --;
            return typeStack[$ - 1];
        }
        else if(isUnaryOperator(lexType)) {
            typeStack[$ - 1] = addUnaryOperator(lexType, typeStack[$ - 1]);
            return typeStack[$ - 1];
        }

        return GrType(GrBaseType.VoidType);		
	}

    GrType addInternalOperator(GrLexemeType lexType, GrType varType, bool isSwapped = false) {
        switch(varType.baseType) with(GrBaseType) {
        case BoolType:
            switch(lexType) with(GrLexemeType) {
            case And:
				addInstruction(GrOpcode.And_Int);
                return GrType(GrBaseType.BoolType);
			case Or:
				addInstruction(GrOpcode.Or_Int);
                return GrType(GrBaseType.BoolType);
			case Not:
				addInstruction(GrOpcode.Not_Int);
                return GrType(GrBaseType.BoolType);				
            default:
                break;
            }
            break;
		case IntType:
			switch(lexType) with(GrLexemeType) {
			case Add:
				addInstruction(GrOpcode.Add_Int);
				return GrType(GrBaseType.IntType);
			case Substract:
				addInstruction(GrOpcode.Substract_Int);
				return GrType(GrBaseType.IntType);
			case Multiply:
				addInstruction(GrOpcode.Multiply_Int);
				return GrType(GrBaseType.IntType);
			case Divide:
				addInstruction(GrOpcode.Divide_Int);
				return GrType(GrBaseType.IntType);
            case Remainder:
				addInstruction(GrOpcode.Remainder_Int);
				return GrType(GrBaseType.IntType);
			case Minus:
				addInstruction(GrOpcode.Negative_Int);
				return GrType(GrBaseType.IntType);
			case Plus:
				return GrType(GrBaseType.IntType);
			case Increment:
				addInstruction(GrOpcode.Increment_Int);
				return GrType(GrBaseType.IntType);
			case Decrement:
				addInstruction(GrOpcode.Decrement_Int);
				return GrType(GrBaseType.IntType);
			case Equal:
				addInstruction(GrOpcode.Equal_Int);
				return GrType(GrBaseType.BoolType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_Int);
				return GrType(GrBaseType.BoolType);
			case Greater:
				addInstruction(GrOpcode.Greater_Int);
				return GrType(GrBaseType.BoolType);
			case GreaterOrEqual:
				addInstruction(GrOpcode.GreaterOrEqual_Int);
				return GrType(GrBaseType.BoolType);
			case Lesser:
				addInstruction(GrOpcode.Lesser_Int);
				return GrType(GrBaseType.BoolType);
			case LesserOrEqual:
				addInstruction(GrOpcode.LesserOrEqual_Int);
                return GrType(GrBaseType.BoolType);
			default:
				break;
			}
			break;
		case FloatType:
			switch(lexType) with(GrLexemeType) {
			case Add:
				addInstruction(GrOpcode.Add_Float);
				return GrType(GrBaseType.FloatType);
			case Substract:
                if(isSwapped)
                    addInstruction(GrOpcode.Swap_Float);
				addInstruction(GrOpcode.Substract_Float);
				return GrType(GrBaseType.FloatType);
			case Multiply:
				addInstruction(GrOpcode.Multiply_Float);
				return GrType(GrBaseType.FloatType);
			case Divide:
                if(isSwapped)
                    addInstruction(GrOpcode.Swap_Float);
				addInstruction(GrOpcode.Divide_Float);
				return GrType(GrBaseType.FloatType);
            case Remainder:
                if(isSwapped)
                    addInstruction(GrOpcode.Swap_Float);
				addInstruction(GrOpcode.Remainder_Float);
				return GrType(GrBaseType.FloatType);
			case Minus:
				addInstruction(GrOpcode.Negative_Float);
				return GrType(GrBaseType.FloatType);
			case Plus:
				return GrType(GrBaseType.FloatType);
			case Increment:
				addInstruction(GrOpcode.Increment_Float);
				return GrType(GrBaseType.FloatType);
			case Decrement:
				addInstruction(GrOpcode.Decrement_Float);
				return GrType(GrBaseType.FloatType);
			case Equal:
				addInstruction(GrOpcode.Equal_Float);
				return GrType(GrBaseType.BoolType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_Float);
				return GrType(GrBaseType.BoolType);
			case Greater:
                if(isSwapped)
                    addInstruction(GrOpcode.LesserOrEqual_Float);
                else
                    addInstruction(GrOpcode.Greater_Float);
				return GrType(GrBaseType.BoolType);
			case GreaterOrEqual:
                if(isSwapped)
                    addInstruction(GrOpcode.Lesser_Float);
                else
                    addInstruction(GrOpcode.GreaterOrEqual_Float);
				return GrType(GrBaseType.BoolType);
			case Lesser:
                if(isSwapped)
                    addInstruction(GrOpcode.GreaterOrEqual_Float);
                else
                    addInstruction(GrOpcode.Lesser_Float);
				return GrType(GrBaseType.BoolType);
			case LesserOrEqual:
                if(isSwapped)
                    addInstruction(GrOpcode.Greater_Float);
                else
                    addInstruction(GrOpcode.LesserOrEqual_Float);
				return GrType(GrBaseType.BoolType);
			default:
				break;
			}
			break;
		case StringType:
			switch(lexType) with(GrLexemeType) {
			case Concatenate:
				addInstruction(GrOpcode.Concatenate_String);
				return GrType(GrBaseType.StringType);
			case Equal:
				addInstruction(GrOpcode.Equal_String);
				return GrType(GrBaseType.BoolType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_String);
				return GrType(GrBaseType.BoolType);
			default:
				break;
			}
			break;
        case ArrayType:
            switch(lexType) with(GrLexemeType) {
            case Equal:
                const GrType subType = grUnmangle(varType.mangledType);
                switch(subType.baseType) with(GrBaseType) {
                case IntType:
                case BoolType:
                case FunctionType:
                case TaskType:
                    addInstruction(GrOpcode.Equal_IntArray);
                    return grBool;
                case FloatType:
                    addInstruction(GrOpcode.Equal_FloatArray);
                    return grBool;
                case StringType:
                    addInstruction(GrOpcode.Equal_StringArray);
                    return grBool;
                default:
                    break;
                }
                break;
            case NotEqual:
                const GrType subType = grUnmangle(varType.mangledType);
                switch(subType.baseType) with(GrBaseType) {
                case IntType:
                case BoolType:
                case FunctionType:
                case TaskType:
                    addInstruction(GrOpcode.NotEqual_IntArray);
                    return grBool;
                case FloatType:
                    addInstruction(GrOpcode.NotEqual_FloatArray);
                    return grBool;
                case StringType:
                    addInstruction(GrOpcode.NotEqual_StringArray);
                    return grBool;
                default:
                    break;
                }
                break;
            case Concatenate:
				const GrType subType = grUnmangle(varType.mangledType);
                switch(subType.baseType) with(GrBaseType) {
                case IntType:
                case BoolType:
                case FunctionType:
                case TaskType:
                    addInstruction(GrOpcode.Concatenate_IntArray);
                    return varType;
                case FloatType:
                    addInstruction(GrOpcode.Concatenate_FloatArray);
                    return varType;
                case StringType:
                    addInstruction(GrOpcode.Concatenate_StringArray);
                    return varType;
                case ObjectType:
                case ArrayType:
                case UserType:
                case ChanType:
                    addInstruction(GrOpcode.Concatenate_ObjectArray);
                    return varType;
                default:
                    break;
                }
                break;
            default:
                break;
            }
            break;
        case ChanType:
            switch(lexType) with(GrLexemeType) {
            case Send:
                GrType chanType = grUnmangle(varType.mangledType);
                switch(chanType.baseType) with(GrBaseType) {
                case IntType:
                case BoolType:
                case FunctionType:
                case TaskType:
                    addInstruction(GrOpcode.Send_Int);
                    return chanType;
                case FloatType:
                    addInstruction(GrOpcode.Send_Float);
                    return chanType;
                case StringType:
                    addInstruction(GrOpcode.Send_String);
                    return chanType;
                case ObjectType:
                case ArrayType:
                case UserType:
                case ChanType:
                    addInstruction(GrOpcode.Send_Object);
                    return chanType;
                default:
                    break;
                }
                break;
            case Receive:
				GrType chanType = grUnmangle(varType.mangledType);
                switch(chanType.baseType) with(GrBaseType) {
                case IntType:
                case BoolType:
                case FunctionType:
                case TaskType:
                    addInstruction(GrOpcode.Receive_Int);
                    return chanType;
                case FloatType:
                    addInstruction(GrOpcode.Receive_Float);
                    return chanType;
                case StringType:
                    addInstruction(GrOpcode.Receive_String);
                    return chanType;
                case ObjectType:
                case ArrayType:
                case UserType:
                case ChanType:
                    addInstruction(GrOpcode.Receive_Object);
                    return chanType;
                default:
                    break;
                }
                break;
            default:
                break;
            }
            break;
		default:
            break;
		}
        return GrType(GrBaseType.VoidType);
    }

	void addSetInstruction(GrVariable variable, GrType valueType = grVoid, bool isExpectingValue = false) {
        _lastAssignationScopeLevel = _blockLevel;
        if(variable.type.baseType == GrBaseType.ReferenceType) {
            valueType = convertType(valueType, grUnmangle(variable.type.mangledType));
            switch(valueType.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
			case ChanType:
				addInstruction(isExpectingValue ? GrOpcode.RefStore2_Int : GrOpcode.RefStore_Int);
				break;
			case FloatType:
				addInstruction(isExpectingValue ? GrOpcode.RefStore2_Float : GrOpcode.RefStore_Float);
				break;
			case StringType:
				addInstruction(isExpectingValue ? GrOpcode.RefStore2_String : GrOpcode.RefStore_String);
				break;
			case ObjectType:
				addInstruction(isExpectingValue ? GrOpcode.RefStore2_Object : GrOpcode.RefStore_Object);
				break;
            case ArrayType:
            case UserType:
				addInstruction(isExpectingValue ? GrOpcode.RefStore2_Object : GrOpcode.RefStore_Object);
				break;
			default:
				logError("Invalid type", "Cannot assign to a \'" ~ to!string(variable.type) ~ "\' type");
			}
            return;
        }

        if(variable.isAuto && !variable.isInitialized) {
            variable.isInitialized = true;
            variable.isAuto = false;
            variable.type = valueType;
            if(valueType.baseType == GrBaseType.VoidType)
                logError("Variable type error", "Cannot infer the type of variable");
            else
                setVariableRegister(variable);
        }
        
        if(valueType.baseType != GrBaseType.VoidType)
            convertType(valueType, variable.type);

        //if(!variable.isInitialized && isExpectingValue)
        //    logError("Uninitialized variable", "The variable is being used without being assigned");
        variable.isInitialized = true;

        if(variable.isField) {
            final switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
				addInstruction(GrOpcode.FieldStore_Int, isExpectingValue ? 0 : -1, true);
				break;
			case FloatType:
				addInstruction(GrOpcode.FieldStore_Float, isExpectingValue ? 0 : -1, true);
				break;
			case StringType:
				addInstruction(GrOpcode.FieldStore_String, isExpectingValue ? 0 : -1, true);
				break;
			case UserType:
			case ReferenceType:
			case ChanType:
			case ArrayType:
			case ObjectType:
				addInstruction(GrOpcode.FieldStore_Object, isExpectingValue ? 0 : -1, true);
				break;
            case VoidType:
            case InternalTupleType:
				logError("Invalid type", "Cannot assign to a \'" ~ to!string(variable.type) ~ "\' type");
			} 
        }
		else if(variable.isGlobal) {
			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
				addInstruction(isExpectingValue ? GrOpcode.GlobalStore2_Int : GrOpcode.GlobalStore_Int, variable.register);
				break;
			case FloatType:
				addInstruction(isExpectingValue ? GrOpcode.GlobalStore2_Float : GrOpcode.GlobalStore_Float, variable.register);
				break;
			case StringType:
				addInstruction(isExpectingValue ? GrOpcode.GlobalStore2_String : GrOpcode.GlobalStore_String, variable.register);
				break;
            case ChanType:
			case ObjectType:
            case ArrayType:
            case UserType:
				addInstruction(isExpectingValue ? GrOpcode.GlobalStore2_Object : GrOpcode.GlobalStore_Object, variable.register);
				break;
			default:
				logError("Invalid type", "Cannot assign to a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
		else {
			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
				addInstruction(isExpectingValue ? GrOpcode.LocalStore2_Int : GrOpcode.LocalStore_Int, variable.register);
				break;
			case FloatType:
				addInstruction(isExpectingValue ? GrOpcode.LocalStore2_Float : GrOpcode.LocalStore_Float, variable.register);
				break;
			case StringType:
				addInstruction(isExpectingValue ? GrOpcode.LocalStore2_String : GrOpcode.LocalStore_String, variable.register);
				break;
			case ObjectType:
				addInstruction(isExpectingValue ? GrOpcode.LocalStore2_Object : GrOpcode.LocalStore_Object, variable.register);
				break;
            case ArrayType:
            case UserType:
			case ChanType:
				addInstruction(isExpectingValue ? GrOpcode.LocalStore2_Object : GrOpcode.LocalStore_Object, variable.register);
				break;
			default:
				logError("Invalid type", "Cannot assign to a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
	}
    
    ///Add a load opcode, or optimize a previous store.
	void addGetInstruction(GrVariable variable, GrType expectedType = GrType(GrBaseType.VoidType), bool allowOptimization = true) {
        if(_lastAssignationScopeLevel != _blockLevel) {
            /+--------------------------
                Optimizing getters should take care of scope levels as jumps will break the VM.
                This shouldn't be optimized as the stack will be empty on the second pass.
                "main {
                    bool a = true;
                    loop {
                        if(a) {}  //a is just after a = true, so will be optimized.
                        yield;
                    } //We jump back to the loop where lstore2 is, crashing the VM.
                }"
                To avoid that, we disallow optimization of different scope levels.
            -------------------------+/
            allowOptimization = false;
        }

        if(variable.isField) {
            logError("Internal error", "Attempt to get field value");
        }
        else if(variable.isGlobal) {
			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
                if(allowOptimization
                    && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_Int
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_Int;
                else
                    addInstruction(GrOpcode.GlobalLoad_Int, variable.register);
				break;
			case FloatType:
                if(allowOptimization
                    && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_Float
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_Float;
                else
                    addInstruction(GrOpcode.GlobalLoad_Float, variable.register);
				break;
			case StringType:
                if(allowOptimization
                    && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_String
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_String;
                else
                    addInstruction(GrOpcode.GlobalLoad_String, variable.register);
				break;
			case ObjectType:
                if(allowOptimization
                    && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_Object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_Object;
                else
                    addInstruction(GrOpcode.GlobalLoad_Object, variable.register);
				break;
            case ArrayType:
            case UserType:
			case ChanType:
                if(allowOptimization
                    && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_Object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_Object;
                else
                    addInstruction(GrOpcode.GlobalLoad_Object, variable.register);
				break;
			default:
				logError("Invalid type", "Cannot fetch from a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
		else {
            if(!variable.isInitialized)
                logError("Uninitialized variable", "The local variable is being used without being assigned");
            
			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
                if(allowOptimization
                    && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_Int
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_Int;
                else
                    addInstruction(GrOpcode.LocalLoad_Int, variable.register);
				break;
			case FloatType:
                if(allowOptimization
                    && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_Float
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_Float;
                else
                    addInstruction(GrOpcode.LocalLoad_Float, variable.register);
				break;
			case StringType:
                if(allowOptimization
                    && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_String
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_String;
                else
                    addInstruction(GrOpcode.LocalLoad_String, variable.register);
				break;
			case ObjectType:
                if(allowOptimization
                    && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_Object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_Object;
                else
                    addInstruction(GrOpcode.LocalLoad_Object, variable.register);
				break;
            case ArrayType:
            case UserType:
			case ChanType:
                if(allowOptimization
                    && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_Object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_Object;
                else
                    addInstruction(GrOpcode.LocalLoad_Object, variable.register);
				break;
			default:
				logError("Invalid type", "Cannot fetch from a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
	}

    private GrType addFunctionAddress(dstring mangledName) {
        GrFunctionCall call = new GrFunctionCall;
		call.mangledName = mangledName;
		call.caller = currentFunction;
		functionCalls ~= call;
		currentFunction.functionCalls ~= call;
        call.isAddress = true;
		auto func = (call.mangledName in functions);
        if(func is null)
            func = (call.mangledName in anonymousFunctions);
		if(func !is null) {
		    call.functionToCall = *func;
            call.isAddress = true;
            call.position = cast(uint)currentFunction.instructions.length;
            addInstruction(GrOpcode.Const_Int, 0);

            return grGetFunctionAsType(*func);
        }

		return GrType(GrBaseType.VoidType);
    }

	GrType[] addFunctionCall(dstring mangledName) {
		GrFunctionCall call = new GrFunctionCall;
		call.mangledName = mangledName;
		call.caller = currentFunction;
		functionCalls ~= call;
		currentFunction.functionCalls ~= call;
        call.isAddress = false;

		auto func = (call.mangledName in functions);
		if(func !is null) {
			call.functionToCall = *func;
            if(func.isTask) {
                if(func.nbIntegerParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Int, func.nbIntegerParameters);
                if(func.nbFloatParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Float, func.nbFloatParameters);
                if(func.nbStringParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_String, func.nbStringParameters);
                if(func.nbObjectParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Object, func.nbObjectParameters);
            }

            call.position = cast(uint)currentFunction.instructions.length;
            addInstruction(GrOpcode.Call, 0);

			return func.outSignature;
		}
		else
			logError("Undeclared function", "The function \'" ~ grGetPrettyFunctionCall(call.mangledName) ~ "\' is not declared", -1);

		return [];
	}

	void setOpcode(ref uint[] opcodes, uint position, GrOpcode opcode, uint value = 0u, bool isSigned = false) {
		assert(position != 0);
        GrInstruction instruction;
		instruction.opcode = opcode;
		if(isSigned) {
			if((value >= 0x800000) || (-value >= 0x800000))
				logError("Internal failure", "An opcode\'s signed value is exceeding limits");	
			instruction.value = value + 0x800000;
		}
		else
			instruction.value = value;

		uint makeOpcode(uint instr, uint value) {
			return ((value << 8u) & 0xffffff00) | (instr & 0xff);
		}
		opcodes[position] = makeOpcode(cast(uint)instruction.opcode, instruction.value);
	}

	void solveFunctionCalls(ref uint[] opcodes) {
		foreach(GrFunctionCall call; functionCalls) {
			auto func = (call.mangledName in functions);
            if(func is null)
                func = (call.mangledName in anonymousFunctions);
			if(func !is null) {
                if(call.isAddress)
                    setOpcode(opcodes, call.position, GrOpcode.Const_Int, registerIntConstant(func.position));
				else if(func.isTask)
					setOpcode(opcodes, call.position, GrOpcode.Task, func.position);
				else
					setOpcode(opcodes, call.position, GrOpcode.Call, func.position);
			}
			else
				logError("Undeclared function", "The function \'" ~ to!string(call.mangledName) ~ "\' is not declared");
		}

		foreach(func; anonymousFunctions)
			setOpcode(opcodes, func.anonParent.position + func.anonParent.offset + func.anonReference, GrOpcode.Const_Int, registerIntConstant(func.position));
	}

	void dump() {
		writeln("Code Generated:\n");
		foreach(size_t i, int ivalue; iconsts)
			writeln(".iconst " ~ to!string(ivalue) ~ "\t;" ~ to!string(i));

		foreach(size_t i, float fvalue; fconsts)
			writeln(".fconst " ~ to!string(fvalue) ~ "\t;" ~ to!string(i));

		foreach(size_t i, dstring svalue; sconsts)
			writeln(".sconst " ~ to!string(svalue) ~ "\t;" ~ to!string(i));

		foreach(dstring funcName, GrFunction func; functions) {
			if(func.isTask)
				writeln("\n.task " ~ funcName);
			else
				writeln("\n.function " ~ funcName);

			foreach(size_t i, GrInstruction instruction; func.instructions) {
				writeln("[" ~ to!string(i) ~ "] " ~ to!string(instruction.opcode) ~ " " ~ to!string(instruction.value));
			}
		}
	}

	void parseScript(GrData data, GrLexer lexer) {
        _data = data;
		preParseScript(lexer);
		reset();

		lexemes = lexer.lexemes;

		while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Semicolon:
                checkAdvance();
                break;
            case Tuple:
            case Object:
                skipDeclaration();
                break;
			case Main:
				parseMainDeclaration();
				break;
            case Event:
                parseEventDeclaration();
                break;
			case TaskType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				parseTaskDeclaration();
				break;
			case FunctionType:
                if(get(1).type != GrLexemeType.Identifier &&
                    get(1).type != GrLexemeType.As)
                    goto case VoidType;
				parseFunctionDeclaration();
				break;
            case VoidType: .. case ArrayType:
            case AutoType:
            case Identifier:
                skipExpression();
                break;
			default:
				logError("Invalid type", "The type should be either main, func or task");
			}
		}
/*
        foreach(variable; globalVariables) {
            const auto counter = countSubTypes(variable.type);
            iglobalsCount += counter.iCount;
            fglobalsCount += counter.fCount;
            sglobalsCount += counter.sCount;
            oglobalsCount += counter.oCount;
        }*/
	}

	void preParseScript(GrLexer lexer) {
		lexemes = lexer.lexemes;

        //Tuple definitions
        while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Semicolon:
                checkAdvance();
                break;
            case Object:
                parseStructDeclaration();
                break;
			case Main:
            case Event:
			case TaskType:
			case FunctionType:
				skipDeclaration();
				break;
			default:
				skipExpression();
                break;
			}
		}

        // Finish definitions and signatures.
        _data.resolveSignatures();
        
        //Function definitions
        reset();
		while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Semicolon:
                checkAdvance();
                break;
            case Tuple:
            case Object:
                skipDeclaration();
                break;
			case Main:
				preParseMainDeclaration();
				break;
            case Event:
                preParseEventDeclaration();
                break;
			case TaskType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				preParseTaskDeclaration();
				break;
			case FunctionType:
                if(get(1).type != GrLexemeType.Identifier &&
                    get(1).type != GrLexemeType.As)
                    goto case VoidType;
				preParseFunctionDeclaration();
				break;
            case VoidType: .. case ArrayType:
            case AutoType:
            case Identifier:
                skipExpression();
                break;
			default:
				logError("Invalid type", "The type should be either main, func, task or struct");
			}
		}

        //Global variable definitions
        reset();
        beginGlobalScope();
		while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Semicolon:
                checkAdvance();
                break;
            case Event:
            case Tuple:
            case Object:
			case Main:
				skipDeclaration();
				break;
			case TaskType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				skipDeclaration();
				break;
			case FunctionType:
                if(get(1).type != GrLexemeType.Identifier &&
                    get(1).type != GrLexemeType.As)
                    goto case VoidType;
                skipDeclaration();
                break;
            case VoidType: .. case ArrayType:
            case AutoType:
                parseGlobalDeclaration();
                break;
            case Identifier:
                if(_data.isUserType(get().svalue)) {
                    parseGlobalDeclaration();
                    break;
                }
                goto default;
			default:
				logError("Invalid type", "The type should be either main, func, task or struct");
			}
		}
        endGlobalScope();
	}

    void parseStructDeclaration() {
		checkAdvance();
        if(get().type != GrLexemeType.Identifier)
            logError("Missing Identifier", "struct must have a name");
        dstring structName = get().svalue;
        checkAdvance();
        if(get().type != GrLexemeType.LeftCurlyBrace)
            logError("Missing {", "struct does not have a body");
        checkAdvance();

        dstring[] fields;
        GrType[] signature;
        while(!isEnd()) {
            if(get().type == GrLexemeType.VoidType)
                logError("Field type error", "Void is not a valid field type");
            else if(get().type == GrLexemeType.RightCurlyBrace) {
                checkAdvance();
                break;
            }

            //Lazy check because we can't know about other structs
            auto fieldType = parseType(false);
            do {
                if(get().type == GrLexemeType.Comma)
                    checkAdvance();

                //Unresolved type
                if(fieldType.baseType == GrBaseType.VoidType) {
                    fieldType.mangledType = get().svalue;
                    checkAdvance();
                }
                
                if(get().type != GrLexemeType.Identifier)
                    logError("Missing Identifier", "struct field must have a name");

                auto fieldName = get().svalue;
                checkAdvance();

                signature ~= fieldType;
                fields ~= fieldName;
            }
            while(get().type == GrLexemeType.Comma);

            if(get().type != GrLexemeType.Semicolon)
                logError("Missing semicolon", "A struct field declaration must end with a semicolon");
            checkAdvance();

            if(get().type == GrLexemeType.RightCurlyBrace) {
                checkAdvance();
                break;
            }
        }
        _data.addObject(structName, fields, signature);
    }

    void skipDeclaration() {
        checkAdvance();
        while(!isEnd()) {
            if(get().type != GrLexemeType.LeftCurlyBrace) {
                checkAdvance();
            }
            else {
                skipBlock();
                return;
            }
        }
    }

    void skipExpression() {
        checkAdvance();
        while(!isEnd()) {
            switch(get().type) with(GrLexemeType) {
            case Semicolon:
                checkAdvance();
                return;
            case LeftCurlyBrace:
                skipBlock();
                break;
            default:
                checkAdvance();
                break;
            }
        }
    }

    GrType parseType(bool mustBeType = true) {
        GrType currentType = GrBaseType.VoidType;

        GrLexeme lex = get();
        if(!lex.isType) {
            if(lex.type == GrLexemeType.Identifier && _data.isObject(lex.svalue)) {
                currentType.baseType = GrBaseType.ObjectType;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                return currentType;
            }
            else if(lex.type == GrLexemeType.Identifier && _data.isUserType(lex.svalue)) {
                currentType.baseType = GrBaseType.UserType;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                return currentType;
            }
            else if(mustBeType) {
                logError("Excepted type", "A valid type is expected");
            }
            else {
                return currentType;
            }
        }

        switch(lex.type) with(GrLexemeType) {
        case VoidType:
            currentType.baseType = GrBaseType.VoidType;
            checkAdvance();
            break;
        case IntType:
            currentType.baseType = GrBaseType.IntType;
            checkAdvance();
            break;
        case FloatType:
            currentType.baseType = GrBaseType.FloatType;
            checkAdvance();
            break;
        case BoolType:
            currentType.baseType = GrBaseType.BoolType;
            checkAdvance();
            break;
        case StringType:
            currentType.baseType = GrBaseType.StringType;
            checkAdvance();
            break;
        case ArrayType:
            currentType.baseType = GrBaseType.ArrayType;
            dstring[] temp;
            auto signature = parseInSignature(temp, true);
            if(signature.length > 1)
                logError("Array type error", "Arrays can only have one type");
            currentType.mangledType = grMangleFunction(signature);
            break;
        case FunctionType:
            currentType.baseType = GrBaseType.FunctionType;
            dstring[] temp;
            currentType.mangledType = grMangleFunction(parseInSignature(temp, true));
            currentType.mangledReturnType = grMangleFunction(parseOutSignature());
            break;
        case TaskType:
            currentType.baseType = GrBaseType.TaskType;
            dstring[] temp;
            currentType.mangledType = grMangleFunction(parseInSignature(temp, true));
            break;
        case ChanType:
            currentType.baseType = GrBaseType.ChanType;
            dstring[] temp;
            GrType[] signature = parseInSignature(temp, true);
            if(signature.length != 1)
                logError("Channel signature error", "A channel can only carry one type");
            currentType.mangledType = grMangleFunction(signature);
            break;    
        default:
            logError("Invalid type", "Cannot call a function with a parameter of type \'" ~ to!string(lex.type) ~ "\'");
        }

        return currentType;
    }

    void addGlobalPop(GrType type) {
        final switch(type.baseType) with(GrBaseType) {
        case VoidType:
            logError("Invalid type", "Void is not a valid parameter type");
            break;
        case IntType:
        case BoolType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.GlobalPop_Int, 0u);
            break;
        case FloatType:
            addInstruction(GrOpcode.GlobalPop_Float, 0u);
            break;
        case StringType:
            addInstruction(GrOpcode.GlobalPop_String, 0u);
            break;
        case ObjectType:
        case ArrayType:
        case UserType:
        case ChanType:
        case ReferenceType:
            addInstruction(GrOpcode.GlobalPop_Object, 0u);
            break;
        case InternalTupleType:
            throw new Exception("Tuples should not exist here.");
        }
    }

    void addGlobalPush(GrType type, int nbPush = 1u) {
        if(nbPush == 0)
            return;
        final switch(type.baseType) with(GrBaseType) {
        case VoidType:
            logError("Invalid type", "Void is not a valid parameter type");
            break;
        case IntType:
        case BoolType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.GlobalPush_Int, nbPush);
            break;
        case FloatType:
            addInstruction(GrOpcode.GlobalPush_Float, nbPush);
            break;
        case StringType:
            addInstruction(GrOpcode.GlobalPush_String, nbPush);
            break;
        case ObjectType:
        case ArrayType:
        case UserType:
        case ChanType:
        case ReferenceType:
            addInstruction(GrOpcode.GlobalPush_Object, nbPush);
            break;
        case InternalTupleType:
            throw new Exception("Tuples should not exist here.");
        }
    }

    void addGlobalPush(GrType[] signature) {
        struct TypeCounter {
            uint nbIntParams, nbFloatParams, nbStringParams, nbObjectParams;
        }
        void countParameters(ref TypeCounter typeCounter, GrType type) {
            final switch(type.baseType) with(GrBaseType) {
            case VoidType:
                logError("Invalid type", "Void is not a valid parameter type");
                break;
            case IntType:
            case BoolType:
            case FunctionType:
            case TaskType:
                typeCounter.nbIntParams ++;
                break;
            case FloatType:
                typeCounter.nbFloatParams ++;
                break;
            case StringType:
                typeCounter.nbStringParams ++;
                break;
            case ObjectType:
            case ArrayType:
            case UserType:
            case ChanType:
            case ReferenceType:
                typeCounter.nbObjectParams ++;
                break;
            case InternalTupleType:
                throw new Exception("Tuples should not exist here.");
            }
        }

        TypeCounter typeCounter;
        foreach(type; signature) {
            countParameters(typeCounter, type);
        }

        if(typeCounter.nbIntParams > 0)
            addInstruction(GrOpcode.GlobalPush_Int, typeCounter.nbIntParams);
        if(typeCounter.nbFloatParams > 0)
            addInstruction(GrOpcode.GlobalPush_Float, typeCounter.nbFloatParams);
        if(typeCounter.nbStringParams > 0)
            addInstruction(GrOpcode.GlobalPush_String, typeCounter.nbStringParams);
        if(typeCounter.nbObjectParams > 0)
            addInstruction(GrOpcode.GlobalPush_Object, typeCounter.nbObjectParams);
    }

	GrType[] parseInSignature(ref dstring[] inputVariables, bool asType = false) {
		GrType[] inSignature;

		checkAdvance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A signature should always start with \'(\'");

        bool startLoop = true;
		for(;;) {
			checkAdvance();
			GrLexeme lex = get();

			if(startLoop && lex.type == GrLexemeType.RightParenthesis)
				break;
            startLoop = false;
            
            inSignature ~= parseType();

            //If we want to know whether it's a type or an anon, we can't throw exceptions.
            if(isTypeChecking) {
                lex = get();
                if(get().type == GrLexemeType.Identifier) {
                    inputVariables ~= lex.svalue;
                    checkAdvance();
                    lex = get();
                }
                
                if(lex.type == GrLexemeType.RightParenthesis)
                    break;
                else if(lex.type != GrLexemeType.Comma)
                    logError("Missing symbol", "Either a \',\' or a \')\' is expected");
            }
            else {
                //Is it a function type or a function declaration ?
                if(!asType) {
                    lex = get();
                    if(get().type != GrLexemeType.Identifier)
                        logError("Missing identifier", "Expected a name such as \'foo\'");
                    inputVariables ~= lex.svalue;
                    checkAdvance();
                }

                lex = get();
                if(lex.type == GrLexemeType.RightParenthesis)
                    break;
                else if(lex.type != GrLexemeType.Comma)
                    logError("Missing symbol", "Either a \',\' or a \')\' is expected");
            }
		}
		checkAdvance();

		return inSignature;
	}

    GrType[] parseOutSignature() {
		GrType[] outSignature;
        bool startLoop = true;
		for(;;) {
			GrLexeme lex = get();
            
            auto type = parseType(false);
            if(type.baseType != GrBaseType.VoidType)
                outSignature ~= type;

            lex = get();
            if(lex.type != GrLexemeType.Comma)
                break;
            checkAdvance();
		}
		return outSignature;
	}

	void parseMainDeclaration() {
		checkAdvance();
		beginFunction("main", []);
        
        openDeferrableSection();
		parseBlock();
		if(!currentFunction.instructions.length
            || currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
            addKill();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
	}

	void preParseMainDeclaration() {
		checkAdvance();
		preBeginFunction("main", [], [], false);
		skipBlock();
		preEndFunction();
	}

    void parseEventDeclaration() {
        checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
		dstring[] inputs;
		GrType[] signature = parseInSignature(inputs);
		beginFunction(name, signature, true);
        
        openDeferrableSection();
		parseBlock();
		if(!currentFunction.instructions.length
            || currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
            addKill();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
    }

    void preParseEventDeclaration() {
        checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
		dstring[] inputs;
		GrType[] signature = parseInSignature(inputs);
		preBeginFunction(name, signature, inputs, false, [], false, true);
		skipBlock();
		preEndFunction();
    }

	void parseTaskDeclaration() {
		checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
        const auto previousVariable = (name in globalVariables);
        if(previousVariable !is null)
            logError("Multiple declaration", "The identifier \'" ~ to!string(name) ~ "\' is already declared as a global variable");
		dstring[] inputs;
		GrType[] signature = parseInSignature(inputs);
		beginFunction(name, signature);

        openDeferrableSection();
		parseBlock();
		if(!currentFunction.instructions.length
            || currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
            addKill();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
	}

	void preParseTaskDeclaration() {
		checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
		dstring[] inputs;
		GrType[] signature = parseInSignature(inputs);
		preBeginFunction(name, signature, inputs, true);
		skipBlock();
		preEndFunction();
	}

	void parseFunctionDeclaration() {
		checkAdvance();
        dstring name;
        bool isConversion;
        if(get().type == GrLexemeType.As) {
            name = "@as";
            isConversion = true;
        }
        else {
            if(get().type != GrLexemeType.Identifier)
                logError("Missing identifier", "Expected a name such as \'foo\'");
            name = get().svalue;

            if(name == "operator") {
                checkAdvance();
                if(get().type >= GrLexemeType.Add && get().type <= GrLexemeType.Not) {
                    name = "@op_" ~ grGetPrettyLexemeType(get().type);
                }
                else
                    logError("Invalid Operator", "The specified operator must be valid");
            }
        }
        const auto previousVariable = (name in globalVariables);
        if(previousVariable !is null)
            logError("Multiple declaration", "The identifier \'" ~ to!string(name) ~ "\' is already declared as a global variable");
		dstring[] inputs;
		GrType[] signature = parseInSignature(inputs);

        if(isConversion) {
            if(signature.length != 1uL)
                logError("Invalid format", "A conversion function has to take only 1 parameter and be non-void");
            GrType[] outSignature = parseOutSignature();
            if(outSignature.length != 1uL)
                logError("Invalid format", "A conversion function has to take only 1 parameter and be non-void");

            signature ~= outSignature[0];
        }
        else
            parseOutSignature();

		beginFunction(name, signature);
        openDeferrableSection();
		parseBlock();
        if(!currentFunction.outSignature.length) {
            if(!currentFunction.instructions.length
                || currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
                addReturn();
        }
        else {
            if(!currentFunction.instructions.length
                || currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
                logError("Missing return", "The function is missing a return at the end of the scope");
        }
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
	}

	void preParseFunctionDeclaration() {
		checkAdvance();
        dstring name;
        bool isConversion;
        if(get().type == GrLexemeType.As) {
            name = "@as";
            isConversion = true;
        }
        else {
            if(get().type != GrLexemeType.Identifier)
                logError("Missing identifier", "Expected a name such as \'foo\'");
            name = get().svalue;
            if(name == "operator") {
                checkAdvance();
                if(get().type >= GrLexemeType.Add && get().type <= GrLexemeType.Not) {
                    name = "@op_" ~ grGetPrettyLexemeType(get().type);
                }
                else
                    logError("Invalid Operator", "The specified operator must be valid");
            }
        }
		dstring[] inputs;
		GrType[] inSignature = parseInSignature(inputs);

		//Return Type.
        GrType[] outSignature;
        if(isConversion) {
            if(inSignature.length != 1uL)
                logError("Invalid format", "A conversion function has to take only 1 parameter");
            outSignature = parseOutSignature();
            if(outSignature.length != 1uL)
                logError("Invalid format", "A conversion function can only have 1 return type");

            inSignature ~= outSignature[0];
        }
        else
            outSignature = parseOutSignature();

		preBeginFunction(name, inSignature, inputs, false, outSignature);
		skipBlock();
		preEndFunction();
	}

	GrType parseAnonymousFunction(bool isTask) {
		dstring[] inputs;
		GrType[] outSignature;
		GrType[] inSignature = parseInSignature(inputs);

		if(!isTask) {
			//Return Type.
            outSignature = parseOutSignature();
		}
		preBeginFunction("$anon"d, inSignature, inputs, isTask, outSignature, true);

        openDeferrableSection();
		parseBlock();

        if(isTask) {
            if(!currentFunction.instructions.length || currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
                addKill();
        }
        else {
            if(!outSignature.length) {
                if(!currentFunction.instructions.length || currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
                    addReturn();
            }
            else {
                if(!currentFunction.instructions.length || currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
                    logError("Missing return", "The function is missing a return at the end of the scope");
            }
        }
            
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();

        GrType functionType = isTask ? GrBaseType.TaskType : GrBaseType.FunctionType;
        functionType.mangledType = grMangleNamedFunction("", inSignature);
        functionType.mangledReturnType = grMangleNamedFunction("", outSignature);


        return functionType;
	}

    /**
    Parse either multiple lines between `{` and `}` or a single expression.
    */
	void parseBlock(bool changeOptimizationBlockLevel = false) {
        if(changeOptimizationBlockLevel)
            _blockLevel ++;
        bool isMultiline;
		if(get().type == GrLexemeType.LeftCurlyBrace) {
            isMultiline = true;
            if(!checkAdvance())
                logError("Unexpected end of file", "Missing }");
        }
		openBlock();

		void parseStatement() {
            switch(get().type) with(GrLexemeType) {
            case Semicolon:
            case RightCurlyBrace:
                advance();
                break;
            case Defer:
                parseDeferStatement();
                break;
            case If:
            case Unless:
                parseIfStatement();
                break;
            case Switch:
                parseSwitchStatement();
                break;
            case Select:
                parseSelectStatement();
                break;
            case Until:
            case While:
                parseWhileStatement();
                break;
            case Do:
                parseDoWhileStatement();
                break;
            case For:
                parseForStatement();
                break;
            case Loop:
                parseLoopStatement();
                break;
            case Raise:
                parseRaiseStatement();
                break;
            case Try:
                parseExceptionHandler();
                break;
            case Return:
                parseReturnStatement();
                break;
            case Kill:
                parseKill();
                break;
            case KillAll:
                parseKillAll();
                break;
            case Yield:
                parseYield();
                break;
            case Continue:
                parseContinue();
                break;
            case Break:
                parseBreak();
                break;
            case VoidType: .. case AutoType:
                if(isDeclaration())
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            case Identifier:
                if(_data.isObject(get().svalue) || _data.isUserType(get().svalue))
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            default:
                parseExpression();
                break;
            }
        }

        if(isMultiline) {
            while(!isEnd()) {
                if(get().type == GrLexemeType.RightCurlyBrace)
                    break;
                parseStatement();
            }
        }
        else {
            if(get().type != GrLexemeType.Semicolon)
                parseStatement();
        }

        if(isMultiline) {
            if(get().type != GrLexemeType.RightCurlyBrace)
                logError("Missing symbol", "A block should always end with \'}\'");
            checkAdvance();
        }
		closeBlock();
        if(changeOptimizationBlockLevel)
            _blockLevel --;
	}

    bool isDeclaration() {
        const auto tempPos = current;
        isTypeChecking = true;
        if(get().type == GrLexemeType.AutoType)
            checkAdvance();
        else
            parseType(false);
        isTypeChecking = false;
        bool isDecl;
        if(get().type == GrLexemeType.Identifier)
            isDecl = true;
        current = tempPos;
        return isDecl;
    }

	void skipBlock() {
		bool isMultiline;
		if(get().type == GrLexemeType.LeftCurlyBrace) {
            isMultiline = true;
            if(!checkAdvance())
                logError("Unexpected end of file", "Missing }");
        }
		openBlock();

		void skipStatement() {
            switch(get().type) with(GrLexemeType) {
            case LeftParenthesis:
                skipParenthesis();
                break;
            case LeftBracket:
                skipBrackets();
                break;
			case LeftCurlyBrace:
				skipBlock();
				break;
            case Defer:
                checkAdvance();
                skipBlock();
                break;
            case Switch:
                checkAdvance();
                skipParenthesis();
                while(get().type == GrLexemeType.Case) {
                    checkAdvance();
                    if(get().type == GrLexemeType.LeftParenthesis)
                        skipParenthesis();
                    skipBlock();
                }
                break;
            case If:
            case Unless:
                checkAdvance();
                skipParenthesis();
                skipBlock();
                break;
            case Select:
                checkAdvance();
                while(get().type == GrLexemeType.Case) {
                    checkAdvance();
                    if(get().type == GrLexemeType.LeftParenthesis)
                        skipParenthesis();
                    skipBlock();
                }
                break;
            case Until:
            case While:
                checkAdvance();
                skipBlock();
                break;
            case Do:
                checkAdvance();
                skipBlock();
                checkAdvance();
                skipParenthesis();
                break;
            case For:
                checkAdvance();
                skipParenthesis();
                skipBlock();
                break;
            case Loop:
                checkAdvance();
                if(get().type == GrLexemeType.LeftParenthesis)
                    skipParenthesis();
                skipBlock();
                break;
            case Raise:
                checkAdvance();
                skipBlock();
                break;
            case Try:
                checkAdvance();
                skipBlock();
                if(get().type == GrLexemeType.Catch) {
                    checkAdvance();
                    skipParenthesis();
                    skipBlock();
                }
                break;
            case Yield:
                checkAdvance();
                break;
            case Return:
                checkAdvance();
                skipBlock();
                break;
			default:
				checkAdvance();
				break;
			}
        }
		
		if(isMultiline) {
            while(!isEnd()) {
                if(get().type == GrLexemeType.RightCurlyBrace)
                    break;
                switch(get().type) with(GrLexemeType) {
                case LeftParenthesis:
                    skipParenthesis();
                    break;
                case LeftBracket:
                    skipBrackets();
                    break;
                case LeftCurlyBrace:
                    skipBlock();
                    break;
                default:
                    checkAdvance();
                    break;
                }
            }

            if(get().type != GrLexemeType.RightCurlyBrace)
                logError("Missing symbol", "A block should always end with \'}\'");
            checkAdvance(); 
        }
        else {
            if(get().type != GrLexemeType.Semicolon)
                skipStatement();
        }
		closeBlock();
	}

    void parseKill() {
        if(!currentFunction.instructions.length || currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
            addKill();
        advance();
    }

    void parseKillAll() {
        if(!currentFunction.instructions.length || currentFunction.instructions[$ - 1].opcode != GrOpcode.KillAll)
            addKillAll();
        advance();                
    }

    void parseYield() {
		addInstruction(GrOpcode.Yield, 0u);
        advance();
    }

    //Exception handling
    void parseRaiseStatement() {
        advance();
        GrType type = parseSubExpression(GR_SUBEXPR_TERMINATE_SEMICOLON).type;
        checkAdvance();
        convertType(type, grString);
        addInstruction(GrOpcode.Raise);
        checkDeferStatement();
    }

    void parseExceptionHandler() {
        advance();

        const auto tryPosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.Try);

        parseBlock();

        if(get().type != GrLexemeType.Catch)
            logError("Missing catch", "A try must be followed by a catch statement");
        advance();

        if(get().type != GrLexemeType.LeftParenthesis)
            logError("Missing (", "");
        advance();

        if(get().type != GrLexemeType.Identifier)
            logError("Missing identifier", "");
        GrVariable errVariable = registerLocalVariable(get().svalue, grString);

        advance();
        if(get().type != GrLexemeType.RightParenthesis)
            logError("Missing )", "");
        advance();

        const auto catchPosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.Catch);

        addInstruction(GrOpcode.GlobalPop_String);
        addSetInstruction(errVariable, grString);

        parseBlock(true);

        const auto endPosition = currentFunction.instructions.length;


        setInstruction(GrOpcode.Try, cast(uint)tryPosition, cast(uint)(catchPosition - tryPosition), true);
        setInstruction(GrOpcode.Catch, cast(uint)catchPosition, cast(uint)(endPosition - catchPosition), true);
    }

    //Defer
    void openDeferrableSection() {
        auto deferrableSection = new GrDeferrableSection;
        deferrableSection.deferInitPositions = cast(uint)currentFunction.instructions.length;
        currentFunction.deferrableSections ~= deferrableSection;

        currentFunction.isDeferrableSectionLocked.length ++;
    }

    void closeDeferrableSection() {
        if(!currentFunction.deferrableSections.length)
            logError("Deferrable section error", "A deferrable section had a mismatch");

        foreach(deferBlock; currentFunction.deferrableSections[$ - 1].deferredBlocks) {
            currentFunction.registeredDeferBlocks ~= deferBlock;
        }

        currentFunction.deferrableSections.length --;
        currentFunction.isDeferrableSectionLocked.length --;
    }

    void parseDeferStatement() {
        if(currentFunction.isDeferrableSectionLocked[$ - 1])
            logError("Invalid instruction", "You cannot use a defer statement inside another defer");
        advance();

        //Register the position of the block for a late parsing.
        GrDeferBlock deferBlock = new GrDeferBlock;
        deferBlock.position = cast(uint)currentFunction.instructions.length;
        deferBlock.parsePosition = current;
        deferBlock.scopeLevel = scopeLevel;
        currentFunction.deferrableSections[$ - 1].deferredBlocks ~= deferBlock;

        addInstruction(GrOpcode.Defer);

        //Parse the deferred block at the end of the outer block.
        skipBlock();
    }
    
    void checkDeferStatement() {
        if(currentFunction.isDeferrableSectionLocked[$ - 1])
            logError("Invalid instruction", "You cannot use a flow-control statement in a defer");
    }

    void registerDeferBlocks() {
        const auto tempParsePosition = current;
        const auto startDeferPos = cast(uint)currentFunction.instructions.length;
        
        int tempScopeLevel = scopeLevel;
        while(currentFunction.registeredDeferBlocks.length) {
            GrDeferBlock deferBlock = currentFunction.registeredDeferBlocks[0];
            currentFunction.registeredDeferBlocks = currentFunction.registeredDeferBlocks[1 .. $];

            setInstruction(GrOpcode.Defer, deferBlock.position, cast(int)(currentFunction.instructions.length - deferBlock.position), true);
            current = deferBlock.parsePosition;
            scopeLevel = deferBlock.scopeLevel;

            currentFunction.isDeferrableSectionLocked[$ - 1] = true;
            parseBlock(true);
            currentFunction.isDeferrableSectionLocked[$ - 1] = false;

            addInstruction(GrOpcode.Unwind);
        }
        currentFunction.registeredDeferBlocks.length = 0;
        current = tempParsePosition;
        scopeLevel = tempScopeLevel;
    }

	//Break
	void openBreakableSection() {
		breaksJumps ~= [null];
	}

	void closeBreakableSection() {
		if(!breaksJumps.length)
			logError("Breakable section error", "A breakable section had a mismatch");

		uint[] breaks = breaksJumps[$ - 1];
		breaksJumps.length --;

		foreach(position; breaks)
			setInstruction(GrOpcode.Jump, position, cast(int)(currentFunction.instructions.length - position), true);
	}

	void parseBreak() {
		if(!breaksJumps.length)
			logError("Non breakable statement", "The break statement is not inside a breakable statement");

        checkDeferStatement();
		breaksJumps[$ - 1] ~= cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.Jump);
		advance();
	}

	//Continue
	void openContinuableSection() {
		continuesJumps ~= [null];
	}

	void closeContinuableSection() {
		if(!continuesJumps.length)
			logError("Continuable section error", "A continuable section had a mismatch");

		uint[] continues = continuesJumps[$ - 1];
		uint destination = continuesDestinations[$ - 1];
		continuesJumps.length --;
		continuesDestinations.length --;

		foreach(position; continues)
			setInstruction(GrOpcode.Jump, position, cast(int)(position - destination), true);
	}

	void setContinuableSectionDestination() {
		continuesDestinations ~= cast(uint)currentFunction.instructions.length;
	}

	void parseContinue() {
		if(!continuesJumps.length)
			logError("Non continuable statement", "The continue statement is not inside a continuable statement");

        checkDeferStatement();
		continuesJumps[$ - 1] ~= cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.Jump);
		advance();
	}

    void parseGlobalDeclaration() {
        //GrVariable type
        GrType type = GrBaseType.VoidType;
        bool isAuto;
        if(get().type == GrLexemeType.AutoType) {
            isAuto = true;
            checkAdvance();
        }
        else
            type = parseType();

        GrVariable[] lvalues;
        do {
            if(get().type == GrLexemeType.Comma)
                checkAdvance();
            //Identifier
            if(get().type != GrLexemeType.Identifier)
                logError("Missing identifier", "Expected a name such as \'foo\'");

            dstring identifier = get().svalue;

            //Registering
            GrVariable lvalue = registerGlobalVariable(identifier, type, isAuto);
            lvalues ~= lvalue;
            
            checkAdvance();
        }
        while(get().type == GrLexemeType.Comma);

		parseAssignList(lvalues);

        foreach(lvalue; lvalues) {
            if(lvalue.isAuto && !lvalue.isInitialized)
                logError("Declaration error", "Cannot infer a non-initialized global auto-type");
        }
    }

	//Type Identifier [= EXPRESSION] ;
	void parseLocalDeclaration() {
        //GrVariable type
        GrType type = GrBaseType.VoidType;
        bool isAuto;
        if(get().type == GrLexemeType.AutoType) {
            isAuto = true;
            checkAdvance();
        }
        else
            type = parseType();
        
        GrVariable[] lvalues;
        do {
            if(get().type == GrLexemeType.Comma)
                checkAdvance();
            //Identifier
            if(get().type != GrLexemeType.Identifier)
                logError("Missing identifier", "Expected a name such as \'foo\'");

            dstring identifier = get().svalue;

            //Registering
            GrVariable lvalue = registerLocalVariable(identifier, type);
            lvalue.isAuto = isAuto;
            lvalues ~= lvalue;

            //A composite type does not need to be initialized.
            if(lvalue.type == GrBaseType.ObjectType)
                lvalue.isInitialized = true;
            
            checkAdvance();
        }
        while(get().type == GrLexemeType.Comma);

		parseAssignList(lvalues);
	}

    GrType parseFunctionReturnType() {
        GrType returnType = GrBaseType.VoidType;
        if(get().isType) {
            switch(get().type) with(GrLexemeType) {
            case IntType:
                returnType = GrType(GrBaseType.IntType);
                break;
            case FloatType:
                returnType = GrType(GrBaseType.FloatType);
                break;
            case BoolType:
                returnType = GrType(GrBaseType.BoolType);
                break;
            case StringType:
                returnType = GrType(GrBaseType.StringType);
                break;
            case ArrayType:
                returnType = GrType(GrBaseType.ArrayType);
                break;
            case FunctionType:
                GrType type = GrBaseType.FunctionType;
                dstring[] temp; 
                type.mangledType = grMangleNamedFunction("", parseInSignature(temp, true));
                returnType = type;
                break;
            case TaskType:
                GrType type = GrBaseType.TaskType;
                dstring[] temp;
                type.mangledType = grMangleNamedFunction("", parseInSignature(temp, true));
                returnType = type;
                break;
            default:
                logError("Invalid type", "A " ~ to!string(get().type) ~ " is not a valid return type");
            }
            checkAdvance();
        }

        return returnType;
    }

    /**
    ---
    if(SUBEXPR) BLOCK
    else if(SUBEXPR) BLOCK
    else unless(SUBEXPR) BLOCK
    else(SUBEXPR) BLOCK
    ---
    */
	void parseIfStatement() {
        bool isNegative = get().type == GrLexemeType.Unless;
		advance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		advance();
		GrSubExprResult result = parseSubExpression();
        convertType(result.type, grBool);
		advance();

		uint jumpPosition = cast(uint)currentFunction.instructions.length;
        //Jumps to if(0) for "if", if(!= 0) for "unless".
		addInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual);
        
		parseBlock(true); //{ .. }
        
		//If(1){}, jumps out.
		uint[] exitJumps;
		if(get().type == GrLexemeType.Else) {
            exitJumps ~= cast(uint)currentFunction.instructions.length;
            addInstruction(GrOpcode.Jump);
        }

        //Jumps to if(0) for "if", if(!= 0) for "unless".
        setInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual,
            jumpPosition,
            cast(int)(currentFunction.instructions.length - jumpPosition),
            true);

		bool isElseIf;
		do {
			isElseIf = false;
			if(get().type == GrLexemeType.Else) {
				checkAdvance();
				if(get().type == GrLexemeType.If || get().type == GrLexemeType.Unless) {
                    isNegative = get().type == GrLexemeType.Unless;
					isElseIf = true;
					checkAdvance();
					if(get().type != GrLexemeType.LeftParenthesis)
						logError("Missing symbol", "A condition should always start with \'(\'");
					checkAdvance();

					parseSubExpression();
                    advance();

					jumpPosition = cast(uint)currentFunction.instructions.length;
					//Jumps to if(0) for "if", if(!= 0) for "unless".
                    addInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual);

					parseBlock(true); //{ .. }

					//If(1){}, jumps out.
					exitJumps ~= cast(uint)currentFunction.instructions.length;
					addInstruction(GrOpcode.Jump);

					//Jumps to if(0) for "if", if(!= 0) for "unless".
					setInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual,
                        jumpPosition,
                        cast(int)(currentFunction.instructions.length - jumpPosition),
                        true);
				}
				else
					parseBlock(true);
			}
		}
		while(isElseIf);
        
		foreach(uint position; exitJumps)
			setInstruction(GrOpcode.Jump, position, cast(int)(currentFunction.instructions.length - position), true);
	}

    GrType parseChannelBuilder() {
        GrType chanType = GrBaseType.ChanType;
        int channelSize = 1;
        
        checkAdvance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A signature should always start with \'(\'");
		checkAdvance();
        GrType subType = parseType();

        GrLexeme lex = get();
        if(lex.type == GrLexemeType.Comma) {
            checkAdvance();
            lex = get();
            if(lex.type != GrLexemeType.Integer)
                logError("Channel size expected", "The channel size must be a positive int value");
            channelSize = lex.ivalue;
            if(channelSize < 1)
                logError("Channel size error", "The channel size cannot be null");
            checkAdvance();
        }
        lex = get();
        if(lex.type != GrLexemeType.RightParenthesis)
            logError("Missing symbol", "Either a \',\' or a \')\' is expected");
        checkAdvance();
        chanType.mangledType = grMangleFunction([subType]);

        final switch(subType.baseType) with(GrBaseType) {
        case IntType:
        case BoolType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.Channel_Int, channelSize);
            break;
        case FloatType:
            addInstruction(GrOpcode.Channel_Float, channelSize);
            break;
        case StringType:
            addInstruction(GrOpcode.Channel_String, channelSize);
            break;
        case ObjectType:
        case ArrayType:
        case UserType:
        case ChanType:
        case ReferenceType:
            addInstruction(GrOpcode.Channel_Object, channelSize);
            break;
        case VoidType:
        case InternalTupleType:
            logError("Invalid channel type", "invalid channel type");
        }
        return chanType;
    }

    /**
    ---
    switch(SUBEXPR)
    case(SUBEXPR) BLOCK
    case(SUBEXPR) BLOCK
    case() BLOCK
    ---
    */
    void parseSwitchStatement() {
        advance();
        assertError(get().type == GrLexemeType.LeftParenthesis,
            "Missing symbol", "A switch statement should always start with \'(\'");

        advance();
		GrType switchType = parseSubExpression().type;
        GrVariable switchVar = registerSpecialVariable("switch"d ~ to!dstring(scopeLevel), switchType);
        addSetInstruction(switchVar);
        advance();

        /* A switch is breakable. */
		openBreakableSection();
        uint[] exitJumps;
        uint jumpPosition, defaultCasePosition;
        bool hasCase, hasDefaultCase;

        while(get().type == GrLexemeType.Case) {
            advance();
            assertError(get().type == GrLexemeType.LeftParenthesis, 
                "Invalid case syntax", "It should be either case(...) or case()");
            advance();
            if(get().type == GrLexemeType.RightParenthesis) {
                assertError(!hasDefaultCase, "Multiple default cases", "There must be only one default case per switch statement");
                advance();
                hasDefaultCase = true;
                defaultCasePosition = current;
                skipBlock();
            }
            else {
                hasCase = true;
                addGetInstruction(switchVar);
                GrType caseType = parseSubExpression().type;
                addBinaryOperator(GrLexemeType.Equal, switchType, caseType);
                advance();

                jumpPosition = cast(uint)currentFunction.instructions.length;
                //Jumps to if(0).
                addInstruction(GrOpcode.JumpEqual);

                parseBlock(true);

                exitJumps ~= cast(uint)currentFunction.instructions.length;
                addInstruction(GrOpcode.Jump);

                //Jumps to if(0).
                setInstruction(GrOpcode.JumpEqual,
                    jumpPosition,
                    cast(int)(currentFunction.instructions.length - jumpPosition),
                    true);
            }
        }

        if(hasDefaultCase) {
            const uint tmp = current;
            current = defaultCasePosition;
            parseBlock(true);
            current = tmp;
        }

        /* A switch is breakable. */
		closeBreakableSection();

        foreach(uint position; exitJumps)
			setInstruction(GrOpcode.Jump, position, cast(int)(currentFunction.instructions.length - position), true);
    }

    /**
    ---
    select
    case(SUBEXPR) BLOCK
    case(SUBEXPR) BLOCK
    case() BLOCK
    ---
    */
    void parseSelectStatement() {
        advance();

        /* A select is breakable. */
		openBreakableSection();
        uint[] exitJumps;
        uint jumpPosition, defaultCasePosition;
        bool hasCase, hasDefaultCase;
        uint startJump = cast(uint)currentFunction.instructions.length;

        addInstruction(GrOpcode.StartSelectChannel);
        while(get().type == GrLexemeType.Case) {
            advance();
            assertError(get().type == GrLexemeType.LeftParenthesis, 
                "Invalid case syntax", "It should be either case(...) or case()");
            advance();

            if(get().type == GrLexemeType.RightParenthesis) {
                assertError(hasDefaultCase, "Multiple default cases", "There must be only one default case per switch statement");
                advance();
                hasDefaultCase = true;
                defaultCasePosition = current;
                skipBlock();
            }
            else {
                hasCase = true;
                jumpPosition = cast(uint)currentFunction.instructions.length;
                addInstruction(GrOpcode.TryChannel);
                parseSubExpression();
                advance();

                addInstruction(GrOpcode.CheckChannel);

                parseBlock(true);

                exitJumps ~= cast(uint)currentFunction.instructions.length;
                addInstruction(GrOpcode.Jump);

                setInstruction(GrOpcode.TryChannel,
                    jumpPosition,
                    cast(int)(currentFunction.instructions.length - jumpPosition),
                    true);
            }
        }

        if(hasDefaultCase) {
            /* With a default case specified, it is processed if no previous case has been processed in the select statement.
		     * The select statement is not blocking here because at least one case is executed. */
            const uint tmp = current;
            current = defaultCasePosition;
            parseBlock(true);
            current = tmp;
        }
        else {
            /* Without default case, the select statement is a blocking operation until one case is processed.
	         * So, we add a yield then jump back to the beggining of the statement to evaluate the select statement again. */
            addInstruction(GrOpcode.Yield);
            addInstruction(GrOpcode.Jump, cast(int)(startJump - currentFunction.instructions.length), true);
        }

        /* A switch is breakable. */
		closeBreakableSection();

        foreach(uint position; exitJumps)
			setInstruction(GrOpcode.Jump, position, cast(int)(currentFunction.instructions.length - position), true);
        addInstruction(GrOpcode.EndSelectChannel);
    }

    /**
    ---
    while(SUBEXPR)
        BLOCK
    ---
    */
	void parseWhileStatement() {
        const bool isNegative = get().type == GrLexemeType.Until;
		advance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		/* While is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		/* Continue jump. */
		setContinuableSectionDestination();

		uint conditionPosition,
			blockPosition = cast(uint)currentFunction.instructions.length;

		advance();
		parseSubExpression();

		advance();
		conditionPosition = cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.JumpEqual);

		parseBlock(true);

		addInstruction(GrOpcode.Jump, cast(int)(blockPosition - currentFunction.instructions.length), true);
		setInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual, conditionPosition, cast(int)(currentFunction.instructions.length - conditionPosition), true);

		/* While is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

    /**
    ---
    do BLOCK
    while(SUBEXPR)
    ---
    */
	void parseDoWhileStatement() {
		advance();

		/* While is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		uint blockPosition = cast(uint)currentFunction.instructions.length;

		parseBlock(true);

        bool isNegative;
		if(get().type == GrLexemeType.Until)
            isNegative = true;
		else if(get().type != GrLexemeType.While)
			logError("Missing while", "A do-while statement expects the keyword while after \'}\'");
		advance();

		/* Continue jump. */
		setContinuableSectionDestination();

		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		advance();
		parseSubExpression();
		advance();

		addInstruction(isNegative ? GrOpcode.JumpEqual : GrOpcode.JumpNotEqual, cast(int)(blockPosition - currentFunction.instructions.length), true);

		/* While is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

    GrVariable parseDeclarableArgument() {
        GrVariable lvalue;
        GrType type = GrBaseType.VoidType;
        bool isAuto, isTyped = true;
        switch(get().type) with(GrLexemeType) {
        case AutoType:
            isAuto = true;
            checkAdvance();
            break;
        case VoidType: .. case ChanType:
            type = parseType();
            break;
        case Identifier:
            if(_data.isObject(get().svalue) || _data.isUserType(get().svalue))
                type = parseType();
            else
                isTyped = false;
            break;
        default:
            logError("Type or identifier expected", "You must type a variable declaration or an existing one");
            break;
        }
        GrLexeme identifier = get();
		if(identifier.type != GrLexemeType.Identifier)
			logError("Missing identifier", "Identifier expected");

        if(isTyped) {
            lvalue = registerLocalVariable(identifier.svalue, type);
            lvalue.isAuto = isAuto;
        }
        else if(hasVariable(identifier.svalue)) {
            lvalue = getVariable(identifier.svalue);
        }
        else {
            /// Automatic, same behaviour with let.
            lvalue = registerLocalVariable(identifier.svalue, type);
            lvalue.isAuto = true;
        }
        
        //A composite type does not need to be initialized.
        if(lvalue.type == GrBaseType.ObjectType)
            lvalue.isInitialized = true;

		checkAdvance();
        return lvalue;
    }

    /**
    The for statement takes an iterator and an array.
    */
	void parseForStatement() {
		advance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		advance();
        
		GrVariable variable = parseDeclarableArgument();

		if(get().type != GrLexemeType.Comma)
			logError("Missing symbol", "Did you forget the \',\' ?");
		advance();

		//From length to 0
		GrType arrayType = parseSubExpression().type;

        /* Init */
        GrType subType = grUnmangle(arrayType.mangledType);
		GrVariable iterator = registerSpecialVariable("iterator"d ~ to!dstring(scopeLevel), grInt);
		GrVariable index = registerSpecialVariable("index"d ~ to!dstring(scopeLevel), grInt);
		GrVariable array = registerSpecialVariable("array"d ~ to!dstring(scopeLevel), arrayType);
		
        if(variable.isAuto && subType.baseType != GrBaseType.VoidType) {
            variable.isAuto = false;
            variable.type = subType;
            setVariableRegister(variable);
        }

		addSetInstruction(array, arrayType, true);
        final switch(subType.baseType) with(GrBaseType) {
        case BoolType:
        case IntType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.Length_Int);
            break;
        case FloatType:
            addInstruction(GrOpcode.Length_Float);
            break;
        case StringType:
            addInstruction(GrOpcode.Length_String);
            break;
        case ArrayType:
        case ObjectType:
        case UserType:
        case ChanType:
        case ReferenceType:
            addInstruction(GrOpcode.Length_Object);
            break;
        case VoidType:
        case InternalTupleType:
            logError("Invalid array type", "Cannot have an array of this type");
            break;
        }
		addInstruction(GrOpcode.SetupIterator);		
		addSetInstruction(iterator);

		//Set index to -1
		addIntConstant(-1);
		addSetInstruction(index);

		/* For is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		/* Continue jump. */
		setContinuableSectionDestination();


		advance();
		uint blockPosition = cast(uint)currentFunction.instructions.length;

		addGetInstruction(iterator, GrType(GrBaseType.IntType));
		addInstruction(GrOpcode.Decrement_Int);
		addSetInstruction(iterator);

		addGetInstruction(iterator, GrType(GrBaseType.IntType));
		uint jumpPosition = cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.JumpEqual);

		//Set Index
		addGetInstruction(array);
		addGetInstruction(index);
		addInstruction(GrOpcode.Increment_Int);
		addSetInstruction(index, grVoid, true);
        final switch(subType.baseType) with(GrBaseType) {
        case BoolType:
        case IntType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.Index2_Int);
            break;
        case FloatType:
            addInstruction(GrOpcode.Index2_Float);
            break;
        case StringType:
            addInstruction(GrOpcode.Index2_String);
            break;
        case ArrayType:
        case ObjectType:
        case UserType:
        case ChanType:
        case ReferenceType:
            addInstruction(GrOpcode.Index2_Object);
            break;
        case VoidType:
        case InternalTupleType:
            logError("Invalid array type", "Cannot have an array of this type");
            break;
        }
		convertType(subType, variable.type);
		addSetInstruction(variable);

		parseBlock(true);

		addInstruction(GrOpcode.Jump, cast(int)(blockPosition - currentFunction.instructions.length), true);
		setInstruction(GrOpcode.JumpEqual, jumpPosition, cast(int)(currentFunction.instructions.length - jumpPosition), true);

		/* For is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

    /// Skips everything from a `(` to its matching `)`.
    void skipParenthesis() {
        if(get().type != GrLexemeType.LeftParenthesis)
            return;
        advance();
        
        __loop: while(!isEnd()) {
            switch(get().type) with(GrLexemeType) {
            case RightParenthesis:
                advance();
                return;
            case RightBracket:
            case RightCurlyBrace:
            case Semicolon:
                break __loop;
            case LeftParenthesis:
                skipParenthesis();
                break;
            case LeftBracket:
                skipBrackets();
                break;
            case LeftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }
    }

    /// Skips everything from a `[` to its matching `]`.
    void skipBrackets() {
        if(get().type != GrLexemeType.LeftBracket)
            return;
        advance();

        __loop: while(!isEnd()) {
            switch(get().type) with(GrLexemeType) {
            case RightBracket:
                advance();
                return;
            case RightParenthesis:
            case RightCurlyBrace:
            case Semicolon:
                break __loop;
            case LeftParenthesis:
                skipParenthesis();
                break;
            case LeftBracket:
                skipBrackets();
                break;
            case LeftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }
    }

    /// Returns the number of parameters separated by commas inside a pair of (), [] or {}.
    int checkArity() {
        int arity;
        const int position = current;

        bool useParenthesis, useBrackets, useCurlyBraces;

		switch(get().type) with(GrLexemeType) {
        case LeftParenthesis:
            advance();
            useParenthesis = true;
            if(get(1).type != GrLexemeType.RightParenthesis)
                arity ++;
            break;
        case LeftBracket:
            advance();
            useBrackets = true;
            if(get(1).type != GrLexemeType.RightBracket)
                arity ++;
            break;
        case LeftCurlyBrace:
            advance();
            useCurlyBraces = true;
            if(get(1).type != GrLexemeType.RightCurlyBrace)
                arity ++;
            break;
        default:
            logError("Arity check error", "Cannot evaluate the arity of an unknown compound");
            break;
        }

        __loop: while(!isEnd()) {
            switch(get().type) with(GrLexemeType) {
            case Comma:
                arity ++;
                advance();
                break;
            case RightParenthesis:
                if(!useParenthesis)
                    goto default;
                break __loop;
            case RightBracket:
                if(!useBrackets)
                    goto default;
                break __loop;
            case RightCurlyBrace:
                if(!useCurlyBraces)
                    goto default;
                break __loop;
            case Semicolon:
                break __loop;
            case LeftParenthesis:
                skipParenthesis();
                break;
            case LeftBracket:
                skipBrackets();
                break;
            case LeftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }

        current = position;
        return arity;
    }

    /**
    There are 3 types of loop.
    - The infinite loop with no parameters:
    ---
    loop printl("I'm infinite !");
    ---
    - The finite loop, with 1 parameter:
    ---
    loop(5) printl("I'm printed 5 times !");
    ---
    - The finite loop with an iterator:
    ---
    loop(i, 5) printl("Iterator = " ~ i as string);
    ---
    */
	void parseLoopStatement() {
        bool isInfinite, hasCustomIterator;
        GrVariable iterator, customIterator;
        
		advance();
		if(get().type == GrLexemeType.LeftParenthesis) {
            const int arity = checkArity();
            advance();
            if(arity == 2) {
                hasCustomIterator = true;
                customIterator = parseDeclarableArgument();
                if(customIterator.isAuto) {
                    customIterator.isAuto = false;
                    customIterator.type = grInt;
                    setVariableRegister(customIterator);
                }
                else if(customIterator.type != grInt) {
                    logError("Loop iterator type error", "The type of the iterator must be int, not " ~ grGetPrettyType(customIterator.type));
                }

                addIntConstant(0);
                addSetInstruction(customIterator);

                if(get().type != GrLexemeType.Comma)
                    logError("Missing symbol", "Did you forget the \',\' ?");
                advance();
            }

            /* Init */
            iterator = registerSpecialVariable("iterator"d ~ to!dstring(scopeLevel), GrType(GrBaseType.IntType));
        
            //Init counter
            GrType type = parseSubExpression().type;
            advance();

            convertType(type, grInt);
            addInstruction(GrOpcode.SetupIterator);
            addSetInstruction(iterator);
        }
        else
            isInfinite = true;

		/* For is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		/* Continue jump. */
		setContinuableSectionDestination();


		uint blockPosition = cast(uint)currentFunction.instructions.length;
        uint jumpPosition;

        if(!isInfinite) {
            addGetInstruction(iterator, grInt, false);
            addInstruction(GrOpcode.Decrement_Int);
            addSetInstruction(iterator);

            addGetInstruction(iterator, grInt);
            jumpPosition = cast(uint)currentFunction.instructions.length;
            addInstruction(GrOpcode.JumpEqual);
        }

		parseBlock(true);

        if(!isInfinite && hasCustomIterator) {
            addGetInstruction(customIterator, grInt, false);
            addInstruction(GrOpcode.Increment_Int);
            addSetInstruction(customIterator);
        }

		addInstruction(GrOpcode.Jump, cast(int)(blockPosition - currentFunction.instructions.length), true);
		if(!isInfinite)
            setInstruction(GrOpcode.JumpEqual, jumpPosition, cast(int)(currentFunction.instructions.length - jumpPosition), true);

		/* For is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

    /**
    The type of the return must be that of the signature of the function. \
    Doesn't need a `;` if there a no return value.
    ---
    return "Hello"; // Returns a string.
    return // No ';' because there is no expression.
    ---
    */
	void parseReturnStatement() {
		checkAdvance();
        if(currentFunction.name == "main" || currentFunction.isTask) {
            if(!currentFunction.instructions.length || currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
                addKill();
        }
        else if(!currentFunction.outSignature.length) {
            if(!currentFunction.instructions.length || currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
                addReturn();
        }
        else {
            auto types = parseExpressionList();
            
            addReturn();
            if(types.length != currentFunction.outSignature.length)
                logError("Invalid return type", "");
            for(int i; i < types.length; i ++) {
                if(types[i] != currentFunction.outSignature[i])
                    logError("Invalid return type",
                        "The returned type \'"
                        ~ to!string(types[i])
                        ~ "\' does not match the function definition \'"
                        ~ to!string(currentFunction.outSignature[i])
                        ~ "\'");
            }
        }
	}

    /// Add a `return` instruction that pop the callstack.
    void addReturn() {
        checkDeferStatement();
        if(_isProfiling) {
            addInstruction(GrOpcode.Debug_ProfileEnd);
        }
        addInstruction(GrOpcode.Return);
    }

    /// Add a `kill` instruction that stops the current task.
    void addKill() {
        checkDeferStatement();
        if(_isProfiling) {
            addInstruction(GrOpcode.Debug_ProfileEnd);
        }
        addInstruction(GrOpcode.Kill);
    }

    /// Add a `killall` instruction that stops every tasks.
    void addKillAll() {
        checkDeferStatement();
        if(_isProfiling) {
            addInstruction(GrOpcode.Debug_ProfileEnd);
        }
        addInstruction(GrOpcode.KillAll);
    }

    /// The more it is, the less you need parenthesis.
    uint getLeftOperatorPriority(GrLexemeType type) {
		switch(type) with(GrLexemeType) {
        case Assign: .. case PowerAssign:
            return 6;
        case Or:
            return 1;
        case Xor:
            return 2;
        case And:
            return 3;
        case Equal: .. case NotEqual:
            return 14;
        case GreaterOrEqual: .. case Lesser:
            return 15;
        case Add: .. case Substract:
            return 16;
        case Multiply: .. case Remainder:
            return 17;
        case Power:
            return 18;
        case Not:
        case Plus:
        case Minus:
        case Increment:
        case Decrement:
        case Send:
        case Receive:
            return 19;
        default:
            logError("Unknown priority", "The operator is not listed in the operator priority table");
            return 0;
		}
	}

    /// The more it is, the less you need parenthesis.
	uint getRightOperatorPriority(GrLexemeType type) {
		switch(type) with(GrLexemeType) {
        case Assign: .. case PowerAssign:
            return 20;
        case Or:
            return 1;
        case Xor:
            return 2;
        case And:
            return 3;
        case Equal: .. case NotEqual:
            return 4;
        case GreaterOrEqual: .. case Lesser:
            return 5;
        case Add: .. case Substract:
            return 16;
        case Multiply: .. case Remainder:
            return 17;
        case Power:
            return 18;
        case Not:
        case Plus:
        case Minus:
        case Increment:
        case Decrement:
        case Send:
        case Receive:
            return 19;
        default:
            logError("Unknown priority", "The operator is not listed in the operator priority table");
            return 0;
		}
	}

    /// Attempt to convert `src` type to the `dst` type.
	GrType convertType(GrType src, GrType dst, bool noFail = false, bool isExplicit = false) {
        if(src.baseType == dst.baseType) {
            final switch(src.baseType) with(GrBaseType) {
            case FunctionType:
                if(src.mangledType == dst.mangledType && src.mangledReturnType == dst.mangledReturnType)
                    return dst;
                break;
            case TaskType:
                if(src.mangledType == dst.mangledType)
                    return dst;
                break;
            case VoidType:
            case BoolType:
            case IntType:
            case FloatType:
            case StringType:
                return dst;
            case ArrayType:
            case ObjectType:
            case UserType:
            case ChanType:
            case ReferenceType:
            case InternalTupleType:
                if(dst.mangledType == src.mangledType)
                    return dst;
                break;
            }
        }

        if(src.baseType == GrBaseType.InternalTupleType || dst.baseType == GrBaseType.InternalTupleType)
            logError("Convertion error", "Cannot convert multiple values from an expression list");

        if(dst.baseType == GrBaseType.BoolType) {
            final switch(src.baseType) with(GrBaseType) {
            case FunctionType:
            case TaskType:
            case VoidType:
            case BoolType:
            case IntType:
            case FloatType:
            case StringType:
            case InternalTupleType:
                break;
            case ArrayType:
            case ObjectType:
            case UserType:
            case ChanType:
            case ReferenceType:
                addInstruction(GrOpcode.IsNonNull_Object);
                return dst;
            }
        }
		
        //User-defined conversions.
        if(addCustomConversion(src, dst, isExplicit) == dst)
            return dst;
        
        if(!noFail)
            logError("Incompatible types", "Cannot convert \'"
                ~ grGetPrettyType(src) ~ "\' to \'" ~ grGetPrettyType(dst) ~ "\'", -1);
		return GrType(GrBaseType.VoidType);	
	}

    /// Convert with a primitive or function.
    GrType addCustomConversion(GrType leftType, GrType rightType, bool isExplicit) {
        GrType resultType = GrBaseType.VoidType;

        //As opposed to other functions, we need the return type (rightType) to be part of the signature.
        dstring mangledName = grMangleNamedFunction("@as", [leftType, rightType]);

        //Special conversions
        /*if(leftType != rightType) {
            if(leftType.baseType == GrBaseType.TupleType) {
                switch(rightType.baseType) with(GrBaseType) {
                case ArrayType:
                case VariantType:
                    auto tuple = _data.getTuple(leftType.mangledType);
                    const auto nbFields = tuple.signature.length;
                    for(int i = 1; i <= nbFields; i ++) {
                        convertType(tuple.signature[nbFields - i], grVariant, isExplicit);
                    }
                    addInstruction(GrOpcode.Array, cast(int)nbFields);
                    convertType(grArray, rightType);
                    return rightType;
                default:
                    break;
                }
            }
            else if(rightType.baseType == GrBaseType.TupleType) {
                switch(leftType.baseType) with(GrBaseType) {
                case ArrayType:
                    leftType = convertType(leftType, grVariant);
                    goto case VariantType;
                case VariantType:
                    auto tuple = _data.getTuple(rightType.mangledType);
                    addMetaConstant(grMangleFunction(tuple.signature));
                    addInstruction(GrOpcode.DynCast_Variant);
                    return rightType;
                default:
                    break;
                }
            }
            else if(rightType.baseType == GrBaseType.VariantType) {
                switch(leftType.baseType) with(GrBaseType) {
                case FunctionType:
                case TaskType:
                case ObjectType:
                    //We can't know in advance what'll be the signature of the anonymous function we want to convert.
                    //So we add the mangling as a runtime meta value.
                    addMetaConstant(grMangleVariant(leftType));
                    //Then, we delete the mangling, and the cast primitive will do the same.
                    GrType tempType = leftType;
                    tempType.mangledType = grMangleNamedFunction("", []);
                    tempType.mangledReturnType = "";
                    mangledName = grMangleNamedFunction("@as", [tempType, rightType]);
                    break;
                default:
                    break;
                }
            }
            else if(leftType.baseType == GrBaseType.VariantType) {
                switch(rightType.baseType) with(GrBaseType) {
                case FunctionType:
                case TaskType:
                case ObjectType:               
                    //We can't know in advance what'll be the signature of the anonymous function we want to convert.
                    //So we add the mangling as a runtime meta value.
                    addMetaConstant(grMangleVariant(rightType));
                    //Then, we delete the mangling, and the cast primitive will do the same.
                    GrType tempType = rightType;
                    tempType.mangledType = grMangleNamedFunction("", []);
                    tempType.mangledReturnType = "";
                    mangledName = grMangleNamedFunction("@as", [leftType, tempType]);
                    break;
                default:
                    break;
                }
            }
        }*/
        
        //GrPrimitive check
        if(_data.isPrimitiveDeclared(mangledName)) {
            GrPrimitive primitive = _data.getPrimitive(mangledName);
            //Some implicit conversions are disabled.
            //ex: float -> int because we might lose information.
            if(primitive.isExplicit && !isExplicit)
                return resultType;
            addInstruction(GrOpcode.PrimitiveCall, primitive.index);
            if(primitive.outSignature.length != 1uL)
                logError("Return signature error", "An operator can only have one return value");
            resultType = rightType;
        }

        //GrFunction check
        if(resultType.baseType == GrBaseType.VoidType) {
            const auto func = (mangledName in functions);
            if(func !is null) {
                auto outSignature = addFunctionCall(mangledName);
                if(outSignature.length != 1uL)
                    logError("Return signature error", "An operator can only have one return value");
                resultType = rightType;
            }
        }

        return resultType;     
    }

    /**
    Parse an array creation.
    The type is optional if the array is not empty.
    If no type is specified, the array subtype is set to the type of the first element.
    ---
    array(int)[1, 2, 3]
    ["1", "2", "3"]
    array(string)[]
    ---
    */
    GrType parseArrayBuilder() {
        GrType arrayType = GrType(GrBaseType.ArrayType);
        GrType subType = grVoid;

        //Explicit type like: array(int)[1, 2, 3]
        if(get().type == GrLexemeType.ArrayType) {
            dstring[] temp;
            auto signature = parseInSignature(temp, true);
            if(signature.length > 1)
                logError("Array type error", "Arrays can only have one type");
            subType = signature[0];
            arrayType.mangledType = grMangleFunction(signature);
            if(subType.baseType == GrBaseType.VoidType)
                logError("Array type error", "Array can not be of type void");
        }

        if(get().type != GrLexemeType.LeftBracket)
            logError("Missing [", "Missing [");
        advance();

        int arraySize;
        while(get().type != GrLexemeType.RightBracket) {
            if(subType.baseType == GrBaseType.VoidType) {
                //Implicit type specified by the type of the first element.
                subType = parseSubExpression(GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA).type;
                arrayType.mangledType = grMangleFunction([subType]);
                if(subType.baseType == GrBaseType.VoidType)
                    logError("Array type error", "Array can not be of type void");
            }
            else {
                convertType(parseSubExpression(GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA).type, subType);
            }
            arraySize ++;

            if(get().type == GrLexemeType.RightBracket)
                break;
            if(get().type != GrLexemeType.Comma)
                logError("Missing comma or ]", "bottom text");
            checkAdvance();
        }

        final switch(subType.baseType) with(GrBaseType) {
        case BoolType:
        case IntType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.Array_Int, arraySize);
            break;
        case FloatType:
            addInstruction(GrOpcode.Array_Float, arraySize);
            break;
        case StringType:
            addInstruction(GrOpcode.Array_String, arraySize);
            break;
        case ArrayType:
        case ObjectType:
        case UserType:
        case ChanType:
        case ReferenceType:
            addInstruction(GrOpcode.Array_Object, arraySize);
            break;
        case VoidType:
        case InternalTupleType:
            logError("Array Error", "Cannot build an array of this type");
            break;
        }
        advance();
        return arrayType;
    }

    GrType parseArrayIndex(GrType arrayType) {
        if(get().type != GrLexemeType.LeftBracket)
            logError("Missing [", "Missing [");
        advance();

        for(;;) {
            if(get().type == GrLexemeType.Comma)
                logError("Missing value", "bottom text");
            auto index = parseSubExpression(GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA).type;
            if(index.baseType == GrBaseType.VoidType)
                logError("Syntax Error", "right there");
            convertType(index, grInt);

            if(get().type == GrLexemeType.RightBracket) {
                switch(arrayType.baseType) with(GrBaseType) {
                case ArrayType:
                    GrType subType = grUnmangle(arrayType.mangledType);
                    final switch(subType.baseType) with(GrBaseType) {
                    case BoolType:
                    case IntType:
                    case FunctionType:
                    case TaskType:
                        addInstruction(GrOpcode.Index_Int);
                        break;
                    case FloatType:
                        addInstruction(GrOpcode.Index_Float);
                        break;
                    case StringType:
                        addInstruction(GrOpcode.Index_String);
                        break;
                    case ArrayType:
                    case ObjectType:
                    case UserType:
                    case ChanType:
                    case ReferenceType:
                        addInstruction(GrOpcode.Index_Object);
                        break;
                    case VoidType:
                    case InternalTupleType:
                        logError("Array Error", "Cannot index an array of this type");
                        break;
                    }
                    arrayType = subType;
                    break;
                default:
                    logError("Invalid array type", "Can only index array or variant value");
                }
                break;
            }
            if(get().type != GrLexemeType.Comma)
                logError("Missing comma or ]", "bottom text");
            checkAdvance();
            if(get().type == GrLexemeType.RightBracket)
                logError("Missing comma or ]", "bottom text");

            switch(arrayType.baseType) with(GrBaseType) {
            case ArrayType:
                GrType subType = grUnmangle(arrayType.mangledType);
                final switch(subType.baseType) with(GrBaseType) {
                case BoolType:
                case IntType:
                case FunctionType:
                case TaskType:
                    addInstruction(GrOpcode.Index_Int);
                    break;
                case FloatType:
                    addInstruction(GrOpcode.Index_Float);
                    break;
                case StringType:
                    addInstruction(GrOpcode.Index_String);
                    break;
                case ArrayType:
                case ObjectType:
                case UserType:
                case ChanType:
                case ReferenceType:
                    addInstruction(GrOpcode.Index_Object);
                    break;
                case VoidType:
                case InternalTupleType:
                    logError("Array Error", "Cannot index an array of this type");
                    break;
                }
                arrayType = subType;
                break;
            default:
                logError("Invalid array type", "Can only index array or variant value");
            }
        }
        advance();
        return arrayType;
    }

    /**
    Parse a cast, or `as` operation.
    ---
    1 as float
    ---
    */
    GrType parseConversionOperator(GrType[] typeStack) {
        if(!typeStack.length)
            logError("Conversion Error", "You can only convert a value");
        advance();
        auto asType = parseType();
        convertType(typeStack[$ - 1], asType, false, true);
        typeStack[$ - 1] = asType;
        return asType;
    }

    /// Parse an assignable (named) element.
    GrVariable parseLValue() {
        if(get().type != GrLexemeType.Identifier)
            logError("Missing lvalue", "Missing lvalue");

        dstring identifierName = get().svalue;

        checkAdvance();

        auto lvalue = (identifierName in currentFunction.localVariables);
        if(lvalue is null)
            lvalue = (identifierName in globalVariables);

        if(lvalue is null)
            logError("Missing lvalue", "Missing lvalue");
        
        return *lvalue;
    }

    /// Parse a single expression, not a statement.
	void parseExpression() {
        bool isAssignmentList;
        const auto tempPos = current;
        checkAdvance();
        __skipLoop: while(!isEnd()) {
            switch(get().type) with(GrLexemeType) {
            case LeftBracket:
                skipBrackets();
                break;
            case LeftParenthesis:
                skipParenthesis();
                break;
            case LeftCurlyBrace:
                skipBlock();
                break;
            case Semicolon:
                isAssignmentList = false;
                break __skipLoop;
            case Comma:
                isAssignmentList = true;
                break __skipLoop;
            default:
                checkAdvance();
                break;
            }
        }
        current = tempPos;
        
        if(isAssignmentList) {
            //Get list of lvalues
            GrVariable[] lvalues;
            do {
                if(lvalues.length)
                    checkAdvance();
                //Identifier
                if(get().type != GrLexemeType.Identifier)
                    logError("Missing identifier", "Expected a name such as \'foo\'");
                lvalues ~= parseSubExpression(GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_ASSIGN | GR_SUBEXPR_EXPECTING_LVALUE).lvalue;
            }
            while(get().type == GrLexemeType.Comma);

            parseAssignList(lvalues);
        }
        else {
            parseSubExpression(GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_MUST_CLEAN);
            checkAdvance();
        }
	}

    /// Parse the right side of a multiple assignment.
    GrType[] parseExpressionList() {
        GrType[] expressionTypes;
        for(;;) {
            GrType type = parseSubExpression(GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_EXPECTING_VALUE).type;
            if(type.baseType == GrBaseType.InternalTupleType) {
                auto types = grUnpackTuple(type);
                if(!types.length)
                    logError("Empty return value", "Cannot return a void value");
                else {
                    foreach(subType; types)
                        expressionTypes ~= subType;
                }
            }
            else
                expressionTypes ~= type;
            if(get().type != GrLexemeType.Comma)
                break;
            checkAdvance();
        }
        if(get().type != GrLexemeType.Semicolon)
            logError("Missing semicolon", "An expression list must be finished with a ;");
        checkAdvance();
        return expressionTypes;
    }

    /// Parse the right side of a multiple assignment and associate them with the `lvalues`.
    void parseAssignList(GrVariable[] lvalues) {
        switch(get().type) with(GrLexemeType) {
        case Assign:
            advance();
            GrType[] expressionTypes = parseExpressionList();
            
            if(expressionTypes.length > lvalues.length)
                logError("Exceeding number of expressions", "Cannot assign more values than identifiers");

            int variableIndex = to!int(lvalues.length) - 1;
            int expressionIndex = to!int(expressionTypes.length) - 1;
            bool passThrough;
            GrVariable[] skippedLvalues;
            while(variableIndex > expressionIndex) {
                addSetInstruction(lvalues[variableIndex], expressionTypes[expressionIndex], true);
                variableIndex --;
                passThrough = true;
            }
            if(passThrough) {
                if(expressionTypes[expressionIndex].baseType == GrBaseType.VoidType) {
                    skippedLvalues ~= lvalues[variableIndex];
                }
                else {
                    addSetInstruction(lvalues[variableIndex], lvalues[variableIndex + 1].type, false);
                }
                variableIndex --;
                expressionIndex --;
            }
            while(variableIndex >= 0) {
                if(expressionTypes[expressionIndex].baseType == GrBaseType.VoidType) {
                    skippedLvalues ~= lvalues[variableIndex];
                }
                else {
                    while(skippedLvalues.length) {
                        addSetInstruction(skippedLvalues[$ - 1], expressionTypes[expressionIndex], true);
                        skippedLvalues.length --;
                    }
                    addSetInstruction(lvalues[variableIndex], expressionTypes[expressionIndex], false);
                }
                variableIndex --;
                expressionIndex --;
            }
            if(skippedLvalues.length)
                logError("Assignment List", "First element cannot be empty");
            break;
        case Semicolon:
            advance();
            break;
        default:
            logError("Invalid symbol", "A declaration must either be terminated by a ; or assigned with =");
        }
    }

    /**
    Count the number of D types used (int, float, string and void*).
    */
    auto countSubTypes(GrType type) {
        struct TypeCounter {
            int iCount, fCount, sCount, oCount;
        }
        TypeCounter counter;
        void countSubTypes(GrType type, ref TypeCounter counter) {
            final switch(type.baseType) with(GrBaseType) {
            case IntType:
            case BoolType:
            case FunctionType:
            case TaskType:
                counter.iCount ++;
                break;
            case FloatType:
                counter.fCount ++;
                break;
            case StringType:
                counter.sCount ++;
                break;
            case ObjectType:
            case ArrayType:
            case UserType:
            case ChanType:
            case ReferenceType:
                counter.oCount ++;
                break;
            case VoidType:
                throw new Exception("Cannot change the stack for a struct type");
            case InternalTupleType:
                throw new Exception("Tuples should not exist here.");
            }
        }
        countSubTypes(type, counter);
        return counter;
    }

    /// Add an instruction to clean up a value from the stack.
    void shiftStackPosition(GrType type, short count) {
        const auto counter = countSubTypes(type);
        if(counter.iCount)
            addInstruction(GrOpcode.ShiftStack_Int, counter.iCount * count, true);
        if(counter.fCount)
            addInstruction(GrOpcode.ShiftStack_Float, counter.fCount * count, true);
        if(counter.sCount)
            addInstruction(GrOpcode.ShiftStack_String, counter.sCount * count, true);
        if(counter.oCount)
            addInstruction(GrOpcode.ShiftStack_Object, counter.oCount * count, true);
    }

    /// Does this operation require a left-expr ?
    bool requireLValue(GrLexemeType operatorType) {
        switch(operatorType) with(GrLexemeType) {
        case Period:
        case Increment:
        case Decrement:
        case Assign: .. case PowerAssign:
            return true;
        default:
            return false;
        }
    }

    /**
    Parse a function reference expression. \
    Converts a public function/task into an anonymous one.
    */
    GrType parseFunctionPointer(GrType currentType) {
        checkAdvance();
        if(get().type == GrLexemeType.LeftParenthesis) {
            checkAdvance();
            GrType refType = parseType();
            if(get().type != GrLexemeType.RightParenthesis)
                logError("Missing symbol", "Expected a \')\' after the type");
            checkAdvance();
            if(currentType.baseType == GrBaseType.VoidType)
                currentType = refType;
            else
                currentType = convertType(refType, currentType);
        }
        if(get().type != GrLexemeType.Identifier)
            logError("GrFunction name expected", "The name of the func or task is required after \'&\'");
        if(currentType.baseType != GrBaseType.FunctionType && currentType.baseType != GrBaseType.TaskType)
            logError("GrFunction ref error", "Cannot infer the type of \'" ~ to!string(get().svalue) ~ "\'");

        GrType funcType = addFunctionAddress(get().svalue ~ currentType.mangledType);
        convertType(funcType, currentType);
        checkAdvance();
        return currentType;
    }

    private enum {
        GR_SUBEXPR_TERMINATE_SEMICOLON = 0x1,
        GR_SUBEXPR_TERMINATE_BRACKET = 0x2,
        GR_SUBEXPR_TERMINATE_COMMA = 0x4,
        GR_SUBEXPR_TERMINATE_PARENTHESIS = 0x8,
        GR_SUBEXPR_TERMINATE_ASSIGN = 0x10,
        GR_SUBEXPR_MUST_CLEAN = 0x20,
        GR_SUBEXPR_EXPECTING_VALUE = 0x40,
        GR_SUBEXPR_EXPECTING_LVALUE = 0x80,
    }

    private struct GrSubExprResult {
        GrType type;
        GrVariable lvalue;
    }
    
    /**
    Evaluate a single subexpression.
    */
	GrSubExprResult parseSubExpression(int flags = GR_SUBEXPR_TERMINATE_PARENTHESIS) {
        const bool useSemicolon = (flags & GR_SUBEXPR_TERMINATE_SEMICOLON) > 0;
        const bool useBracket = (flags & GR_SUBEXPR_TERMINATE_BRACKET) > 0;
        const bool useComma = (flags & GR_SUBEXPR_TERMINATE_COMMA) > 0;
        const bool useParenthesis = (flags & GR_SUBEXPR_TERMINATE_PARENTHESIS) > 0;
        const bool useAssign = (flags & GR_SUBEXPR_TERMINATE_ASSIGN) > 0;
        const bool mustCleanValue = (flags & GR_SUBEXPR_MUST_CLEAN) > 0;
        const bool isExpectingValue = (flags & GR_SUBEXPR_EXPECTING_VALUE) > 0;
        const bool isExpectingLValue = (flags & GR_SUBEXPR_EXPECTING_LVALUE) > 0;
        
		GrVariable[] lvalues;
		GrLexemeType[] operatorsStack;
		GrType[] typeStack;
		GrType currentType = grVoid, lastType = grVoid;
		bool hasValue = false, hadValue = false,
        hasLValue = false, hadLValue = false,
        hasReference = false, hadReference = false,
		isRightUnaryOperator = true, isEndOfExpression = false;

        GrSubExprResult result;

		do {
			if(hasValue && currentType != lastType && lastType != grVoid) {
				lastType = currentType;
				currentType = lastType;
			}
            else
                lastType = currentType;

			isRightUnaryOperator = false;
			hadValue = hasValue;
			hasValue = false;

			hadLValue = hasLValue;
			hasLValue = false;

            hadReference = hasReference;
            hasReference = false;

			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
			case Semicolon:
				if(useSemicolon)
					isEndOfExpression = true;
                else
					logError("Unexpected symbol", "A \';\' cannot exist inside this expression");
				break;
			case Comma:
				if(useComma)
					isEndOfExpression = true;
				else
					logError("Unexpected symbol", "A \',\' cannot exist inside this expression");
				break;
			case RightParenthesis:
				if(useParenthesis)
					isEndOfExpression = true;
				else
					logError("Unexpected symbol", "A \')\' cannot exist inside this expression");
				break;
            case RightBracket:
				if(useBracket)
					isEndOfExpression = true;
				else
					logError("Unexpected symbol", "A \']\' cannot exist inside this expression");
				break;
			case LeftParenthesis:
                if(hadValue) {
                    currentType = parseAnonymousCall(typeStack[$ - 1]);
                    //Unpack function value for 1 or less return values
                    //Multiples values are left as a tuple for parseExpressionList()
                    if(currentType.baseType == GrBaseType.InternalTupleType) {
                        auto types = grUnpackTuple(currentType);
                        if(!types.length)
                            currentType = grVoid;
                        else if(types.length == 1uL)
                            currentType = types[0];
                    }
                    if(currentType.baseType == GrBaseType.VoidType) {
                        typeStack.length --;
                    }
                    else {
                        hadValue = false;
                        hasValue = true;
                        typeStack[$ - 1] = currentType;
                    }
                }
                else {
                    advance();
                    currentType = parseSubExpression().type;
                    advance();
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            case MethodCall:
                advance();
                if(!hadValue)
                    logError("Empty method call", "Cannot call a function on nothing");
                if(get().type != GrLexemeType.Identifier)
                    logError("Missing identifier", "Expecting a function name");
                
                GrType selfValue = grVoid;
                selfValue = typeStack[$ - 1];
                typeStack.length --;
                hadValue = false;
                
                GrVariable lvalue;
				currentType = parseIdentifier(lvalue, lastType, selfValue, isExpectingLValue);
                //Unpack function value for 1 or less return values
                //Multiples values are left as a tuple for parseExpressionList()
                if(currentType.baseType == GrBaseType.InternalTupleType) {
                    auto types = grUnpackTuple(currentType);
                    if(!types.length)
                        currentType = grVoid;
                    else if(types.length == 1uL)
                        currentType = types[0];
                }

                const auto nextLexeme = get();
                if(nextLexeme.type == GrLexemeType.LeftBracket)
                    hasReference = true;
				if(currentType != GrType(GrBaseType.VoidType)) {
					hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            case ArrayType:
                currentType = parseArrayBuilder();
                typeStack ~= currentType;
                hasValue = true;
                break;
            case LeftBracket:
                //Index
                if(hadValue) {
                    hadValue = false;
                    currentType = parseArrayIndex(lastType);
                    hasReference = true;
                    //Check if there is an assignement or not, discard if it's only a rvalue
                    const auto nextLexeme = get();
                    if(requireLValue(nextLexeme.type) ||
                        (isExpectingLValue && nextLexeme.type == GrLexemeType.Comma)) {
                        if((nextLexeme.type > GrLexemeType.Assign &&
                            nextLexeme.type <= GrLexemeType.PowerAssign) ||
                            nextLexeme.type == GrLexemeType.Increment ||
                            nextLexeme.type == GrLexemeType.Decrement) {
                            final switch(currentType.baseType) with(GrBaseType) {
                            case BoolType:
                            case IntType:
                            case FunctionType:
                            case TaskType:
                                setInstruction(GrOpcode.Index3_Int, cast(int)currentFunction.instructions.length - 1);
                                break;
                            case FloatType:
                                setInstruction(GrOpcode.Index3_Float, cast(int)currentFunction.instructions.length - 1);
                                break;
                            case StringType:
                                setInstruction(GrOpcode.Index3_String, cast(int)currentFunction.instructions.length - 1);
                                break;
                            case ArrayType:
                            case ObjectType:
                            case UserType:
                            case ChanType:
                            case ReferenceType:
                                setInstruction(GrOpcode.Index3_Object, cast(int)currentFunction.instructions.length - 1);
                                break;
                            case VoidType:
                            case InternalTupleType:
                                logError("Array Error", "Cannot index an array of this type");
                                break;
                            }
                        }
                        hasLValue = true;
                        GrVariable refVar = new GrVariable;
                        refVar.type.baseType = GrBaseType.ReferenceType;
                        refVar.type.mangledType = grMangleFunction([currentType]);
                        lvalues ~= refVar;
                    } else {
                        final switch(currentType.baseType) with(GrBaseType) {
                        case BoolType:
                        case IntType:
                        case FunctionType:
                        case TaskType:
                            setInstruction(GrOpcode.Index2_Int, cast(int)currentFunction.instructions.length - 1);
                            break;
                        case FloatType:
                            setInstruction(GrOpcode.Index2_Float, cast(int)currentFunction.instructions.length - 1);
                            break;
                        case StringType:
                            setInstruction(GrOpcode.Index2_String, cast(int)currentFunction.instructions.length - 1);
                            break;
                        case ArrayType:
                        case ObjectType:
                        case UserType:
                        case ChanType:
                        case ReferenceType:
                            setInstruction(GrOpcode.Index2_Object, cast(int)currentFunction.instructions.length - 1);
                            break;
                        case VoidType:
                        case InternalTupleType:
                            logError("Array Error", "Cannot index an array of this type");
                            break;
                        }
                    }
                    lastType = currentType;
                    typeStack[$ - 1] = currentType;
                    hasValue = true;
                }
                else {
                    currentType = parseArrayBuilder();
                    typeStack ~= currentType;
                    hasValue = true;
                }
                break;
			case Integer:
				currentType = GrType(GrBaseType.IntType);
				addIntConstant(lex.ivalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case Float:
				currentType = GrType(GrBaseType.FloatType);
				addFloatConstant(lex.fvalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case Boolean:
				currentType = GrType(GrBaseType.BoolType);
				addBoolConstant(lex.bvalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case String:
				currentType = GrType(GrBaseType.StringType);
				addStringConstant(lex.svalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
            case New:
                checkAdvance();
                if(get().type != GrLexemeType.Identifier)
                    logError("Missing type", "Missing a type name to instanciate");
                currentType = grGetObjectType(get().svalue);
                hasValue = true;
                typeStack ~= currentType;
                GrObjectDefinition object = _data.getObject(get().svalue);
                addInstruction(GrOpcode.New, cast(uint)object.index);
                checkAdvance();
                break;
            case ChanType:
				currentType = parseChannelBuilder();
                hasValue = true;
                typeStack ~= currentType;
                break;
            case Period:
                if(currentType.baseType != GrBaseType.ObjectType)
                    logError("Field operator error", "It's not a struct type");
                checkAdvance();
                if(get().type != GrLexemeType.Identifier) //TODO: change to handle tuples
                    logError("Missing identifier", "Missing field name after the \'.\'");
                const dstring identifier = get().svalue;
                checkAdvance();
                GrObjectDefinition object = _data.getObject(currentType.mangledType);
                const auto nbFields = object.signature.length;
                bool hasField;
                for(int i; i < nbFields; i ++) {
                    if(identifier == object.fields[i]) {
                        hasField = true;
                        currentType = object.signature[i];
                        currentType.isField = true;
                        GrVariable fieldLValue = new GrVariable;
                        fieldLValue.isInitialized = true;
                        fieldLValue.isField = true;
                        fieldLValue.type = currentType;
                        fieldLValue.register = i;

                        if(hadLValue)
                            lvalues[$ - 1] = fieldLValue;
                        else
                            lvalues ~= fieldLValue;

                        if(hadValue)
                            typeStack[$ - 1] = currentType;
                        else
                            typeStack ~= currentType;

                        hasValue = true;
                        hadValue = false;
                        hasLValue = true;
                        hadLValue = false;

                        void addLoadFieldInstruction(GrType type, uint index, bool asCopy) {
                            final switch(type.baseType) with(GrBaseType) {
                            case BoolType:
                            case IntType:
                            case FunctionType:
                            case TaskType:
                                addInstruction(asCopy ? GrOpcode.FieldLoad2_Int : GrOpcode.FieldLoad_Int, index);
                                break;
                            case FloatType:
                                addInstruction(asCopy ? GrOpcode.FieldLoad2_Float : GrOpcode.FieldLoad_Float, index);
                                break;
                            case StringType:
                                addInstruction(asCopy ? GrOpcode.FieldLoad2_String : GrOpcode.FieldLoad_String, index);
                                break;
                            case ReferenceType:
                            case ChanType:
                            case ObjectType:
                            case ArrayType:
                            case UserType:
                                addInstruction(asCopy ? GrOpcode.FieldLoad2_Object : GrOpcode.FieldLoad_Object, index);
                                break;
                            case InternalTupleType:
                            case VoidType:
                                logError("Invalid field type", "Cannot access this field");
                                break;
                            }
                        }

                        switch(get().type) with(GrLexemeType) {
                        case Period:
                            addInstruction(GrOpcode.FieldLoad_Object, fieldLValue.register);
                            break;
                        case Assign:
                            addInstruction(GrOpcode.FieldLoad, fieldLValue.register);
                            break;
                        case Increment:
                        case Decrement:
                        case AddAssign: .. case PowerAssign:
                            addLoadFieldInstruction(currentType, fieldLValue.register, true);
                            break;
                        case Comma:
                            if(isExpectingLValue)
                                goto case Assign;
                            goto default;
                        default:
                            addLoadFieldInstruction(currentType, fieldLValue.register, false);
                            break;
                        }
                        break;
                    }
                }
                if(!hasField)
                    logError("Unknown field", "This field does not exist", -1);
                break;
            case Pointer:
                currentType = parseFunctionPointer(currentType);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case As:
                if(!hadValue)
                    logError("","");
                currentType = parseConversionOperator(typeStack);
                hasValue = true;
                hadValue = false;
                break;
			case Self:
                // Parse a function call that refers to its parent. 
                checkAdvance();
                const dstring mangledName = grMangleNamedFunction(currentFunction.name, currentFunction.inSignature);
                currentType = addFunctionAddress(mangledName);
                if(currentType.baseType == GrBaseType.VoidType)
                    logError("Self reference error", "Couldn't find parent function", -1);
                typeStack ~= currentType;
				hasValue = true;
                break;
			case FunctionType:
				currentType = parseAnonymousFunction(false);
                typeStack ~= currentType;
				hasValue = true;
				break;
			case TaskType:
				currentType = parseAnonymousFunction(true);
                typeStack ~= currentType;
				hasValue = true;
				break;
            case Assign:
                if(useAssign) {
                    isEndOfExpression = true;
                    break;
                }
                goto case AddAssign;
			case AddAssign: .. case PowerAssign:
				if(!hadLValue)
					logError("Expression invalid", "Missing lvalue in expression");
				hadLValue = false;
				goto case Multiply;
			case Add:
				if(!hadValue)
					lex.type = GrLexemeType.Plus;
				goto case Multiply;
			case Substract:
				if(!hadValue)
					lex.type = GrLexemeType.Minus;
				goto case Multiply;
            case Send:
				if(!hadValue)
					lex.type = GrLexemeType.Receive;
				goto case Multiply;
			case Increment: .. case Decrement:
				isRightUnaryOperator = true;
				goto case Multiply;
			case Multiply: .. case Not:
                if(isExpectingLValue)
                    logError("Unexpected operation", "Cannot do this kind of operation on the left side of an assignment");
				if(!hadValue
                    && lex.type != GrLexemeType.Plus
                    && lex.type != GrLexemeType.Minus
                    && lex.type != GrLexemeType.Not
                    && lex.type != GrLexemeType.Receive)
					logError("Expected value", "A value is missing");

				while(operatorsStack.length && getLeftOperatorPriority(operatorsStack[$ - 1]) > getRightOperatorPriority(lex.type)) {
					GrLexemeType operator = operatorsStack[$ - 1];
	
					switch(operator) with(GrLexemeType) {
					case Assign:
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					case AddAssign: .. case PowerAssign:
						currentType = addOperator(operator - (GrLexemeType.AddAssign - GrLexemeType.Add), typeStack);
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					case Increment: .. case Decrement:
						currentType = addOperator(operator, typeStack);
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					default:
						currentType = addOperator(operator, typeStack);
						break;
					}

					operatorsStack.length --;
				}

				operatorsStack ~= lex.type;
				if(hadValue && isRightUnaryOperator) {
					hasValue = true;
					hadValue = false;
				}
				else
					hasValue = false;
				checkAdvance();
				break;
			case Identifier:
				GrVariable lvalue;
				currentType = parseIdentifier(lvalue, lastType, grVoid, isExpectingLValue);
                //Unpack function value for 1 or less return values
                //Multiples values are left as a tuple for parseExpressionList()
                if(currentType.baseType == GrBaseType.InternalTupleType) {
                    auto types = grUnpackTuple(currentType);
                    if(!types.length)
                        currentType = grVoid;
                    else if(types.length == 1uL)
                        currentType = types[0];
                }

                //Check if there is an assignement or not, discard if it's only a rvalue
                const auto nextLexeme = get();
				if(lvalue !is null && (requireLValue(nextLexeme.type) ||
                        (isExpectingLValue && nextLexeme.type == GrLexemeType.Comma))) {
					hasLValue = true;
					lvalues ~= lvalue;

                    if(lvalue.isAuto)
                        hasValue = true;
				}

                if(!hasLValue && nextLexeme.type == GrLexemeType.LeftBracket)
                    hasReference = true;

				if(currentType != GrType(GrBaseType.VoidType)) {
					hasValue = true;
                    typeStack ~= currentType;
                }
				break;
			default:
				logError("Unexpected symbol", "Invalid \'" ~ to!string(lex.type) ~ "\' symbol in the expression");
			}

			if(hasValue && hadValue)
                logError("Missing symbol", "The expression is not terminated by a \';\'");
		}
		while(!isEndOfExpression);

		if(operatorsStack.length) {
			if(!hadValue) {
				if(!isRightUnaryOperator)
					logError("Expected value", "A value is missing");
				else
					logError("Expected value", "A value is missing");
			}
		}

		while(operatorsStack.length) {
			GrLexemeType operator = operatorsStack[$ - 1];
	
			switch(operator) with(GrLexemeType) {
			case Assign:
				addSetInstruction(lvalues[$ - 1], currentType, isExpectingValue || operatorsStack.length > 1uL);
				lvalues.length --;

                if(operatorsStack.length <= 1uL)
                    hadValue = false;
				break;
			case AddAssign: .. case PowerAssign:
				currentType = addOperator(operator - (GrLexemeType.AddAssign - GrLexemeType.Add), typeStack);
				addSetInstruction(lvalues[$ - 1], currentType, isExpectingValue || operatorsStack.length > 1uL);			
				lvalues.length --;

                if(operatorsStack.length <= 1uL)
                    hadValue = false;
				break;
			case Increment: .. case Decrement:
				currentType = addOperator(operator, typeStack);
				addSetInstruction(lvalues[$ - 1], currentType, isExpectingValue || operatorsStack.length > 1uL);
				lvalues.length --;

                if(operatorsStack.length <= 1uL)
                    hadValue = false;
				break;
			default:
				currentType = addOperator(operator, typeStack);
				break;
			}

			operatorsStack.length --;
		}

        if(isExpectingLValue) {
            if(!hadLValue)
                logError("Not an lvalue", "Left side of an assignation list must be an lvalue");
            result.lvalue = lvalues[$ - 1];
        }
        
        if(mustCleanValue && hadValue && currentType.baseType != GrBaseType.VoidType)
            shiftStackPosition(currentType, -1);
        
        result.type = currentType;
        return result;
	}

    /// Parse a function call from a runtime value.
    GrType parseAnonymousCall(GrType type) {
        GrVariable functionId;
        if(type.baseType == GrBaseType.FunctionType) {
            functionId = registerSpecialVariable("anon", GrType(GrBaseType.IntType));
            addSetInstruction(functionId, GrType(GrBaseType.IntType));
        }

        checkAdvance();
        //Signature parsing with type conversion
		GrType[] signature;
        GrType[] anonSignature = grUnmangleSignature(type.mangledType);
        int i;
        if(get().type != GrLexemeType.RightParenthesis) {
            for(;;) {
                if(i >= anonSignature.length)
                    logError("Invalid anonymous call", "The number of parameters does not match");
                GrType subType = parseSubExpression(GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS | GR_SUBEXPR_EXPECTING_VALUE).type;
                signature ~= convertType(subType, anonSignature[i]);
                if(get().type == GrLexemeType.RightParenthesis)
                    break;
                advance();
                i ++;
            }
        }
        if(signature.length != anonSignature.length)
            logError("Invalid function call", "The signature does not match");
        checkAdvance();

        //Push the values on the global stack for task spawning.
        if(type.baseType == GrBaseType.TaskType)
            addGlobalPush(signature);

        //Anonymous call.
        GrType retTypes = grPackTuple(grUnmangleSignature(type.mangledReturnType));

        if(type.baseType == GrBaseType.FunctionType) {
            addGetInstruction(functionId, GrType(GrBaseType.IntType));
        }

        if(type.baseType == GrBaseType.FunctionType)
            addInstruction(GrOpcode.AnonymousCall, 0u);
        else if(type.baseType == GrBaseType.TaskType)
            addInstruction(GrOpcode.AnonymousTask, 0u);
        else
            logError("Invalid anonymous type", "debug");
        return retTypes;
    }

	/// Parse an identifier or function call and return the deduced return type and lvalue.
	GrType parseIdentifier(ref GrVariable variable, GrType expectedType, GrType selfValue = grVoid, bool isAssignment = false) {
		GrType returnType = GrBaseType.VoidType;
		GrLexeme identifier = get();		
		bool isFunctionCall = false, isMethodCall = false, hasParenthesis = false;
        dstring identifierName = identifier.svalue;

		advance();

        if(selfValue.baseType != GrBaseType.VoidType) {
            isMethodCall = true;
			isFunctionCall = true;
        }

		if(get().type == GrLexemeType.LeftParenthesis) {
			isFunctionCall = true;
            hasParenthesis = true;
        }

		if(isFunctionCall) {
			GrType[] signature;

            if(hasParenthesis)
                advance();

			auto var = (identifierName in currentFunction.localVariables);
            if(var is null)
                var = (identifierName in globalVariables);
			if(var !is null) {
                //Signature parsing with type conversion
                GrType[] anonSignature = grUnmangleSignature(var.type.mangledType);
                int i;
                if(isMethodCall) {
                    signature ~= convertType(selfValue, anonSignature[i]);                    
                    i ++;
                }
                if(hasParenthesis && get().type != GrLexemeType.RightParenthesis) {
                    for(;;) {
                        if(i >= anonSignature.length)
                            logError("Invalid anonymous call", "The number of parameters does not match");
                        GrType subType = parseSubExpression(GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS | GR_SUBEXPR_EXPECTING_VALUE).type;
                        if(subType.baseType == GrBaseType.InternalTupleType) {
                            auto types = grUnpackTuple(subType);
                            if(types.length) {
                                for(int y; y < types.length; y ++, i ++) {
                                    signature ~= convertType(types[y], anonSignature[i]);
                                }
                            }
                            else
                                logError("Cannot use a void function", "Cannot use a void function as a parameter");
                        }
                        else {
                            signature ~= convertType(subType, anonSignature[i]);
                            i ++;
                        }
                        if(get().type == GrLexemeType.RightParenthesis) {
                            if(signature.length != anonSignature.length)
                                logError("Invalid anonymous call", "The number of parameters does not match");
                            break;
                        }
                        advance();
                    }
                    if(hasParenthesis && get().type == GrLexemeType.RightParenthesis)
                        advance();
                }
                else {
                    if(hasParenthesis && get().type == GrLexemeType.RightParenthesis)
                        advance();
                    if(anonSignature.length)
                        logError("Invalid anonymous call", "The number of parameters does not match");
                }

                //Push the values on the global stack for task spawning.
                if(var.type.baseType == GrBaseType.TaskType)
                    addGlobalPush(signature);

				//Anonymous call.
				bool hasAnonFunc = false;
				addGetInstruction(*var);
                
				returnType = grPackTuple(grUnmangleSignature(var.type.mangledReturnType));

				if(var.type.baseType == GrBaseType.FunctionType)
					addInstruction(GrOpcode.AnonymousCall, 0u);
				else if(var.type.baseType == GrBaseType.TaskType)
					addInstruction(GrOpcode.AnonymousTask, 0u);
				else
					logError("Invalid anonymous type", "debug");

				/*foreach(anonFunc; anonymousFunctions) {
					if(anonFunc.name == currentFunction.name) {

						hasAnonFunc = true;
						break;
					}
				}*/
			}
			else {
                if(isMethodCall) {
                    signature ~= selfValue;
                }
                //Signature parsing, no coercion is made
                if(hasParenthesis && get().type != GrLexemeType.RightParenthesis) {
                    for(;;) {
                        auto type = parseSubExpression(GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS | GR_SUBEXPR_EXPECTING_VALUE).type;
                        if(type.baseType == GrBaseType.InternalTupleType) {
                            auto types = grUnpackTuple(type);
                            if(types.length)
                                signature ~= types;
                            else
                                logError("Cannot use a void function", "Cannot use a void function as a parameter");
                        }
                        else
                            signature ~= type;

                        if(get().type == GrLexemeType.RightParenthesis)
                            break;
                        advance();
                    }
                }
                if(hasParenthesis  && get().type == GrLexemeType.RightParenthesis)
                    advance();

                //Mangling function name
				dstring mangledName = grMangleNamedFunction(identifierName, signature);
				
				//GrPrimitive call.
				if(_data.isPrimitiveDeclared(mangledName)) {
					GrPrimitive primitive = _data.getPrimitive(mangledName);
					addInstruction(GrOpcode.PrimitiveCall, primitive.index);
					returnType = grPackTuple(primitive.outSignature);
				}
				else //GrFunction/Task call.
					returnType = grPackTuple(addFunctionCall(mangledName));
			}
		}
		else {
			//Declared variable.
			variable = getVariable(identifierName);
			returnType = variable.type;
            //If it's an assignement, we want the GET instruction to be after the assignement, not there.
            const auto nextLexeme = get();
            if(!(nextLexeme.type == GrLexemeType.Assign || (isAssignment && nextLexeme.type == GrLexemeType.Comma)))
                addGetInstruction(variable, expectedType);
		}
		return returnType;
	}

    /// Check an raise an error.
    void assertError(bool assertion, string message, string info, int offset = 0) {
        if(assertion)
            return;
        logError(message, info, offset);
    }

    /// Log an error and throw an exception.
	void logError(string message, string info, int offset = 0) {
		GrError error = new GrError;
        error.type = GrError.Type.parser;
		error.message = message;
		error.info = info;

        GrLexeme lex = (isEnd() && offset >= 0) ? get(-1) : get(offset);
        error.filePath = to!string(lex.getFile());
        error.lineText = to!string(lex.getLine()).replace("\t", " ");
        error.line = lex.line + 1u; // By convention, the first line is 1, not 0.
        error.column = lex.column;
        error.textLength = lex.textLength;

		throw new GrParserException(error);
	}
}

package final class GrParserException: Exception {
    GrError error;

    /// Ctor
    this(GrError error_, string file = __FILE__, size_t line = __LINE__) {
        super(error_.message, file, line);
        error = error_;
    }
}