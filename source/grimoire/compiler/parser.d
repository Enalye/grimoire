/** 
 * Copyright: Enalye
 * License: Zlib
 * Authors: Enalye
 */
module grimoire.compiler.parser;

import std.stdio;
import std.format;
import std.string;
import std.array;
import std.conv;
import std.math;
import std.file;
import std.meta;

import grimoire.runtime;
import grimoire.assembly;
import grimoire.compiler.util;
import grimoire.compiler.lexer;
import grimoire.compiler.mangle;
import grimoire.compiler.type;
import grimoire.compiler.constraint;
import grimoire.compiler.primitive;
import grimoire.compiler.data;
import grimoire.compiler.pretty;
import grimoire.compiler.error;

/**
Analyses the syntax and produce the data for the VM
The parser analyses the lexemes generated by the lexer and produce machine code.
*/
final class GrParser {
    package {
        GrInt[] iconsts;
        GrReal[] rconsts;
        GrString[] sconsts;

        uint scopeLevel;

        GrVariable[] globalVariables;
        GrFunction[] instanciatedFunctions, functionsQueue, functions, events;
        GrFunction[] anonymousFunctions;
        GrTemplateFunction[] templatedFunctions;

        uint current;
        GrFunction currentFunction;
        GrFunction[] functionStack;
        GrFunctionCall[] functionCalls;

        uint[][] breaksJumps;
        uint[][] continuesJumps;
        uint[] continuesDestinations;

        GrLexeme[] lexemes;

        bool isTypeChecking;

        /// Number of int based global variables declared.
        uint iglobalsCount;
        /// Number of real based global variables declared.
        uint rglobalsCount;
        /// Number of string based global variables declared.
        uint sglobalsCount;
        /// Number of ptr based global variables declared.
        uint oglobalsCount;

        GrLocale _locale;
    }

    private {
        GrData _data;
        bool _isAssignationOptimizable;
        int _options;
    }

    /// Ctor
    this(GrLocale locale) {
        _locale = locale;
    }

    /// Reset to the start of the sequence.
    private void reset() {
        current = 0u;
    }

    /// Advance to the next lexeme.
    private void advance() {
        if (current < lexemes.length)
            current++;
    }

    /// Return to the last lexeme.
    private void goBack() {
        if (current > 0u)
            current--;
    }

    /// Check for the end the sequence, then advance to the next lexeme.
    private bool checkAdvance() {
        if (isEnd())
            return false;

        advance();
        return true;
    }

    /// Start of a block with `{`
    private void openBlock() {
        scopeLevel++;
        if (currentFunction)
            currentFunction.openScope();
    }

    /// End of a block with '}'
    private void closeBlock() {
        scopeLevel--;
        if (currentFunction)
            currentFunction.closeScope();
    }

    /// Check for the end of the sequence.
    private bool isEnd(int offset = 0) {
        return (current + offset) >= cast(uint) lexemes.length;
    }

    private void set(uint position_) {
        current = position_;
        if (current < 0 || current >= cast(uint) lexemes.length) {
            current = 0;
        }
    }

    /// Return the lexeme at the current position.
    private GrLexeme get(int offset = 0) {
        const uint position = current + offset;
        if (position < 0 || position >= cast(uint) lexemes.length) {
            logError(getError(Error.eofReached), getError(Error.eof));
        }
        return lexemes[position];
    }

    /// Register an integral value and returns its id.
    private uint registerIntConstant(GrInt value) {
        foreach (size_t index, GrInt iconst; iconsts) {
            if (iconst == value)
                return cast(uint) index;
        }
        iconsts ~= value;
        return cast(uint) iconsts.length - 1;
    }

    /// Register an floating point value and returns its id.
    private uint registerRealConstant(GrReal value) {
        foreach (size_t index, GrReal fconst; rconsts) {
            if (fconst == value)
                return cast(uint) index;
        }
        rconsts ~= value;
        return cast(uint) rconsts.length - 1;
    }

    /// Register an string value and returns its id.
    private uint registerStringConstant(GrString value) {
        foreach (size_t index, GrString sconst; sconsts) {
            if (sconst == value)
                return cast(uint) index;
        }
        sconsts ~= value;
        return cast(uint) sconsts.length - 1;
    }

    /// Register a special local variable, used for iterators, etc.
    private GrVariable registerSpecialVariable(string name, GrType type) {
        name = "~" ~ name;
        GrVariable specialVariable = registerLocalVariable(name, type);
        specialVariable.isAuto = false;
        specialVariable.isInitialized = true; //We shortcut this check
        return specialVariable;
    }

    /// Register a global variable
    private GrVariable registerGlobalVariable(string name, GrType type, bool isAuto, bool isPublic) {
        //Check if declared globally.
        assertNoGlobalDeclaration(name, get().fileId, isPublic);

        GrVariable variable = new GrVariable;
        variable.isAuto = isAuto;
        variable.isGlobal = true;
        variable.isInitialized = false;
        variable.type = type;
        variable.name = name;
        variable.isPublic = isPublic;
        variable.fileId = get().fileId;
        variable.lexPosition = current;
        if (!isAuto)
            setVariableRegister(variable);
        globalVariables ~= variable;

        return variable;
    }

    private GrVariable getGlobalVariable(string name, uint fileId, bool isPublic = false) {
        foreach (GrVariable var; globalVariables) {
            if (var.name == name && (var.fileId == fileId || var.isPublic || isPublic))
                return var;
        }
        return null;
    }

    private void assertNoGlobalDeclaration(string name, uint fileId, bool isPublic) {
        GrVariable var;
        GrFunction func;
        if ((var = getGlobalVariable(name, fileId, isPublic)) !is null)
            logError(format(getError(Error.nameXDefMultipleTimes), name),
                format(getError(Error.xRedefHere), name), "", 0,
                format(getError(Error.prevDefOfX), name), var.lexPosition);
        if (_data.isPrimitiveDeclared(name))
            logError(format(getError(Error.nameXDefMultipleTimes), name),
                format(getError(Error.prevDefPrim), name));
        if ((func = getFunction(name, fileId, isPublic)) !is null)
            logError(format(getError(Error.nameXDefMultipleTimes), name),
                format(getError(Error.xRedefHere), name), "", 0,
                format(getError(Error.prevDefOfX), name), func.lexPosition);
        if ((func = getEvent(name)) !is null)
            logError(format(getError(Error.nameXDefMultipleTimes), name),
                format(getError(Error.xRedefHere), name), "", 0,
                format(getError(Error.prevDefOfX), name), func.lexPosition);
    }

    private void setVariableRegister(GrVariable variable) {
        final switch (variable.type.base) with (GrType.Base) {
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            if (variable.isGlobal) {
                variable.register = iglobalsCount;
                iglobalsCount++;
            }
            else {
                if (currentFunction.iregisterAvailables.length) {
                    variable.register = currentFunction.iregisterAvailables[$ - 1];
                    currentFunction.iregisterAvailables.length--;
                }
                else {
                    variable.register = currentFunction.ilocalsCount;
                    currentFunction.ilocalsCount++;
                }
            }
            break;
        case real_:
            if (variable.isGlobal) {
                variable.register = rglobalsCount;
                rglobalsCount++;
            }
            else {
                if (currentFunction.rregisterAvailables.length) {
                    variable.register = currentFunction.rregisterAvailables[$ - 1];
                    currentFunction.rregisterAvailables.length--;
                }
                else {
                    variable.register = currentFunction.flocalsCount;
                    currentFunction.flocalsCount++;
                }
            }
            break;
        case string_:
            if (variable.isGlobal) {
                variable.register = sglobalsCount;
                sglobalsCount++;
            }
            else {
                if (currentFunction.sregisterAvailables.length) {
                    variable.register = currentFunction.sregisterAvailables[$ - 1];
                    currentFunction.sregisterAvailables.length--;
                }
                else {
                    variable.register = currentFunction.slocalsCount;
                    currentFunction.slocalsCount++;
                }
            }
            break;
        case array:
        case class_:
        case foreign:
        case channel:
            if (variable.isGlobal) {
                variable.register = oglobalsCount;
                oglobalsCount++;
            }
            else {
                if (currentFunction.oregisterAvailables.length) {
                    variable.register = currentFunction.oregisterAvailables[$ - 1];
                    currentFunction.oregisterAvailables.length--;
                }
                else {
                    variable.register = currentFunction.olocalsCount;
                    currentFunction.olocalsCount++;
                }
            }
            break;
        case internalTuple:
        case reference:
        case null_:
        case void_:
            logError(format(getError(Error.cantDefVarOfTypeX),
                    getPrettyType(variable.type)), getError(Error.invalidType));
            break;
        }
    }

    /// Register a local variable
    private GrVariable registerLocalVariable(string name, GrType type) {
        //Check if declared globally
        assertNoGlobalDeclaration(name, get().fileId, false);

        GrVariable variable = new GrVariable;
        variable.isGlobal = false;
        variable.type = type;
        variable.name = name;
        variable.fileId = get().fileId;
        variable.lexPosition = current;

        currentFunction.setLocal(variable);
        if (variable.type.base != GrType.Base.void_)
            setVariableRegister(variable);

        return variable;
    }

    private void beginGlobalScope() {
        GrFunction globalScope = getFunction("@global", 0);
        if (globalScope) {
            functionStack ~= currentFunction;
            currentFunction = globalScope;
        }
        else {
            GrFunction func = new GrFunction;
            func.name = "@global";
            func.mangledName = func.name;
            func.isTask = false;
            func.inSignature = [];
            func.outSignature = [];
            func.isPublic = true;
            func.fileId = 0;
            func.lexPosition = 0;
            functions ~= func;
            functionStack ~= currentFunction;
            currentFunction = func;
        }
    }

    private void endGlobalScope() {
        if (!functionStack.length)
            throw new Exception("global scope mismatch");

        currentFunction = functionStack[$ - 1];
        functionStack.length--;
    }

    private void beginFunction(string name, uint fileId, GrType[] signature, bool isEvent = false) {
        const string mangledName = grMangleComposite(name, signature);

        GrFunction func;
        if (isEvent)
            func = getEvent(mangledName);
        else
            func = getFunction(mangledName, fileId);

        if (func is null)
            logError(format(getError(Error.xNotDef), name), getError(Error.unknownFunc));

        functionStack ~= currentFunction;
        currentFunction = func;
    }

    private void preBeginFunction(string name, uint fileId, GrType[] signature,
        string[] inputVariables, bool isTask, GrType[] outSignature = [],
        bool isAnonymous = false, bool isEvent = false, bool isPublic = false) {
        GrFunction func = new GrFunction;
        func.isTask = isTask;
        func.inputVariables = inputVariables;
        func.inSignature = signature;
        func.outSignature = outSignature;
        func.fileId = fileId;

        if (isAnonymous) {
            //func.index = cast(uint) anonymousFunctions.length;
            func.anonParent = currentFunction;
            func.anonReference = cast(uint) currentFunction.instructions.length;
            func.name = currentFunction.name ~ "@anon" ~ to!string(func.index);
            func.mangledName = grMangleComposite(func.name, func.inSignature);
            anonymousFunctions ~= func;
            func.lexPosition = current;

            //Is replaced by the addr of the function later (see solveFunctionCalls).
            addInstruction(GrOpcode.const_int, 0u);
        }
        else {
            //func.index = cast(uint) functions.length;
            func.name = name;
            func.isPublic = isPublic;

            func.mangledName = grMangleComposite(name, signature);
            assertNoGlobalDeclaration(func.mangledName, fileId, isPublic);

            func.isEvent = isEvent;
            func.lexPosition = current;
            functionsQueue ~= func;
        }

        functionStack ~= currentFunction;
        currentFunction = func;
        generateFunctionInputs();
    }

    private void endFunction() {
        int prependInstructionCount;
        if (_options & GrOption.profile) {
            prependInstructionCount++;
            const uint index = registerStringConstant(getPrettyFunction(currentFunction));
            addInstructionInFront(GrOpcode.debugProfileBegin, index);
        }

        if (currentFunction.ilocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_int, currentFunction.ilocalsCount);
            prependInstructionCount++;
        }

        if (currentFunction.flocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_real, currentFunction.flocalsCount);
            prependInstructionCount++;
        }

        if (currentFunction.slocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_string, currentFunction.slocalsCount);
            prependInstructionCount++;
        }

        if (currentFunction.olocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_object, currentFunction.olocalsCount);
            prependInstructionCount++;
        }

        foreach (call; currentFunction.functionCalls)
            call.position += prependInstructionCount;

        currentFunction.offset += prependInstructionCount;

        if (!functionStack.length)
            throw new Exception("attempting to close a non-existing function");

        currentFunction = functionStack[$ - 1];
        functionStack.length--;
    }

    private void preEndFunction() {
        if (!functionStack.length)
            throw new Exception("attempting to close a non-existing function");
        currentFunction = functionStack[$ - 1];
        functionStack.length--;
    }

    /// Generate opcodes to fetch the function or the task's parameters
    void generateFunctionInputs() {
        void fetchParameter(string name, GrType type) {
            final switch (type.base) with (GrType.Base) {
            case void_:
            case null_:
                logError(format(getError(Error.cantUseTypeAsParam),
                        getPrettyType(type)), getError(Error.invalidParamType));
                break;
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                currentFunction.nbIntegerParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_int, 0u);
                break;
            case real_:
                currentFunction.nbRealParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_real, 0u);
                break;
            case string_:
                currentFunction.nbStringParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_string, 0u);
                break;
            case class_:
            case array:
            case foreign:
            case channel:
            case reference:
                currentFunction.nbObjectParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_object, 0u);
                break;
            case internalTuple:
                throw new Exception("tuples are not allowed here");
            }

            GrVariable newVar = new GrVariable;
            newVar.type = type;
            newVar.isInitialized = true;
            newVar.isGlobal = false;
            newVar.name = name;
            newVar.fileId = get().fileId;
            newVar.lexPosition = current;
            currentFunction.setLocal(newVar);
            setVariableRegister(newVar);
            addSetInstruction(newVar, currentFunction.fileId);
        }

        foreach_reverse (size_t i, inputVariable; currentFunction.inputVariables) {
            fetchParameter(currentFunction.inputVariables[i], currentFunction.inSignature[i]);
        }
    }

    GrFunction getFunction(string mangledName, uint fileId = 0, bool isPublic = false) {
        foreach (GrFunction func; functions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                return func;
            }
        }
        return null;
    }

    auto getFirstMatchingFuncOrPrim(string name, GrType[] signature, uint fileId = 0, bool isPublic = false) {
        struct Result {
            GrPrimitive prim;
            GrFunction func;
        }

        Result result;

        const string mangledName = grMangleComposite(name, signature);
        result.prim = _data.getPrimitive(mangledName);
        if (result.prim)
            return result;

        foreach (GrFunction func; functions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                result.func = func;
                return result;
            }
        }
        foreach (GrFunction func; functionsQueue) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                result.func = func;
                return result;
            }
        }
        foreach (GrFunction func; instanciatedFunctions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                functionsQueue ~= func;

                functionStack ~= currentFunction;
                currentFunction = func;
                generateFunctionInputs();
                currentFunction = functionStack[$ - 1];
                functionStack.length--;

                result.func = func;
                return result;
            }
        }

        result.prim = _data.getCompatiblePrimitive(name, signature);
        if (result.prim)
            return result;

        foreach (GrFunction func; functions) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic)) {
                    result.func = func;
                    return result;
                }
            }
        }
        foreach (GrFunction func; functionsQueue) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic)) {
                    result.func = func;
                    return result;
                }
            }
        }

        foreach (GrFunction func; instanciatedFunctions) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic)) {
                    functionsQueue ~= func;

                    functionStack ~= currentFunction;
                    currentFunction = func;
                    generateFunctionInputs();
                    currentFunction = functionStack[$ - 1];
                    functionStack.length--;

                    result.func = func;
                    return result;
                }
            }
        }

        result.prim = _data.getAbstractPrimitive(name, signature);
        if (result.prim)
            return result;

        __functionLoop: foreach (GrTemplateFunction temp; templatedFunctions) {
            if (temp.name == name && (temp.fileId == fileId || temp.isPublic || isPublic)) {
                GrAnyData anyData = new GrAnyData;
                _data.setAnyData(anyData);
                if (_data.isAbstractSignatureCompatible(signature, temp.inSignature, fileId, isPublic)) {
                    foreach (GrConstraint constraint; temp.constraints) {
                        if (!constraint.evaluate(_data, anyData))
                            continue __functionLoop;
                    }
                    GrType[] templateSignature;
                    for (int i; i < temp.templateVariables.length; ++i) {
                        templateSignature ~= anyData.get(temp.templateVariables[i]);
                    }
                    GrFunction func = parseTemplatedFunctionDeclaration(temp, templateSignature);
                    functionsQueue ~= func;

                    functionStack ~= currentFunction;
                    currentFunction = func;
                    generateFunctionInputs();
                    currentFunction = functionStack[$ - 1];
                    functionStack.length--;

                    result.func = func;
                    return result;
                }
            }
        }

        return result;
    }

    GrFunction getFunction(string name, GrType[] signature, uint fileId = 0, bool isPublic = false) {
        const string mangledName = grMangleComposite(name, signature);
        foreach (GrFunction func; functions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                return func;
            }
        }
        foreach (GrFunction func; functions) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic))
                    return func;
            }
        }
        foreach (GrFunction func; functionsQueue) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                return func;
            }
        }
        foreach (GrFunction func; functionsQueue) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic))
                    return func;
            }
        }
        foreach (GrFunction func; instanciatedFunctions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                functionsQueue ~= func;

                functionStack ~= currentFunction;
                currentFunction = func;
                generateFunctionInputs();
                currentFunction = functionStack[$ - 1];
                functionStack.length--;

                return func;
            }
        }
        foreach (GrFunction func; instanciatedFunctions) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic)) {
                    functionsQueue ~= func;

                    functionStack ~= currentFunction;
                    currentFunction = func;
                    generateFunctionInputs();
                    currentFunction = functionStack[$ - 1];
                    functionStack.length--;

                    return func;
                }
            }
        }

        __functionLoop: foreach (GrTemplateFunction temp; templatedFunctions) {
            if (temp.name == name && (temp.fileId == fileId || temp.isPublic || isPublic)) {
                GrAnyData anyData = new GrAnyData;
                _data.setAnyData(anyData);
                if (_data.isAbstractSignatureCompatible(signature, temp.inSignature, fileId, isPublic)) {
                    foreach (GrConstraint constraint; temp.constraints) {
                        if (!constraint.evaluate(_data, anyData))
                            continue __functionLoop;
                    }
                    GrType[] templateSignature;
                    for (int i; i < temp.templateVariables.length; ++i) {
                        templateSignature ~= anyData.get(temp.templateVariables[i]);
                    }
                    GrFunction func = parseTemplatedFunctionDeclaration(temp, templateSignature);
                    functionsQueue ~= func;

                    functionStack ~= currentFunction;
                    currentFunction = func;
                    generateFunctionInputs();
                    currentFunction = functionStack[$ - 1];
                    functionStack.length--;

                    return func;
                }
            }
        }
        return null;
    }

    /// Remove a declared function
    void removeFunction(string name) {
        import std.algorithm : remove;

        for (int i; i < functions.length; ++i) {
            if (functions[i].mangledName == name) {
                functions = remove(functions, i);
                return;
            }
        }
    }

    private GrFunction getEvent(string name) {
        foreach (GrFunction func; events) {
            if (func.mangledName == name)
                return func;
        }
        return null;
    }

    private GrFunction getAnonymousFunction(string name) {
        foreach (GrFunction func; anonymousFunctions) {
            if (func.mangledName == name)
                return func;
        }
        return null;
    }

    GrFunction getAnonymousFunction(string name, GrType[] signature, uint fileId) {
        foreach (GrFunction func; anonymousFunctions) {
            if (func.mangledName == name)
                return func;
        }
        foreach (GrFunction func; anonymousFunctions) {
            if (func.name == name) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId))
                    return func;
            }
        }
        return null;
    }

    /// Retrieve a declared variable
    private GrVariable getVariable(string name, uint fileId) {
        GrVariable globalVar = getGlobalVariable(name, fileId);
        if (globalVar !is null)
            return globalVar;

        GrVariable localVar = currentFunction.getLocal(name);
        if (!localVar)
            logError(format(getError(Error.xNotDecl), name), getError(Error.unknownVar), "", -1);
        return localVar;
    }

    private void addIntConstant(GrInt value) {
        addInstruction(GrOpcode.const_int, registerIntConstant(value));
    }

    private void addRealConstant(GrReal value) {
        addInstruction(GrOpcode.const_real, registerRealConstant(value));
    }

    private void addBoolConstant(bool value) {
        addInstruction(GrOpcode.const_bool, value);
    }

    private void addStringConstant(GrString value) {
        addInstruction(GrOpcode.const_string, registerStringConstant(value));
    }

    private void addMetaConstant(GrString value) {
        addInstruction(GrOpcode.const_meta, registerStringConstant(value));
    }

    private void addInstruction(GrOpcode opcode, int value = 0, bool isSigned = false) {
        if (currentFunction is null)
            throw new Exception(
                "the expression is located outside of a function or task, which is forbidden");

        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;
        currentFunction.instructions ~= instruction;

        if (_options & GrOption.symbols) {
            generateInstructionSymbol();
        }
    }

    private void addInstructionInFront(GrOpcode opcode, int value = 0, bool isSigned = false) {
        if (currentFunction is null)
            throw new Exception(
                "the expression is located outside of a function or task, which is forbidden");

        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;
        currentFunction.instructions = instruction ~ currentFunction.instructions;

        if (_options & GrOption.symbols) {
            generateInstructionSymbol();
        }
    }

    private void generateInstructionSymbol() {
        GrFunction.DebugPositionSymbol symbol;
        int lexPos = (cast(int) current) - 2;
        if (lexPos < 0) {
            lexPos = 0;
        }
        if (lexPos >= cast(uint) lexemes.length) {
            lexPos = cast(uint)((cast(int) lexemes.length) - 1);
        }
        GrLexeme lex = lexemes[lexPos];
        symbol.line = lex.line + 1;
        symbol.column = lex.column;
        currentFunction.debugSymbol ~= symbol;
    }

    private void setInstruction(GrOpcode opcode, uint index, int value = 0u, bool isSigned = false) {
        if (currentFunction is null)
            throw new Exception(
                "the expression is located outside of a function or task, which is forbidden");

        if (index >= currentFunction.instructions.length)
            throw new Exception("an instruction's index is exeeding the function size");

        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;
        currentFunction.instructions[index] = instruction;
    }

    private bool isBinaryOperator(GrLexeme.Type lexType) {
        if (lexType >= GrLexeme.Type.bitwiseAnd && lexType <= GrLexeme.Type.arrow)
            return true;
        else if (lexType == GrLexeme.Type.send)
            return true;
        else
            return false;
    }

    private bool isUnaryOperator(GrLexeme.Type lexType) {
        if (lexType >= GrLexeme.Type.plus && lexType <= GrLexeme.Type.minus)
            return true;
        else if (lexType >= GrLexeme.Type.increment && lexType <= GrLexeme.Type.decrement)
            return true;
        else if (lexType == GrLexeme.Type.not || lexType == GrLexeme.Type.bitwiseNot)
            return true;
        else if (lexType == GrLexeme.Type.receive)
            return true;
        else
            return false;
    }

    private GrType addCustomBinaryOperator(GrLexeme.Type lexType, GrType leftType,
        GrType rightType, uint fileId) {
        string name = "@op_" ~ getPrettyLexemeType(lexType);
        GrType[] signature = [leftType, rightType];

        //GrPrimitive check
        auto matching = getFirstMatchingFuncOrPrim(name, signature, fileId);
        if (matching.prim) {
            addInstruction(GrOpcode.primitiveCall, matching.prim.index);
            if (matching.prim.outSignature.length != 1uL) {
                logError(getError(Error.opMustHave1RetVal), format(getError(matching.prim.outSignature.length > 1
                        ? Error.expected1RetValFoundX : Error.expected1RetValFoundXs),
                        matching.prim.outSignature.length));
            }
            return matching.prim.outSignature[0];
        }

        //GrFunction check
        if (matching.func) {
            auto outSignature = addFunctionCall(matching.func, fileId);
            if (outSignature.length != 1uL) {
                logError(getError(Error.opMustHave1RetVal), format(getError(matching.func.outSignature.length > 1
                        ? Error.expected1RetValFoundX : Error.expected1RetValFoundXs),
                        matching.func.outSignature.length));
            }
            return outSignature[0];
        }

        return grVoid;
    }

    private GrType addCustomUnaryOperator(GrLexeme.Type lexType, const GrType type, uint fileId) {
        string name = "@op_" ~ getPrettyLexemeType(lexType);
        GrType[] signature = [type];

        //GrPrimitive check
        auto matching = getFirstMatchingFuncOrPrim(name, signature, fileId);
        if (matching.prim) {
            addInstruction(GrOpcode.primitiveCall, matching.prim.index);
            if (matching.prim.outSignature.length != 1uL) {
                logError(getError(Error.opMustHave1RetVal), format(getError(matching.prim.outSignature.length > 1
                        ? Error.expected1RetValFoundX : Error.expected1RetValFoundXs),
                        matching.prim.outSignature.length));
            }
            return matching.prim.outSignature[0];
        }

        //GrFunction check
        if (matching.func) {
            auto outSignature = addFunctionCall(matching.func, fileId);
            if (outSignature.length != 1uL) {
                logError(getError(Error.opMustHave1RetVal), format(getError(matching.func.outSignature.length > 1
                        ? Error.expected1RetValFoundX : Error.expected1RetValFoundXs),
                        matching.func.outSignature.length));
            }
            return outSignature[0];
        }

        return grVoid;
    }

    private GrType addBinaryOperator(GrLexeme.Type lexType, const GrType leftType,
        const GrType rightType, uint fileId) {
        if (leftType.base == GrType.Base.internalTuple
            || rightType.base == GrType.Base.internalTuple)
            logError(getError(Error.cantUseOpOnMultipleVal), getError(Error.exprYieldsMultipleVal));
        GrType resultType = GrType.Base.void_;

        if (leftType.base == GrType.Base.enum_ && rightType.base == GrType.Base.enum_
            && leftType.mangledType == rightType.mangledType) {
            resultType = addInternalOperator(lexType, leftType);
        }
        else if (leftType.base == GrType.Base.channel) {
            GrType channelType = grUnmangle(leftType.mangledType);
            convertType(rightType, channelType, fileId);
            resultType = addInternalOperator(lexType, leftType);
            if (resultType.base == GrType.Base.void_) {
                resultType = addCustomBinaryOperator(lexType, leftType, rightType, fileId);
            }
        }
        else if (lexType == GrLexeme.Type.concatenate
            && leftType.base == GrType.Base.array && leftType != rightType) {
            const GrType subType = grUnmangle(leftType.mangledType);
            convertType(rightType, subType, fileId);
            final switch (subType.base) with (GrType.Base) {
            case int_:
            case bool_:
            case enum_:
            case function_:
            case task:
                addInstruction(GrOpcode.append_int);
                break;
            case real_:
                addInstruction(GrOpcode.append_real);
                break;
            case string_:
                addInstruction(GrOpcode.append_string);
                break;
            case class_:
            case array:
            case foreign:
            case channel:
                addInstruction(GrOpcode.append_object);
                break;
            case null_:
            case void_:
            case reference:
            case internalTuple:
                break;
            }
            resultType = leftType;
        }
        else if (lexType == GrLexeme.Type.concatenate
            && rightType.base == GrType.Base.array && leftType != rightType) {
            const GrType subType = grUnmangle(rightType.mangledType);
            convertType(leftType, subType, fileId);
            final switch (subType.base) with (GrType.Base) {
            case int_:
            case bool_:
            case enum_:
            case function_:
            case task:
                addInstruction(GrOpcode.prepend_int);
                break;
            case real_:
                addInstruction(GrOpcode.prepend_real);
                break;
            case string_:
                addInstruction(GrOpcode.prepend_string);
                break;
            case class_:
            case array:
            case foreign:
            case channel:
                addInstruction(GrOpcode.prepend_object);
                break;
            case null_:
            case void_:
            case reference:
            case internalTuple:
                break;
            }
            resultType = rightType;
        }
        else if (lexType == GrLexeme.Type.concatenate
            && leftType.base == GrType.Base.string_ && leftType != rightType) {
            convertType(rightType, leftType, fileId);
            resultType = addInternalOperator(lexType, leftType);
        }
        else if (lexType == GrLexeme.Type.concatenate
            && rightType.base == GrType.Base.string_ && leftType != rightType) {
            convertType(leftType, rightType, fileId);
            resultType = addInternalOperator(lexType, rightType, true);
        }
        else if (leftType.base == GrType.Base.int_ && rightType.base == GrType.Base.real_) {
            // Special case, we need to convert int to real, then swap the 2 values when needed.
            convertType(leftType, rightType, fileId);
            resultType = addInternalOperator(lexType, rightType, true);

            //Check custom operator
            if (resultType.base == GrType.Base.void_) {
                addInstruction(GrOpcode.swap_real);
                resultType = addCustomBinaryOperator(lexType, rightType, rightType, fileId);
            }
        }
        else if (leftType != rightType) {
            //Check custom operator
            resultType = addCustomBinaryOperator(lexType, leftType, rightType, fileId);

            //If there is no custom operator defined, we try to convert and then try again
            if (resultType.base == GrType.Base.void_) {
                resultType = convertType(rightType, leftType, fileId, true);
                if (resultType.base != GrType.Base.void_) {
                    resultType = addBinaryOperator(lexType, resultType, resultType, fileId);
                }
            }
        }
        else {
            resultType = addInternalOperator(lexType, leftType);
            if (resultType.base == GrType.Base.void_) {
                resultType = addCustomBinaryOperator(lexType, leftType, rightType, fileId);
            }
        }
        if (resultType.base == GrType.Base.void_)
            logError(format(getError(Error.noXBinaryOpDefForYAndZ), getPrettyLexemeType(lexType),
                    getPrettyType(leftType), getPrettyType(rightType)),
                getError(Error.unknownOp), "", -1);
        return resultType;
    }

    private GrType addUnaryOperator(GrLexeme.Type lexType, const GrType type, uint fileId) {
        if (type.base == GrType.Base.internalTuple)
            logError(getError(Error.cantUseOpOnMultipleVal), getError(Error.exprYieldsMultipleVal));
        GrType resultType = GrType.Base.void_;

        resultType = addInternalOperator(lexType, type);
        if (resultType.base == GrType.Base.void_) {
            resultType = addCustomUnaryOperator(lexType, type, fileId);
        }

        if (resultType.base == GrType.Base.void_)
            logError(format(getError(Error.noXUnaryOpDefForY), getPrettyLexemeType(lexType),
                    getPrettyType(type)), getError(Error.unknownOp));
        return resultType;
    }

    private GrType addOperator(GrLexeme.Type lexType, ref GrType[] typeStack, uint fileId) {
        if (isBinaryOperator(lexType)) {
            typeStack[$ - 2] = addBinaryOperator(lexType, typeStack[$ - 2],
                typeStack[$ - 1], fileId);
            typeStack.length--;
            return typeStack[$ - 1];
        }
        else if (isUnaryOperator(lexType)) {
            typeStack[$ - 1] = addUnaryOperator(lexType, typeStack[$ - 1], fileId);
            return typeStack[$ - 1];
        }

        return GrType(GrType.Base.void_);
    }

    private GrType addInternalOperator(GrLexeme.Type lexType, GrType varType, bool isSwapped = false) {
        switch (varType.base) with (GrType.Base) {
        case class_:
        case foreign:
            switch (lexType) with (GrLexeme.Type) {
            case not:
                addInstruction(GrOpcode.isNonNull_object);
                addInstruction(GrOpcode.not_int);
                return GrType(GrType.Base.bool_);
            default:
                break;
            }
            break;
        case enum_:
            switch (lexType) with (GrLexeme.Type) {
            case equal:
                addInstruction(GrOpcode.equal_int);
                return GrType(GrType.Base.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_int);
                return GrType(GrType.Base.bool_);
            case greater:
                addInstruction(GrOpcode.greater_int);
                return GrType(GrType.Base.bool_);
            case greaterOrEqual:
                addInstruction(GrOpcode.greaterOrEqual_int);
                return GrType(GrType.Base.bool_);
            case lesser:
                addInstruction(GrOpcode.lesser_int);
                return GrType(GrType.Base.bool_);
            case lesserOrEqual:
                addInstruction(GrOpcode.lesserOrEqual_int);
                return GrType(GrType.Base.bool_);
            default:
                break;
            }
            break;
        case bool_:
            switch (lexType) with (GrLexeme.Type) {
            case and:
                addInstruction(GrOpcode.and_int);
                return GrType(GrType.Base.bool_);
            case or:
                addInstruction(GrOpcode.or_int);
                return GrType(GrType.Base.bool_);
            case not:
                addInstruction(GrOpcode.not_int);
                return GrType(GrType.Base.bool_);
            default:
                break;
            }
            break;
        case int_:
            switch (lexType) with (GrLexeme.Type) {
            case add:
                addInstruction(GrOpcode.add_int);
                return GrType(GrType.Base.int_);
            case substract:
                addInstruction(GrOpcode.substract_int);
                return GrType(GrType.Base.int_);
            case multiply:
                addInstruction(GrOpcode.multiply_int);
                return GrType(GrType.Base.int_);
            case divide:
                addInstruction(GrOpcode.divide_int);
                return GrType(GrType.Base.int_);
            case remainder:
                addInstruction(GrOpcode.remainder_int);
                return GrType(GrType.Base.int_);
            case minus:
                addInstruction(GrOpcode.negative_int);
                return GrType(GrType.Base.int_);
            case plus:
                return GrType(GrType.Base.int_);
            case increment:
                addInstruction(GrOpcode.increment_int);
                return GrType(GrType.Base.int_);
            case decrement:
                addInstruction(GrOpcode.decrement_int);
                return GrType(GrType.Base.int_);
            case equal:
                addInstruction(GrOpcode.equal_int);
                return GrType(GrType.Base.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_int);
                return GrType(GrType.Base.bool_);
            case greater:
                addInstruction(GrOpcode.greater_int);
                return GrType(GrType.Base.bool_);
            case greaterOrEqual:
                addInstruction(GrOpcode.greaterOrEqual_int);
                return GrType(GrType.Base.bool_);
            case lesser:
                addInstruction(GrOpcode.lesser_int);
                return GrType(GrType.Base.bool_);
            case lesserOrEqual:
                addInstruction(GrOpcode.lesserOrEqual_int);
                return GrType(GrType.Base.bool_);
            case not:
                addInstruction(GrOpcode.not_int);
                return GrType(GrType.Base.bool_);
            default:
                break;
            }
            break;
        case real_:
            switch (lexType) with (GrLexeme.Type) {
            case add:
                addInstruction(GrOpcode.add_real);
                return GrType(GrType.Base.real_);
            case substract:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_real);
                addInstruction(GrOpcode.substract_real);
                return GrType(GrType.Base.real_);
            case multiply:
                addInstruction(GrOpcode.multiply_real);
                return GrType(GrType.Base.real_);
            case divide:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_real);
                addInstruction(GrOpcode.divide_real);
                return GrType(GrType.Base.real_);
            case remainder:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_real);
                addInstruction(GrOpcode.remainder_real);
                return GrType(GrType.Base.real_);
            case minus:
                addInstruction(GrOpcode.negative_real);
                return GrType(GrType.Base.real_);
            case plus:
                return GrType(GrType.Base.real_);
            case increment:
                addInstruction(GrOpcode.increment_real);
                return GrType(GrType.Base.real_);
            case decrement:
                addInstruction(GrOpcode.decrement_real);
                return GrType(GrType.Base.real_);
            case equal:
                addInstruction(GrOpcode.equal_real);
                return GrType(GrType.Base.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_real);
                return GrType(GrType.Base.bool_);
            case greater:
                if (isSwapped)
                    addInstruction(GrOpcode.lesserOrEqual_real);
                else
                    addInstruction(GrOpcode.greater_real);
                return GrType(GrType.Base.bool_);
            case greaterOrEqual:
                if (isSwapped)
                    addInstruction(GrOpcode.lesser_real);
                else
                    addInstruction(GrOpcode.greaterOrEqual_real);
                return GrType(GrType.Base.bool_);
            case lesser:
                if (isSwapped)
                    addInstruction(GrOpcode.greaterOrEqual_real);
                else
                    addInstruction(GrOpcode.lesser_real);
                return GrType(GrType.Base.bool_);
            case lesserOrEqual:
                if (isSwapped)
                    addInstruction(GrOpcode.greater_real);
                else
                    addInstruction(GrOpcode.lesserOrEqual_real);
                return GrType(GrType.Base.bool_);
            default:
                break;
            }
            break;
        case string_:
            switch (lexType) with (GrLexeme.Type) {
            case concatenate:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_string);
                addInstruction(GrOpcode.concatenate_string);
                return GrType(GrType.Base.string_);
            case equal:
                addInstruction(GrOpcode.equal_string);
                return GrType(GrType.Base.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_string);
                return GrType(GrType.Base.bool_);
            default:
                break;
            }
            break;
        case array:
            switch (lexType) with (GrLexeme.Type) {
            case equal:
                const GrType subType = grUnmangle(varType.mangledType);
                final switch (subType.base) with (GrType.Base) {
                case int_:
                case bool_:
                case enum_:
                case function_:
                case task:
                    addInstruction(GrOpcode.equal_intArray);
                    return grBool;
                case real_:
                    addInstruction(GrOpcode.equal_realArray);
                    return grBool;
                case string_:
                    addInstruction(GrOpcode.equal_stringArray);
                    return grBool;
                case null_:
                case void_:
                case reference:
                case internalTuple:
                case array:
                case class_:
                case foreign:
                case channel:
                    break;
                }
                break;
            case notEqual:
                const GrType subType = grUnmangle(varType.mangledType);
                final switch (subType.base) with (GrType.Base) {
                case int_:
                case bool_:
                case enum_:
                case function_:
                case task:
                    addInstruction(GrOpcode.notEqual_intArray);
                    return grBool;
                case real_:
                    addInstruction(GrOpcode.notEqual_realArray);
                    return grBool;
                case string_:
                    addInstruction(GrOpcode.notEqual_stringArray);
                    return grBool;
                case null_:
                case void_:
                case reference:
                case internalTuple:
                case array:
                case class_:
                case foreign:
                case channel:
                    break;
                }
                break;
            case concatenate:
                const GrType subType = grUnmangle(varType.mangledType);
                final switch (subType.base) with (GrType.Base) {
                case int_:
                case bool_:
                case enum_:
                case function_:
                case task:
                    addInstruction(GrOpcode.concatenate_intArray);
                    return varType;
                case real_:
                    addInstruction(GrOpcode.concatenate_realArray);
                    return varType;
                case string_:
                    addInstruction(GrOpcode.concatenate_stringArray);
                    return varType;
                case class_:
                case array:
                case foreign:
                case channel:
                    addInstruction(GrOpcode.concatenate_objectArray);
                    return varType;
                case null_:
                case void_:
                case reference:
                case internalTuple:
                    break;
                }
                break;
            default:
                break;
            }
            break;
        case channel:
            switch (lexType) with (GrLexeme.Type) {
            case send:
                GrType channelType = grUnmangle(varType.mangledType);
                final switch (channelType.base) with (GrType.Base) {
                case int_:
                case bool_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.send_int);
                    return channelType;
                case real_:
                    addInstruction(GrOpcode.send_real);
                    return channelType;
                case string_:
                    addInstruction(GrOpcode.send_string);
                    return channelType;
                case class_:
                case array:
                case foreign:
                case channel:
                    addInstruction(GrOpcode.send_object);
                    return channelType;
                case void_:
                case null_:
                case internalTuple:
                case reference:
                    break;
                }
                break;
            case receive:
                GrType channelType = grUnmangle(varType.mangledType);
                final switch (channelType.base) with (GrType.Base) {
                case int_:
                case bool_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.receive_int);
                    return channelType;
                case real_:
                    addInstruction(GrOpcode.receive_real);
                    return channelType;
                case string_:
                    addInstruction(GrOpcode.receive_string);
                    return channelType;
                case class_:
                case array:
                case foreign:
                case channel:
                    addInstruction(GrOpcode.receive_object);
                    return channelType;
                case void_:
                case null_:
                case internalTuple:
                case reference:
                    break;
                }
                break;
            default:
                break;
            }
            break;
        default:
            break;
        }
        return GrType(GrType.Base.void_);
    }

    private void addSetInstruction(GrVariable variable, uint fileId,
        GrType valueType = grVoid, bool isExpectingValue = false) {
        _isAssignationOptimizable = true;
        if (variable.isConstant)
            logError(format(getError(Error.xIsConstAndCantBeModified), variable.name),
                format(getError(Error.cantModifyAConstX), getPrettyType(variable.type)));

        if (variable.type.base == GrType.Base.reference) {
            valueType = convertType(valueType, grUnmangle(variable.type.mangledType), fileId);
            final switch (valueType.base) with (GrType.Base) {
            case bool_:
            case int_:
            case function_:
            case task:
            case channel:
            case enum_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_int : GrOpcode.refStore_int);
                break;
            case real_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_real : GrOpcode
                        .refStore_real);
                break;
            case string_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_string
                        : GrOpcode.refStore_string);
                break;
            case class_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_object
                        : GrOpcode.refStore_object);
                break;
            case array:
            case foreign:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_object
                        : GrOpcode.refStore_object);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError(format(getError(Error.cantAssignToAXVar),
                        getPrettyType(variable.type)), getError(Error.ValNotAssignable));
            }
            return;
        }

        if (variable.isAuto && !variable.isInitialized) {
            variable.isInitialized = true;
            variable.isAuto = false;
            variable.type = valueType;
            if (valueType.base == GrType.Base.void_)
                logError(getError(Error.cantInferTypeOfVar), getError(Error.varNotInit));
            else
                setVariableRegister(variable);
        }

        if (valueType.base != GrType.Base.void_)
            convertType(valueType, variable.type, fileId);

        //if(!variable.isInitialized && isExpectingValue)
        //    logError("Uninitialized variable", "The variable is being used without being assigned");
        variable.isInitialized = true;

        if (variable.isField) {
            final switch (variable.type.base) with (GrType.Base) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(GrOpcode.fieldStore_int, isExpectingValue ? 0 : -1, true);
                break;
            case real_:
                addInstruction(GrOpcode.fieldStore_real, isExpectingValue ? 0 : -1, true);
                break;
            case string_:
                addInstruction(GrOpcode.fieldStore_string, isExpectingValue ? 0 : -1, true);
                break;
            case foreign:
            case reference:
            case channel:
            case array:
            case class_:
                addInstruction(GrOpcode.fieldStore_object, isExpectingValue ? 0 : -1, true);
                break;
            case void_:
            case null_:
            case internalTuple:
                logError(format(getError(Error.cantAssignToAXVar),
                        getPrettyType(variable.type)), getError(Error.ValNotAssignable));
            }
        }
        else if (variable.isGlobal) {
            final switch (variable.type.base) with (GrType.Base) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_int
                        : GrOpcode.globalStore_int, variable.register);
                break;
            case real_:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_real
                        : GrOpcode.globalStore_real, variable.register);
                break;
            case string_:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_string
                        : GrOpcode.globalStore_string, variable.register);
                break;
            case channel:
            case class_:
            case array:
            case foreign:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_object
                        : GrOpcode.globalStore_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError(format(getError(Error.cantAssignToAXVar),
                        getPrettyType(variable.type)), getError(Error.ValNotAssignable));
            }
        }
        else {
            final switch (variable.type.base) with (GrType.Base) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_int
                        : GrOpcode.localStore_int, variable.register);
                break;
            case real_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_real
                        : GrOpcode.localStore_real, variable.register);
                break;
            case string_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_string
                        : GrOpcode.localStore_string, variable.register);
                break;
            case class_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_object
                        : GrOpcode.localStore_object, variable.register);
                break;
            case array:
            case foreign:
            case channel:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_object
                        : GrOpcode.localStore_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError(format(getError(Error.cantAssignToAXVar),
                        getPrettyType(variable.type)), getError(Error.ValNotAssignable));
            }
        }
    }

    ///Add a load opcode, or optimize a previous store.
    void addGetInstruction(GrVariable variable, GrType expectedType = grVoid,
        bool allowOptimization = true) {
        if (!_isAssignationOptimizable) {
            /+--------------------------
                Optimizing getters should take care of scope levels as jumps will break the VM.
                This shouldn't be optimized as the stack will be empty on the second pass.
                "function foo() {
                    bool a = true;
                    loop {
                        if(a) {}  //a is just after a = true, so will be optimized.
                        yield;
                    } //We jump back to the loop where lstore2 is, crashing the VM.
                }"
                To avoid that, we disallow optimization of different scope levels.
            -------------------------+/
            allowOptimization = false;
        }

        if (variable.isField) {
            throw new Exception("attempt to get field value");
        }
        else if (variable.isGlobal) {
            final switch (variable.type.base) with (GrType.Base) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_int
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_int;
                else
                    addInstruction(GrOpcode.globalLoad_int, variable.register);
                break;
            case real_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_real
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_real;
                else
                    addInstruction(GrOpcode.globalLoad_real, variable.register);
                break;
            case string_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_string
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_string;
                else
                    addInstruction(GrOpcode.globalLoad_string, variable.register);
                break;
            case class_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_object;
                else
                    addInstruction(GrOpcode.globalLoad_object, variable.register);
                break;
            case array:
            case foreign:
            case channel:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_object;
                else
                    addInstruction(GrOpcode.globalLoad_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError(format(getError(Error.cantGetValueOfX),
                        getPrettyType(variable.type)), getError(Error.valNotFetchable));
            }
        }
        else {
            if (!variable.isInitialized)
                logError(getError(Error.locVarUsedNotAssigned), getError(Error.varNotInit));

            final switch (variable.type.base) with (GrType.Base) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_int
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_int;
                else
                    addInstruction(GrOpcode.localLoad_int, variable.register);
                break;
            case real_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_real
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_real;
                else
                    addInstruction(GrOpcode.localLoad_real, variable.register);
                break;
            case string_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_string
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_string;
                else
                    addInstruction(GrOpcode.localLoad_string, variable.register);
                break;
            case class_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_object;
                else
                    addInstruction(GrOpcode.localLoad_object, variable.register);
                break;
            case array:
            case foreign:
            case channel:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_object;
                else
                    addInstruction(GrOpcode.localLoad_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError(format(getError(Error.cantGetValueOfX),
                        getPrettyType(variable.type)), getError(Error.valNotFetchable));
            }
        }
    }

    private GrType addFunctionAddress(string name, GrType[] signature, uint fileId) {
        if (name == "@global")
            return grVoid;
        GrFunctionCall call = new GrFunctionCall;
        call.name = name;
        call.signature = signature;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = true;
        auto func = getFunction(name, signature, fileId);
        if (func is null)
            func = getAnonymousFunction(name, signature, fileId);
        if (func !is null) {
            call.functionToCall = func;
            call.position = cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.const_int, 0);

            return grGetFunctionAsType(func);
        }
        return grVoid;
    }

    private GrType addFunctionAddress(GrFunction func, uint fileId) {
        if (func.name == "@global")
            return grVoid;
        GrFunctionCall call = new GrFunctionCall;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = true;
        call.functionToCall = func;
        call.position = cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.const_int, 0);
        return grGetFunctionAsType(func);
    }

    private GrType[] addFunctionCall(string name, GrType[] signature, uint fileId) {
        GrFunctionCall call = new GrFunctionCall;
        call.name = name;
        call.signature = signature;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = false;
        call.fileId = fileId;

        GrFunction func = getFunction(name, signature, call.fileId, false);
        if (func) {
            call.functionToCall = func;
            if (func.isTask) {
                if (func.nbIntegerParameters > 0)
                    addInstruction(GrOpcode.globalPush_int, func.nbIntegerParameters);
                if (func.nbRealParameters > 0)
                    addInstruction(GrOpcode.globalPush_real, func.nbRealParameters);
                if (func.nbStringParameters > 0)
                    addInstruction(GrOpcode.globalPush_string, func.nbStringParameters);
                if (func.nbObjectParameters > 0)
                    addInstruction(GrOpcode.globalPush_object, func.nbObjectParameters);
            }

            call.position = cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.call, 0);

            return func.outSignature;
        }
        else
            logError(format(getError(Error.xNotDecl), getPrettyFunctionCall(name,
                    signature)), getError(Error.unknownFunc), "", -1);

        return [];
    }

    private GrType[] addFunctionCall(GrFunction func, uint fileId) {
        GrFunctionCall call = new GrFunctionCall;
        call.name = func.name;
        call.signature = func.inSignature;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = false;
        call.fileId = fileId;

        call.functionToCall = func;
        if (func.isTask) {
            if (func.nbIntegerParameters > 0)
                addInstruction(GrOpcode.globalPush_int, func.nbIntegerParameters);
            if (func.nbRealParameters > 0)
                addInstruction(GrOpcode.globalPush_real, func.nbRealParameters);
            if (func.nbStringParameters > 0)
                addInstruction(GrOpcode.globalPush_string, func.nbStringParameters);
            if (func.nbObjectParameters > 0)
                addInstruction(GrOpcode.globalPush_object, func.nbObjectParameters);
        }

        call.position = cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.call, 0);

        return func.outSignature;
    }

    private void setOpcode(ref uint[] opcodes, uint position, GrOpcode opcode,
        uint value = 0u, bool isSigned = false) {
        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;

        uint makeOpcode(uint instr, uint value) {
            return ((value << 8u) & 0xffffff00) | (instr & 0xff);
        }

        opcodes[position] = makeOpcode(cast(uint) instruction.opcode, instruction.value);
    }

    package void solveFunctionCalls(ref uint[] opcodes) {
        foreach (GrFunctionCall call; functionCalls) {
            GrFunction func = call.functionToCall;
            if (!func)
                func = getFunction(call.name, call.signature, call.fileId);
            if (!func)
                func = getAnonymousFunction(call.name, call.signature, call.fileId);
            if (func) {
                if (call.isAddress)
                    setOpcode(opcodes, call.position, GrOpcode.const_int,
                        registerIntConstant(func.position));
                else if (func.isTask)
                    setOpcode(opcodes, call.position, GrOpcode.task, func.position);
                else
                    setOpcode(opcodes, call.position, GrOpcode.call, func.position);
            }
            else
                logError(format(getError(Error.xNotDecl), getPrettyFunctionCall(call.name,
                        call.signature)), getError(Error.unknownFunc));
        }

        foreach (func; anonymousFunctions)
            setOpcode(opcodes, func.anonParent.position + func.anonParent.offset + func.anonReference,
                GrOpcode.const_int, registerIntConstant(func.position));
    }

    package void dump() {
        writeln("Code Generated:\n");
        foreach (size_t i, GrInt ivalue; iconsts)
            writeln(".iconst " ~ to!string(ivalue) ~ "\t;" ~ to!string(i));

        foreach (size_t i, GrReal rvalue; rconsts)
            writeln(".fconst " ~ to!string(rvalue) ~ "\t;" ~ to!string(i));

        foreach (size_t i, GrString svalue; sconsts)
            writeln(".sconst " ~ to!string(svalue) ~ "\t;" ~ to!string(i));

        foreach (GrFunction func; functions) {
            if (func.isTask)
                writeln("\n.task " ~ func.name);
            else
                writeln("\n.function " ~ func.name);

            foreach (size_t i, GrInstruction instruction; func.instructions) {
                writeln("[" ~ to!string(i) ~ "] " ~ to!string(
                        instruction.opcode) ~ " " ~ to!string(instruction.value));
            }
        }
    }

    package void parseScript(GrData data, GrLexer lexer, int options) {
        _data = data;
        _options = options;

        bool isPublic;
        lexemes = lexer.lexemes;

        beginGlobalScope();
        foreach (GrVariableDefinition variableDef; _data._variableDefinitions) {
            GrVariable variable = registerGlobalVariable(variableDef.name,
                variableDef.type, false, true);
            variable.isConstant = variableDef.isConstant;
            variableDef.register = variable.register;
        }
        endGlobalScope();

        //Type definitions
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexeme.Type.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexeme.Type) {
            case semicolon:
                checkAdvance();
                break;
            case class_:
                registerClassDeclaration(isPublic);
                break;
            case enum_:
                parseEnumDeclaration(isPublic);
                break;
            case event:
            case taskType:
            case functionType:
                skipDeclaration();
                break;
            case alias_:
            default:
                skipExpression();
                break;
            }
        }

        //Type aliases
        reset();
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexeme.Type.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexeme.Type) {
            case semicolon:
                checkAdvance();
                break;
            case alias_:
                parseTypeAliasDeclaration(isPublic);
                break;
            case event:
            case taskType:
            case functionType:
            case class_:
            case enum_:
                skipDeclaration();
                break;
            default:
                skipExpression();
                break;
            }
        }

        //Function definitions
        reset();
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexeme.Type.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexeme.Type) {
            case semicolon:
                checkAdvance();
                break;
            case enum_:
            case class_:
                skipDeclaration();
                break;
            case event:
                parseEventDeclaration(isPublic);
                break;
            case taskType:
                if (get(1).type != GrLexeme.Type.identifier && get(1).type != GrLexeme.Type.lesser)
                    goto case integerType;
                parseTaskDeclaration(isPublic);
                break;
            case functionType:
                if (get(1).type != GrLexeme.Type.identifier && !get(1)
                    .isOperator && get(1).type != GrLexeme.Type.as && get(1)
                    .type != GrLexeme.Type.lesser)
                    goto case integerType;
                parseFunctionDeclaration(isPublic);
                break;
            case integerType: .. case channelType:
            case autoType:
            case identifier:
            case alias_:
                skipExpression();
                break;
            default:
                logError(getError(Error.globalDeclExpected),
                    format(getError(Error.globalDeclExpectedFoundX), getPrettyLexemeType(get()
                        .type)));
            }
        }

        //Global variable definitions
        reset();
        beginGlobalScope();
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexeme.Type.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexeme.Type) {
            case semicolon:
                checkAdvance();
                break;
            case event:
            case enum_:
            case class_:
                skipDeclaration();
                break;
            case taskType:
                if (get(1).type != GrLexeme.Type.identifier && get(1).type != GrLexeme.Type.lesser)
                    goto case integerType;
                skipDeclaration();
                break;
            case functionType:
                if (get(1).type != GrLexeme.Type.identifier && !get(1)
                    .isOperator && get(1).type != GrLexeme.Type.as && get(1)
                    .type != GrLexeme.Type.lesser)
                    goto case integerType;
                skipDeclaration();
                break;
            case integerType: .. case channelType:
            case autoType:
                parseGlobalDeclaration(isPublic);
                break;
            case identifier:
                if (_data.isTypeDeclared(get().svalue, get().fileId, false)) {
                    parseGlobalDeclaration(isPublic);
                    break;
                }
                goto default;
            case alias_:
                skipExpression();
                break;
            default:
                logError(getError(Error.globalDeclExpected),
                    format(getError(Error.globalDeclExpectedFoundX), getPrettyLexemeType(get()
                        .type)));
            }
        }
        endGlobalScope();

        while (functionsQueue.length) {
            GrFunction func = functionsQueue[$ - 1];
            functionsQueue.length--;
            parseFunction(func);
        }
    }

    /**
    Parse the body of global functions
    */
    void parseFunction(GrFunction func) {
        if (func.isEvent) {
            func.index = cast(uint) events.length;
            events ~= func;
        }
        else {
            func.index = cast(uint) functions.length;
            functions ~= func;
        }

        functionStack ~= currentFunction;
        currentFunction = func;

        for (int i; i < func.templateVariables.length; ++i) {
            _data.addTemplateAlias(func.templateVariables[i],
                func.templateSignature[i], func.fileId, func.isPublic);
        }
        current = func.lexPosition;
        parseWhereStatement(func.templateVariables);
        openDeferrableSection();
        parseBlock(false, true);
        if (func.isTask || func.isEvent) {
            if (!currentFunction.instructions.length
                || currentFunction.instructions[$ - 1].opcode != GrOpcode.die)
                addDie();
        }
        else {
            if (!currentFunction.outSignature.length) {
                if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    addReturn();
            }
            else {
                if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    logError(getError(Error.funcMissingRetAtEnd), getError(Error.missingRet));
            }
        }
        closeDeferrableSection();
        registerDeferBlocks();

        endFunction();
        _data.clearTemplateAliases();
    }

    /**
    Declare a new alias of a type.
    */
    private void parseTypeAliasDeclaration(bool isPublic) {
        const uint fileId = get().fileId;
        checkAdvance();
        if (get().type != GrLexeme.Type.identifier)
            logError(format(getError(Error.expectedTypeAliasNameFoundX),
                    getPrettyLexemeType(get().type)), getError(Error.missingIdentifier));
        const string typeAliasName = get().svalue;
        checkAdvance();
        if (get().type != GrLexeme.Type.assign)
            logError(getError(Error.missingAssignInType),
                format(getError(Error.expectedXFoundY), "=", getPrettyLexemeType(get().type)));
        checkAdvance();
        GrType type = parseType(true);
        if (get().type != GrLexeme.Type.semicolon)
            logError(getError(Error.missingSemicolonAfterType),
                format(getError(Error.expectedXFoundY), ";", getPrettyLexemeType(get().type)));

        if (_data.isTypeDeclared(typeAliasName, fileId, isPublic))
            logError(format(getError(Error.nameXDefMultipleTimes), typeAliasName),
                format(getError(Error.alreadyDef), typeAliasName));
        _data.addTypeAlias(typeAliasName, type, fileId, isPublic);
    }

    private void parseEnumDeclaration(bool isPublic) {
        const uint fileId = get().fileId;
        checkAdvance();
        if (get().type != GrLexeme.Type.identifier)
            logError(format(getError(Error.expectedEnumNameFoundX),
                    getPrettyLexemeType(get().type)), getError(Error.missingIdentifier));
        const string enumName = get().svalue;
        checkAdvance();
        if (get().type != GrLexeme.Type.leftCurlyBrace)
            logError(getError(Error.enumDefNotHaveBody),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftCurlyBrace), getPrettyLexemeType(get().type)));
        checkAdvance();

        string[] fields;
        while (!isEnd()) {
            if (get().type == GrLexeme.Type.rightCurlyBrace) {
                checkAdvance();
                break;
            }
            if (get().type != GrLexeme.Type.identifier)
                logError(format(getError(Error.expectedEnumFieldFoundX), getPrettyLexemeType(get()
                        .type)), getError(Error.missingIdentifier));

            auto fieldName = get().svalue;
            checkAdvance();
            fields ~= fieldName;

            if (get().type != GrLexeme.Type.semicolon)
                logError(getError(Error.missingSemicolonAfterEnumField),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.semicolon), getPrettyLexemeType(get().type)));
            checkAdvance();
        }
        if (_data.isTypeDeclared(enumName, fileId, isPublic))
            logError(format(getError(Error.nameXDefMultipleTimes), enumName),
                format(getError(Error.xAlreadyDecl), enumName));
        _data.addEnum(enumName, fields, fileId, isPublic);
    }

    private void registerClassDeclaration(bool isPublic) {
        checkAdvance();
        string[] templateVariables = parseTemplateVariables();
        const uint fileId = get().fileId;
        const uint declPosition = current;
        if (get().type != GrLexeme.Type.identifier)
            logError(format(getError(Error.expectedClassNameFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));
        const string className = get().svalue;
        if (_data.isTypeDeclared(className, fileId, isPublic))
            logError(format(getError(Error.nameXDefMultipleTimes), className),
                format(getError(Error.xAlreadyDecl), className));
        _data.registerClass(className, fileId, isPublic, templateVariables, declPosition);

        if (get(1).type != GrLexeme.Type.leftCurlyBrace) {
            checkAdvance();
            logError(getError(Error.classHaveNoBody),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftCurlyBrace), getPrettyLexemeType(get().type)));
        }

        skipDeclaration();
    }

    private GrClassDefinition getClass(string mangledType, uint fileId) {
        GrClassDefinition class_ = _data.getClass(mangledType, fileId);
        if (!class_)
            return null;
        parseClassDeclaration(class_);
        return class_;
    }

    private void parseClassDeclaration(GrClassDefinition class_) {
        if (class_.isParsed)
            return;
        class_.isParsed = true;
        uint tempPos = current;
        current = class_.position;

        for (int i; i < class_.templateVariables.length; ++i) {
            _data.addTemplateAlias(class_.templateVariables[i],
                class_.templateTypes[i], class_.fileId, class_.isPublic);
        }

        uint[] fieldPositions;
        if (get().type != GrLexeme.Type.identifier)
            logError(format(getError(Error.expectedClassNameFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));
        const string className = get().svalue;
        string parentClassName;
        checkAdvance();

        //Inheritance
        if (get().type == GrLexeme.Type.colon) {
            checkAdvance();
            if (get().type != GrLexeme.Type.identifier)
                logError(getError(Error.parentClassNameMissing),
                    format(getError(Error.expectedClassNameFoundX), getPrettyLexemeType(get()
                        .type)));
            parentClassName = get().svalue;
            checkAdvance();
            parentClassName = grMangleComposite(parentClassName, parseTemplateSignature());
        }
        if (get().type != GrLexeme.Type.leftCurlyBrace)
            logError(getError(Error.classHaveNoBody),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftCurlyBrace), getPrettyLexemeType(get().type)));
        checkAdvance();

        string[] fields;
        GrType[] signature;
        bool[] fieldScopes;
        while (!isEnd()) {
            if (get().type == GrLexeme.Type.rightCurlyBrace) {
                checkAdvance();
                break;
            }

            bool isFieldPublic = false;
            if (get().type == GrLexeme.Type.public_) {
                isFieldPublic = true;
                checkAdvance();
            }

            GrType fieldType = parseType();
            do {
                if (get().type == GrLexeme.Type.comma)
                    checkAdvance();

                const string fieldName = get().svalue;
                signature ~= fieldType;
                fields ~= fieldName;
                fieldScopes ~= isFieldPublic;
                fieldPositions ~= current;
                checkAdvance();
            }
            while (get().type == GrLexeme.Type.comma);

            if (get().type != GrLexeme.Type.semicolon)
                logError(getError(Error.missingSemicolonAfterClassFieldDecl),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.semicolon), getPrettyLexemeType(get().type)));
            checkAdvance();

            if (get().type == GrLexeme.Type.rightCurlyBrace) {
                checkAdvance();
                break;
            }
        }

        class_.parent = parentClassName;
        class_.signature = signature;
        class_.fields = fields;

        class_.fieldsInfo.length = fields.length;
        for (int i; i < class_.fieldsInfo.length; ++i) {
            class_.fieldsInfo[i].fileId = class_.fileId;
            class_.fieldsInfo[i].isPublic = fieldScopes[i];
            class_.fieldsInfo[i].position = fieldPositions[i];
        }
        current = tempPos;
        _data.clearTemplateAliases();
        resolveClassInheritence(class_);
    }

    /// Fetch fields and signature of parent classes
    private void resolveClassInheritence(GrClassDefinition class_) {
        uint fileId = class_.fileId;
        string parent = class_.parent;
        GrClassDefinition lastClass = class_;
        string[] usedClasses = [class_.name];

        while (parent.length) {
            GrClassDefinition parentClass = getClass(parent, fileId);
            if (!parentClass) {
                set(lastClass.position + 2u);
                logError(format(getError(Error.xCantInheritFromY), getPrettyType(
                        grGetClassType(class_.name)), parent),
                    getError(Error.unknownClass));
            }
            for (int i; i < usedClasses.length; ++i) {
                if (parent == usedClasses[i]) {
                    set(lastClass.position + 2u);
                    logError(format(getError(Error.xIncludedRecursively), getPrettyType(
                            grGetClassType(parent))),
                        getError(Error.recursiveInheritence));
                }
            }
            usedClasses ~= parent;
            class_.fields = parentClass.fields ~ class_.fields;
            class_.signature = parentClass.signature ~ class_.signature;
            class_.fieldsInfo = parentClass.fieldsInfo ~ class_.fieldsInfo;
            fileId = parentClass.fileId;
            parent = parentClass.parent;
            lastClass = parentClass;
        }
        for (int i; i < class_.signature.length; ++i) {
            for (int y; y < class_.fields.length; ++y) {
                if (i != y && class_.fields[i] == class_.fields[y]) {
                    int first;
                    int second;
                    if (class_.fieldsInfo[i].position < class_.fieldsInfo[y].position) {
                        first = i;
                        second = y;
                    }
                    else {
                        first = y;
                        second = i;
                    }
                    set(class_.fieldsInfo[second].position);
                    logError(format(getError(Error.fieldXDeclMultipleTimes), class_.fields[second]),
                        format(getError(Error.xRedefHere), class_.fields[second]),
                        "", 0, format(getError(Error.prevDefOfX), class_.fields[first]),
                        class_.fieldsInfo[first].position);
                }
            }
            if (class_.signature[i].base != GrType.Base.class_) {
                for (int y; y < usedClasses.length; ++y) {
                    if (class_.signature[i].mangledType == usedClasses[y]) {
                        set(class_.fieldsInfo[i].position);
                        logError(format(getError(Error.xIncludedRecursively), class_
                                .signature[i].mangledType),
                            getError(Error.recursiveDecl));
                    }
                }
            }
        }
    }

    private void skipDeclaration() {
        checkAdvance();
        while (!isEnd()) {
            if (get().type != GrLexeme.Type.leftCurlyBrace) {
                checkAdvance();
            }
            else {
                skipBlock();
                return;
            }
        }
    }

    private void skipExpression() {
        checkAdvance();
        while (!isEnd()) {
            switch (get().type) with (GrLexeme.Type) {
            case semicolon:
                checkAdvance();
                return;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                checkAdvance();
                break;
            }
        }
    }

    private GrType parseType(bool mustBeType = true, string[] templateVariables = [
        ]) {
        GrType currentType = GrType.Base.void_;

        GrLexeme lex = get();
        if (!lex.isType) {
            if (lex.type == GrLexeme.Type.identifier) {
                foreach (tempVar; templateVariables) {
                    if (tempVar == lex.svalue) {
                        checkAdvance();
                        return grAny(lex.svalue);
                    }
                }
            }
            if (lex.type == GrLexeme.Type.identifier
                && _data.isTypeAlias(lex.svalue, lex.fileId, false)) {
                currentType = _data.getTypeAlias(lex.svalue, lex.fileId).type;
                checkAdvance();
                return currentType;
            }
            else if (lex.type == GrLexeme.Type.identifier
                && _data.isClass(lex.svalue, lex.fileId, false)) {
                currentType.base = GrType.Base.class_;
                checkAdvance();
                currentType.mangledType = grMangleComposite(lex.svalue, parseTemplateSignature(
                        templateVariables));
                if (mustBeType) {
                    GrClassDefinition class_ = getClass(currentType.mangledType, lex.fileId);
                    if (!class_)
                        logError(format(getError(Error.xIsAbstract),
                                getPrettyType(currentType)), format(getError(
                                Error.xIsAbstractAndCannotBeInstanciated), getPrettyType(
                                currentType)), "", -1);
                }
                return currentType;
            }
            else if (lex.type == GrLexeme.Type.identifier
                && _data.isEnum(lex.svalue, lex.fileId, false)) {
                currentType.base = GrType.Base.enum_;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                return currentType;
            }
            else if (lex.type == GrLexeme.Type.identifier && _data.isForeign(lex.svalue)) {
                currentType.base = GrType.Base.foreign;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                currentType.mangledType = grMangleComposite(lex.svalue, parseTemplateSignature(
                        templateVariables));
                if (mustBeType) {
                    GrForeignDefinition foreign = _data.getForeign(currentType.mangledType);
                    if (!foreign)
                        logError(format(getError(Error.xIsAbstract),
                                getPrettyType(currentType)), format(getError(
                                Error.xIsAbstractAndCannotBeInstanciated), getPrettyType(
                                currentType)), "", -1);
                }
                return currentType;
            }
            else if (mustBeType) {
                const string typeName = lex.type == GrLexeme.Type.identifier
                    ? lex.svalue : getPrettyLexemeType(lex.type);
                logError(format(getError(Error.xNotValidType), typeName),
                    format(getError(Error.expectedValidTypeFoundX), typeName));
            }
            else {
                return currentType;
            }
        }

        switch (lex.type) with (GrLexeme.Type) {
        case integerType:
            currentType.base = GrType.Base.int_;
            checkAdvance();
            break;
        case realType:
            currentType.base = GrType.Base.real_;
            checkAdvance();
            break;
        case booleanType:
            currentType.base = GrType.Base.bool_;
            checkAdvance();
            break;
        case stringType:
            currentType.base = GrType.Base.string_;
            checkAdvance();
            break;
        case arrayType:
            currentType.base = GrType.Base.array;
            checkAdvance();
            string[] temp;
            auto signature = parseInSignature(temp, true, templateVariables);
            if (signature.length > 1) {
                logError(getError(Error.arrayCanOnlyContainOneTypeOfVal), getError(Error.conflictingArraySignature),
                    format(getError(Error.tryUsingXInstead), getPrettyType(grArray(signature[0]))), -1);
            }
            else if (signature.length == 0) {
                logError(getError(Error.arrayCanOnlyContainOneTypeOfVal), getError(
                        Error.conflictingArraySignature), "", -1);
            }
            currentType.mangledType = grMangleSignature(signature);
            break;
        case functionType:
            currentType.base = GrType.Base.function_;
            checkAdvance();
            string[] temp;
            currentType.mangledType = grMangleSignature(parseInSignature(temp, true, templateVariables));
            currentType.mangledReturnType = grMangleSignature(parseOutSignature());
            break;
        case taskType:
            currentType.base = GrType.Base.task;
            checkAdvance();
            string[] temp;
            currentType.mangledType = grMangleSignature(parseInSignature(temp, true, templateVariables));
            break;
        case channelType:
            currentType.base = GrType.Base.channel;
            checkAdvance();
            string[] temp;
            GrType[] signature = parseInSignature(temp, true, templateVariables);
            if (signature.length != 1)
                logError(getError(Error.channelCanOnlyContainOneTypeOfVal), getError(Error.conflictingChannelSignature),
                    format(getError(Error.tryUsingXInstead), getPrettyType(grChannel(signature[0]))), -1);
            currentType.mangledType = grMangleSignature(signature);
            break;
        default:
            logError(format(getError(Error.xNotValidType), getPrettyLexemeType(lex.type)),
                format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get().type)));
        }

        return currentType;
    }

    private void addGlobalPop(GrType type) {
        final switch (type.base) with (GrType.Base) {
        case internalTuple:
        case null_:
        case void_:
            logError(format(getError(Error.xNotValidType), getPrettyType(type)), format(
                    getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get().type)));
            break;
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.globalPop_int, 0u);
            break;
        case real_:
            addInstruction(GrOpcode.globalPop_real, 0u);
            break;
        case string_:
            addInstruction(GrOpcode.globalPop_string, 0u);
            break;
        case class_:
        case array:
        case foreign:
        case channel:
        case reference:
            addInstruction(GrOpcode.globalPop_object, 0u);
            break;
        }
    }

    private void addGlobalPush(GrType type, int nbPush = 1u) {
        if (nbPush == 0)
            return;
        final switch (type.base) with (GrType.Base) {
        case internalTuple:
        case null_:
        case void_:
            logError(format(getError(Error.xNotValidType), getPrettyType(type)), format(
                    getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get().type)));
            break;
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.globalPush_int, nbPush);
            break;
        case real_:
            addInstruction(GrOpcode.globalPush_real, nbPush);
            break;
        case string_:
            addInstruction(GrOpcode.globalPush_string, nbPush);
            break;
        case class_:
        case array:
        case foreign:
        case channel:
        case reference:
            addInstruction(GrOpcode.globalPush_object, nbPush);
            break;
        }
    }

    private void addGlobalPush(GrType[] signature) {
        struct TypeCounter {
            uint nbIntParams, nbRealParams, nbStringParams, nbObjectParams;
        }

        void countParameters(ref TypeCounter typeCounter, GrType type) {
            final switch (type.base) with (GrType.Base) {
            case internalTuple:
            case null_:
            case void_:
                logError(format(getError(Error.xNotValidType), getPrettyType(type)), format(
                        getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(
                        get().type)));
                break;
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                typeCounter.nbIntParams++;
                break;
            case real_:
                typeCounter.nbRealParams++;
                break;
            case string_:
                typeCounter.nbStringParams++;
                break;
            case class_:
            case array:
            case foreign:
            case channel:
            case reference:
                typeCounter.nbObjectParams++;
                break;
            }
        }

        TypeCounter typeCounter;
        foreach (type; signature) {
            countParameters(typeCounter, type);
        }

        if (typeCounter.nbIntParams > 0)
            addInstruction(GrOpcode.globalPush_int, typeCounter.nbIntParams);
        if (typeCounter.nbRealParams > 0)
            addInstruction(GrOpcode.globalPush_real, typeCounter.nbRealParams);
        if (typeCounter.nbStringParams > 0)
            addInstruction(GrOpcode.globalPush_string, typeCounter.nbStringParams);
        if (typeCounter.nbObjectParams > 0)
            addInstruction(GrOpcode.globalPush_object, typeCounter.nbObjectParams);
    }

    private string[] parseTemplateVariables() {
        string[] variables;
        if (get().type != GrLexeme.Type.lesser)
            return variables;
        checkAdvance();
        if (get().type == GrLexeme.Type.greater) {
            checkAdvance();
            return variables;
        }
        for (;;) {
            if (get().type != GrLexeme.Type.identifier)
                logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                        .type)), getError(Error.missingTemplateVal));
            variables ~= get().svalue;
            checkAdvance();

            const GrLexeme lex = get();
            if (lex.type == GrLexeme.Type.greater) {
                checkAdvance();
                break;
            }
            else if (lex.type != GrLexeme.Type.comma)
                logError(getError(Error.templateValShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.comma), getPrettyLexemeType(lex.type)));
            checkAdvance();
        }
        return variables;
    }

    private GrType[] parseTemplateSignature(string[] templateVariables = []) {
        GrType[] signature;
        if (get().type != GrLexeme.Type.lesser)
            return signature;
        checkAdvance();
        if (get().type == GrLexeme.Type.greater) {
            checkAdvance();
            return signature;
        }
        for (;;) {
            signature ~= parseType(true, templateVariables);

            const GrLexeme lex = get();
            if (lex.type == GrLexeme.Type.greater) {
                checkAdvance();
                break;
            }
            else if (lex.type != GrLexeme.Type.comma)
                logError(getError(Error.templateTypesShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.comma), getPrettyLexemeType(lex.type)));
            checkAdvance();
        }
        return signature;
    }

    private GrType[] parseInSignature(ref string[] inputVariables, bool asType = false, string[] templateVariables = [
        ]) {
        GrType[] inSignature;

        if (get().type != GrLexeme.Type.leftParenthesis)
            logError(getError(Error.missingParentheses),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));

        bool startLoop = true;
        for (;;) {
            checkAdvance();
            GrLexeme lex = get();

            if (startLoop && lex.type == GrLexeme.Type.rightParenthesis)
                break;
            startLoop = false;
            inSignature ~= parseType(true, templateVariables);

            //If we want to know whether it's a type or an anon, we can't throw exceptions.
            if (isTypeChecking) {
                lex = get();
                if (get().type == GrLexeme.Type.identifier) {
                    inputVariables ~= lex.svalue;
                    checkAdvance();
                    lex = get();
                }

                if (lex.type == GrLexeme.Type.rightParenthesis)
                    break;
                else if (lex.type != GrLexeme.Type.comma)
                    logError(getError(Error.paramShouldBeSeparatedByComma),
                        format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                            GrLexeme.Type.comma), getPrettyLexemeType(get().type)));
            }
            else {
                //Is it a function type or a function declaration ?
                if (!asType) {
                    lex = get();
                    if (get().type != GrLexeme.Type.identifier)
                        logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                                .type)), getError(Error.missingIdentifier));
                    inputVariables ~= lex.svalue;
                    checkAdvance();
                }

                lex = get();
                if (lex.type == GrLexeme.Type.rightParenthesis)
                    break;
                else if (lex.type != GrLexeme.Type.comma)
                    logError(getError(Error.paramShouldBeSeparatedByComma),
                        format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                            GrLexeme.Type.comma), getPrettyLexemeType(get().type)));
            }
        }
        checkAdvance();

        return inSignature;
    }

    private GrType[] parseOutSignature(string[] templateVariables = []) {
        GrType[] outSignature;
        if (get().type != GrLexeme.Type.leftParenthesis)
            return outSignature;
        checkAdvance();
        if (get().type == GrLexeme.Type.rightParenthesis) {
            checkAdvance();
            return outSignature;
        }
        for (;;) {
            outSignature ~= parseType(true, templateVariables);

            const GrLexeme lex = get();
            if (lex.type == GrLexeme.Type.rightParenthesis) {
                checkAdvance();
                break;
            }
            else if (lex.type != GrLexeme.Type.comma)
                logError(getError(Error.typesShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.comma), getPrettyLexemeType(lex.type)));
            checkAdvance();
        }
        return outSignature;
    }

    private void parseEventDeclaration(bool isPublic) {
        if (isPublic)
            logError(getError(Error.addingPubBeforeEventIsRedundant), getError(
                    Error.eventAlreadyPublic));
        checkAdvance();
        if (get().type != GrLexeme.Type.identifier)
            logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));
        string name = get().svalue;
        string[] inputs;
        checkAdvance();
        GrType[] signature = parseInSignature(inputs);
        preBeginFunction(name, get().fileId, signature, inputs, false, [], false, true, true);
        skipBlock(true);
        preEndFunction();
    }

    private void parseTaskDeclaration(bool isPublic) {
        checkAdvance();
        string[] templateVariables = parseTemplateVariables();
        if (get().type != GrLexeme.Type.identifier)
            logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));

        string name = get().svalue;
        checkAdvance();

        GrTemplateFunction temp = new GrTemplateFunction;
        temp.isTask = true;
        temp.name = name;
        temp.templateVariables = templateVariables;
        temp.fileId = get().fileId;
        temp.isPublic = isPublic;
        temp.lexPosition = current;

        string[] inputs;
        temp.inSignature = parseInSignature(inputs, false, templateVariables);
        temp.constraints = parseWhereStatement(templateVariables);
        templatedFunctions ~= temp;
        skipBlock(true);
    }

    private void parseFunctionDeclaration(bool isPublic) {
        checkAdvance();
        string[] templateVariables = parseTemplateVariables();
        string name;
        bool isConversion;
        if (get().type == GrLexeme.Type.as) {
            name = "@as";
            isConversion = true;
        }
        else if (get().type == GrLexeme.Type.new_) {
            name = "@new";
        }
        else if (get().type == GrLexeme.Type.identifier) {
            if (get().svalue == "operator") {
                advance();
                if (get().isOverridableOperator()) {
                    name = "@op_" ~ getPrettyLexemeType(get().type);
                }
                else if (get().isOperator) {
                    logError(format(getError(Error.cantOverrideXOp), getPrettyLexemeType(get()
                            .type)), getError(Error.opCantBeOverriden));
                }
                else {
                    logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                            .type)), getError(Error.missingIdentifier));
                }
            }
            else {
                name = get().svalue;
            }
        }
        else {
            logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));
        }

        checkAdvance();

        GrTemplateFunction temp = new GrTemplateFunction;
        temp.isTask = false;
        temp.name = name;
        temp.isConversion = isConversion;
        temp.templateVariables = templateVariables;
        temp.fileId = get().fileId;
        temp.isPublic = isPublic;
        temp.lexPosition = current;

        string[] inputs;
        temp.inSignature = parseInSignature(inputs, false, templateVariables);
        temp.outSignature = parseOutSignature(templateVariables);
        if (name == "@as" || name == "@new")
            temp.inSignature ~= temp.outSignature;
        temp.constraints = parseWhereStatement(templateVariables);
        templatedFunctions ~= temp;
        skipBlock(true);
    }

    private GrConstraint[] parseWhereStatement(string[] templateVariables) {
        GrConstraint[] constraints;
        if (get().type != GrLexeme.Type.where)
            return constraints;
        checkAdvance();

        for (;;) {
            GrType type = parseType(true, templateVariables);

            if (get().type != GrLexeme.Type.colon)
                logError(getError(Error.expectedColonAfterType),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.colon), getPrettyLexemeType(get().type)));
            checkAdvance();

            if (get().type != GrLexeme.Type.identifier)
                logError(getError(Error.missingConstraint),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.identifier), getPrettyLexemeType(get().type)));

            GrConstraint.Data constraintData = grGetConstraint(get().svalue);
            if (!constraintData.predicate) {
                const string[] nearestValues = findNearestStrings(get().svalue, grGetAllConstraintsName());
                string errorNote;
                if (nearestValues.length) {
                    foreach (size_t i, const string value; nearestValues) {
                        errorNote ~= "`" ~ value ~ "`";
                        if ((i + 1) < nearestValues.length)
                            errorNote ~= ", ";
                    }
                    errorNote ~= ".";
                }
                logError(getError(Error.missingConstraint),
                    format(getError(Error.xIsNotAKnownConstraint), get().svalue),
                    format(getError(Error.validConstraintsAreX), errorNote));
            }
            checkAdvance();
            GrType[] parameters = parseTemplateSignature(templateVariables);
            constraints ~= new GrConstraint(constraintData.predicate, constraintData.arity, type, parameters);
            if (constraintData.arity != parameters.length)
                logError(format(getError(constraintData.arity > 1 ? Error.constraintTakesXArgsButYWereSupplied
                        : Error.constraintTakesXArgButYWereSupplied), constraintData.arity, parameters
                        .length),
                    format(getError(constraintData.arity > 1 ? Error.expectedXArgsFoundY
                        : Error.expectedXArgFoundY), constraintData.arity, parameters.length), "", -1);

            if (get().type != GrLexeme.Type.comma)
                break;
            advance();
        }
        return constraints;
    }

    private GrFunction parseTemplatedFunctionDeclaration(GrTemplateFunction temp,
        GrType[] templateList) {
        const auto lastPosition = current;
        current = temp.lexPosition;

        for (int i; i < temp.templateVariables.length; ++i) {
            _data.addTemplateAlias(temp.templateVariables[i], templateList[i],
                temp.fileId, temp.isPublic);
        }

        string[] inputs;
        GrType[] inSignature = parseInSignature(inputs);
        GrType[] outSignature;

        if (!temp.isTask) {
            //Return Type.
            if (temp.isConversion) {
                if (inSignature.length != 1uL) {
                    logError(getError(Error.convMustHave1Param),
                        format(getError(inSignature.length > 1 ? Error.expected1ParamFoundXs
                            : Error
                            .expected1ParamFoundX), inSignature.length));
                }
                outSignature = parseOutSignature();
                if (outSignature.length != 1uL) {
                    logError(getError(Error.convMustHave1RetVal),
                        format(getError(outSignature.length > 1 ? Error.expected1RetValFoundXs
                            : Error.expected1RetValFoundX), outSignature.length));
                }

                inSignature ~= outSignature[0];
            }
            else
                outSignature = parseOutSignature();
        }

        GrFunction func = new GrFunction;
        func.isTask = temp.isTask;
        func.name = temp.name;
        func.inputVariables = inputs;
        func.inSignature = inSignature;
        func.outSignature = outSignature;
        func.fileId = temp.fileId;
        func.isPublic = temp.isPublic;
        func.lexPosition = current;
        func.templateVariables = temp.templateVariables;
        func.templateSignature = templateList;

        _data.clearTemplateAliases();
        current = lastPosition;
        return func;
    }

    private GrType parseAnonymousFunction(bool isTask) {
        checkAdvance();
        string[] inputs;
        GrType[] outSignature;
        GrType[] inSignature = parseInSignature(inputs);

        if (!isTask) {
            //Return Type.
            outSignature = parseOutSignature();
        }
        preBeginFunction("$anon", get().fileId, inSignature, inputs, isTask, outSignature, true);
        openDeferrableSection();
        parseBlock();

        if (isTask) {
            if (!currentFunction.instructions.length
                || currentFunction.instructions[$ - 1].opcode != GrOpcode.die)
                addDie();
        }
        else {
            if (!outSignature.length) {
                if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    addReturn();
            }
            else {
                if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    logError(getError(Error.funcMissingRetAtEnd), getError(Error.missingRet));
            }
        }

        closeDeferrableSection();
        registerDeferBlocks();

        endFunction();

        GrType functionType = isTask ? GrType.Base.task : GrType.Base.function_;
        functionType.mangledType = grMangleSignature(inSignature);
        functionType.mangledReturnType = grMangleSignature(outSignature);

        return functionType;
    }

    /**
    Parse either multiple lines between `{` and `}` or a single expression.
    */
    private void parseBlock(bool changeOptimizationBlockLevel = false, bool mustBeMultiline = false) {
        if (changeOptimizationBlockLevel)
            _isAssignationOptimizable = false;
        bool isMultiline;
        if (get().type == GrLexeme.Type.leftCurlyBrace) {
            isMultiline = true;
            if (!checkAdvance())
                logError(getError(Error.eof),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.rightCurlyBrace), getPrettyLexemeType(get().type)));
        }
        else if (mustBeMultiline) {
            logError(getError(Error.missingCurlyBraces),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftCurlyBrace), getPrettyLexemeType(get().type)));
        }
        openBlock();

        void parseStatement() {
            switch (get().type) with (GrLexeme.Type) {
            case semicolon:
            case rightCurlyBrace:
                advance();
                break;
            case leftCurlyBrace:
                parseBlock();
                break;
            case defer:
                parseDeferStatement();
                break;
            case if_:
            case unless:
                parseIfStatement();
                break;
            case switch_:
                parseSwitchStatement();
                break;
            case select:
                parseSelectStatement();
                break;
            case until:
            case while_:
                parseWhileStatement();
                break;
            case do_:
                parseDoWhileStatement();
                break;
            case for_:
                parseForStatement();
                break;
            case loop:
                parseLoopStatement();
                break;
            case throw_:
                parseThrowStatement();
                break;
            case try_:
                parseExceptionHandler();
                break;
            case return_:
                parseReturnStatement();
                break;
            case die:
                parseDieStatement();
                break;
            case quit:
                parseQuitStatement();
                break;
            case yield:
                parseYieldStatement();
                break;
            case continue_:
                parseContinueStatement();
                break;
            case break_:
                parseBreakStatement();
                break;
            case integerType: .. case autoType:
                if (isDeclaration())
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            case identifier:
                if (_data.isTypeDeclared(get().svalue, get().fileId, false)
                    && get(1).type != GrLexeme.Type.leftParenthesis)
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            default:
                parseExpression();
                break;
            }
        }

        if (isMultiline) {
            while (!isEnd()) {
                if (get().type == GrLexeme.Type.rightCurlyBrace)
                    break;
                parseStatement();
            }
        }
        else {
            if (get().type != GrLexeme.Type.semicolon)
                parseStatement();
        }

        if (isMultiline) {
            if (get().type != GrLexeme.Type.rightCurlyBrace)
                logError(getError(Error.missingCurlyBraces),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.rightCurlyBrace), getPrettyLexemeType(get().type)));
            checkAdvance();
        }
        closeBlock();
        if (changeOptimizationBlockLevel)
            _isAssignationOptimizable = false;
    }

    private bool isDeclaration() {
        const auto tempPos = current;
        isTypeChecking = true;
        if (get().type == GrLexeme.Type.autoType)
            checkAdvance();
        else
            parseType(false);
        isTypeChecking = false;
        bool isDecl;
        if (get().type == GrLexeme.Type.identifier)
            isDecl = true;
        current = tempPos;
        return isDecl;
    }

    private void skipBlock(bool mustBeMultiline = false) {
        bool isMultiline;
        if (get().type == GrLexeme.Type.leftCurlyBrace) {
            isMultiline = true;
            if (!checkAdvance())
                logError(getError(Error.eof),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.rightCurlyBrace), getPrettyLexemeType(get().type)));
        }
        else if (mustBeMultiline) {
            logError(getError(Error.missingCurlyBraces),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftCurlyBrace), getPrettyLexemeType(get().type)));
        }
        openBlock();

        void skipStatement() {
            switch (get().type) with (GrLexeme.Type) {
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            case defer:
                checkAdvance();
                skipBlock();
                break;
            case switch_:
                checkAdvance();
                skipParenthesis();
                while (get().type == GrLexeme.Type.case_) {
                    checkAdvance();
                    if (get().type == GrLexeme.Type.leftParenthesis)
                        skipParenthesis();
                    skipBlock();
                }
                break;
            case if_:
            case unless:
                checkAdvance();
                skipParenthesis();
                skipBlock();
                break;
            case select:
                checkAdvance();
                while (get().type == GrLexeme.Type.case_) {
                    checkAdvance();
                    if (get().type == GrLexeme.Type.leftParenthesis)
                        skipParenthesis();
                    skipBlock();
                }
                break;
            case until:
            case while_:
                checkAdvance();
                skipBlock();
                break;
            case do_:
                checkAdvance();
                skipBlock();
                checkAdvance();
                skipParenthesis();
                break;
            case for_:
                checkAdvance();
                skipParenthesis();
                skipBlock();
                break;
            case loop:
                checkAdvance();
                if (get().type == GrLexeme.Type.leftParenthesis)
                    skipParenthesis();
                skipBlock();
                break;
            case throw_:
                checkAdvance();
                skipBlock();
                break;
            case try_:
                checkAdvance();
                skipBlock();
                if (get().type == GrLexeme.Type.catch_) {
                    checkAdvance();
                    skipParenthesis();
                    skipBlock();
                }
                break;
            case yield:
                checkAdvance();
                break;
            case return_:
                checkAdvance();
                skipBlock();
                break;
            default:
                checkAdvance();
                break;
            }
        }

        if (isMultiline) {
            while (!isEnd()) {
                if (get().type == GrLexeme.Type.rightCurlyBrace)
                    break;
                switch (get().type) with (GrLexeme.Type) {
                case leftParenthesis:
                    skipParenthesis();
                    break;
                case leftBracket:
                    skipBrackets();
                    break;
                case leftCurlyBrace:
                    skipBlock();
                    break;
                default:
                    checkAdvance();
                    break;
                }
            }

            if (get().type != GrLexeme.Type.rightCurlyBrace)
                logError(getError(Error.missingCurlyBraces),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.rightCurlyBrace), getPrettyLexemeType(get().type)));
            checkAdvance();
        }
        else {
            if (get().type != GrLexeme.Type.semicolon)
                skipStatement();
        }
        closeBlock();
    }

    private void parseDieStatement() {
        if (!currentFunction.instructions.length
            || currentFunction.instructions[$ - 1].opcode != GrOpcode.die)
            addDie();
        advance();
    }

    private void parseQuitStatement() {
        if (!currentFunction.instructions.length
            || currentFunction.instructions[$ - 1].opcode != GrOpcode.quit)
            addQuit();
        advance();
    }

    private void parseYieldStatement() {
        addInstruction(GrOpcode.yield, 0u);
        advance();
    }

    //Exception handling
    private void parseThrowStatement() {
        advance();
        GrType type = parseSubExpression(GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_EXPECTING_VALUE)
            .type;
        checkAdvance();
        convertType(type, grString);
        addInstruction(GrOpcode.throw_);
        checkDeferStatement();
    }

    private void parseExceptionHandler() {
        advance();

        const auto isolatePosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.try_);

        parseBlock();

        const uint fileId = get().fileId;
        if (get().type == GrLexeme.Type.catch_) {
            advance();

            if (get().type != GrLexeme.Type.leftParenthesis)
                logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexeme.Type.else_)),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));
            advance();

            if (get().type != GrLexeme.Type.identifier)
                logError(getError(Error.missingIdentifier),
                    format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get().type)));
            GrVariable errVariable = registerLocalVariable(get().svalue, grString);

            advance();
            if (get().type != GrLexeme.Type.rightParenthesis)
                logError(getError(Error.missingParentheses),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.rightParenthesis), getPrettyLexemeType(get().type)));
            advance();

            const auto capturePosition = currentFunction.instructions.length;
            addInstruction(GrOpcode.catch_);

            addInstruction(GrOpcode.globalPop_string);
            addSetInstruction(errVariable, fileId, grString);

            parseBlock(true);

            const auto endPosition = currentFunction.instructions.length;

            setInstruction(GrOpcode.try_, cast(uint) isolatePosition,
                cast(uint)(capturePosition - isolatePosition), true);
            setInstruction(GrOpcode.catch_, cast(uint) capturePosition,
                cast(uint)(endPosition - capturePosition), true);
        }
        else {
            const auto capturePosition = currentFunction.instructions.length;
            addInstruction(GrOpcode.catch_);
            addInstruction(GrOpcode.globalPop_string);
            addInstruction(GrOpcode.shiftStack_string, 1, true);

            const auto endPosition = currentFunction.instructions.length;

            setInstruction(GrOpcode.try_, cast(uint) isolatePosition,
                cast(uint)(capturePosition - isolatePosition), true);
            setInstruction(GrOpcode.catch_, cast(uint) capturePosition,
                cast(uint)(endPosition - capturePosition), true);
        }
    }

    //defer
    private void openDeferrableSection() {
        auto deferrableSection = new GrDeferrableSection;
        deferrableSection.deferInitPositions = cast(uint) currentFunction.instructions.length;
        currentFunction.deferrableSections ~= deferrableSection;

        currentFunction.isDeferrableSectionLocked.length++;
    }

    private void closeDeferrableSection() {
        if (!currentFunction.deferrableSections.length)
            throw new Exception("attempting to close a non-existing function");

        foreach (deferBlock; currentFunction.deferrableSections[$ - 1].deferredBlocks) {
            currentFunction.registeredDeferBlocks ~= deferBlock;
        }

        currentFunction.deferrableSections.length--;
        currentFunction.isDeferrableSectionLocked.length--;
    }

    private void parseDeferStatement() {
        if (currentFunction.isDeferrableSectionLocked[$ - 1])
            logError(getError(Error.deferInsideDefer), getError(Error.cantDeferInsideDefer));
        advance();

        //Register the position of the block for a late parsing.
        GrDeferBlock deferBlock = new GrDeferBlock;
        deferBlock.position = cast(uint) currentFunction.instructions.length;
        deferBlock.parsePosition = current;
        deferBlock.scopeLevel = scopeLevel;
        currentFunction.deferrableSections[$ - 1].deferredBlocks ~= deferBlock;

        addInstruction(GrOpcode.defer);

        //Parse the deferred block at the end of the outer block.
        skipBlock();
    }

    private void checkDeferStatement() {
        if (currentFunction.isDeferrableSectionLocked[$ - 1]) {
            GrLexeme.Type type = get().type;
            logError(format(getError(Error.xInsideDefer), getPrettyLexemeType(type)),
                format(getError(Error.cantXInsideDefer), getPrettyLexemeType(type)));
        }
    }

    private void registerDeferBlocks() {
        const auto tempParsePosition = current;
        const auto startDeferPos = cast(uint) currentFunction.instructions.length;

        const int tempScopeLevel = scopeLevel;
        while (currentFunction.registeredDeferBlocks.length) {
            GrDeferBlock deferBlock = currentFunction.registeredDeferBlocks[0];
            currentFunction.registeredDeferBlocks = currentFunction.registeredDeferBlocks[1 .. $];

            setInstruction(GrOpcode.defer, deferBlock.position,
                cast(int)(currentFunction.instructions.length - deferBlock.position), true);
            current = deferBlock.parsePosition;
            scopeLevel = deferBlock.scopeLevel;

            currentFunction.isDeferrableSectionLocked[$ - 1] = true;
            parseBlock(true);
            currentFunction.isDeferrableSectionLocked[$ - 1] = false;

            addInstruction(GrOpcode.unwind);
        }
        currentFunction.registeredDeferBlocks.length = 0;
        current = tempParsePosition;
        scopeLevel = tempScopeLevel;
    }

    //Break
    private void openBreakableSection() {
        breaksJumps ~= [null];
        _isAssignationOptimizable = false;
    }

    private void closeBreakableSection() {
        if (!breaksJumps.length)
            throw new Exception("attempting to close a non-existing function");

        uint[] breaks = breaksJumps[$ - 1];
        breaksJumps.length--;

        foreach (position; breaks)
            setInstruction(GrOpcode.jump, position,
                cast(int)(currentFunction.instructions.length - position), true);
        _isAssignationOptimizable = false;
    }

    private void parseBreakStatement() {
        if (!breaksJumps.length)
            logError(getError(Error.breakOutsideLoop), getError(Error.cantBreakOutsideLoop));

        breaksJumps[$ - 1] ~= cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.jump);
        advance();
    }

    //Continue
    private void openContinuableSection() {
        continuesJumps.length++;
        _isAssignationOptimizable = false;
    }

    private void closeContinuableSection() {
        if (!continuesJumps.length)
            throw new Exception("attempting to close a non-existing function");

        uint[] continues = continuesJumps[$ - 1];
        const uint destination = continuesDestinations[$ - 1];
        continuesJumps.length--;
        continuesDestinations.length--;

        foreach (position; continues)
            setInstruction(GrOpcode.jump, position, cast(int)(destination - position), true);
        _isAssignationOptimizable = false;
    }

    private void setContinuableSectionDestination() {
        continuesDestinations ~= cast(uint) currentFunction.instructions.length;
    }

    private void parseContinueStatement() {
        if (!continuesJumps.length)
            logError(getError(Error.continueOutsideLoop), getError(Error.cantContinueOutsideLoop));

        continuesJumps[$ - 1] ~= cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.jump);
        advance();
    }

    private void parseGlobalDeclaration(bool isPublic) {
        //GrVariable type
        GrType type = GrType.Base.void_;
        bool isAuto;

        if (get().type == GrLexeme.Type.autoType) {
            isAuto = true;
            checkAdvance();
        }
        else
            type = parseType();

        GrVariable[] lvalues;
        do {
            if (get().type == GrLexeme.Type.comma)
                checkAdvance();
            //Identifier
            if (get().type != GrLexeme.Type.identifier)
                logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                        .type)), getError(Error.missingIdentifier));

            string identifier = get().svalue;

            //Registering
            GrVariable lvalue = registerGlobalVariable(identifier, type, isAuto, isPublic);
            lvalues ~= lvalue;

            checkAdvance();
        }
        while (get().type == GrLexeme.Type.comma);

        parseAssignList(lvalues, true);
    }

    //Type Identifier [= EXPRESSION] ;
    private void parseLocalDeclaration() {
        //GrVariable type
        GrType type = GrType.Base.void_;
        bool isAuto;
        if (get().type == GrLexeme.Type.autoType) {
            isAuto = true;
            checkAdvance();
        }
        else
            type = parseType();

        GrVariable[] lvalues;
        do {
            if (get().type == GrLexeme.Type.comma)
                checkAdvance();
            //Identifier
            if (get().type != GrLexeme.Type.identifier)
                logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                        .type)), getError(Error.missingIdentifier));

            string identifier = get().svalue;

            //Registering
            GrVariable lvalue = registerLocalVariable(identifier, type);
            lvalue.isAuto = isAuto;
            lvalues ~= lvalue;

            //A composite type does not need to be initialized.
            if (lvalue.type == GrType.Base.class_)
                lvalue.isInitialized = true;

            checkAdvance();
        }
        while (get().type == GrLexeme.Type.comma);

        parseAssignList(lvalues, true);
    }

    private GrType parseFunctionReturnType() {
        GrType returnType = GrType.Base.void_;
        if (get().isType) {
            switch (get().type) with (GrLexeme.Type) {
            case integerType:
                returnType = GrType(GrType.Base.int_);
                break;
            case realType:
                returnType = GrType(GrType.Base.real_);
                break;
            case booleanType:
                returnType = GrType(GrType.Base.bool_);
                break;
            case stringType:
                returnType = GrType(GrType.Base.string_);
                break;
            case arrayType:
                returnType = GrType(GrType.Base.array);
                break;
            case functionType:
                GrType type = GrType.Base.function_;
                checkAdvance();
                string[] temp;
                type.mangledType = grMangleSignature(parseInSignature(temp, true));
                returnType = type;
                break;
            case taskType:
                GrType type = GrType.Base.task;
                checkAdvance();
                string[] temp;
                type.mangledType = grMangleSignature(parseInSignature(temp, true));
                returnType = type;
                break;
            default:
                logError(format(getError(Error.xNotValidRetType), getPrettyLexemeType(get().type)),
                    format(getError(Error.xNotValidRetType), getPrettyLexemeType(get().type)));
            }
            checkAdvance();
        }

        return returnType;
    }

    /**
    ---
    if(SUBEXPR) BLOCK
    else if(SUBEXPR) BLOCK
    else unless(SUBEXPR) BLOCK
    else(SUBEXPR) BLOCK
    ---
    */
    private void parseIfStatement() {
        bool isNegative = get().type == GrLexeme.Type.unless;
        advance();
        if (isNegative && get().type == GrLexeme.Type.if_)
            advance();
        if (get().type != GrLexeme.Type.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(isNegative ? GrLexeme
                    .Type
                    .unless : GrLexeme.Type.if_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));

        advance();
        GrSubExprResult result = parseSubExpression();
        convertType(result.type, grBool, get().fileId);
        advance();

        uint jumpPosition = cast(uint) currentFunction.instructions.length;
        //Jumps to if(0) for "if", if(!= 0) for "unless".
        addInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual);

        parseBlock(true); //{ .. }

        //If(1){}, jumps out.
        uint[] exitJumps;
        if (get().type == GrLexeme.Type.else_) {
            exitJumps ~= cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.jump);
        }

        //Jumps to if(0) for "if", if(!= 0) for "unless".
        setInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual, jumpPosition,
            cast(int)(currentFunction.instructions.length - jumpPosition), true);

        bool isElseIf;
        do {
            isElseIf = false;
            if (get().type == GrLexeme.Type.else_) {
                checkAdvance();
                if (get().type == GrLexeme.Type.if_ || get().type == GrLexeme.Type.unless) {
                    isNegative = get().type == GrLexeme.Type.unless;
                    isElseIf = true;
                    checkAdvance();
                    if (isNegative && get().type == GrLexeme.Type.if_)
                        checkAdvance();
                    if (get().type != GrLexeme.Type.leftParenthesis)
                        logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(isNegative ? GrLexeme
                                .Type.unless : GrLexeme.Type.if_)),
                            format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                                GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));
                    checkAdvance();

                    parseSubExpression();
                    advance();

                    jumpPosition = cast(uint) currentFunction.instructions.length;
                    //Jumps to if(0) for "if", if(!= 0) for "unless".
                    addInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual);

                    parseBlock(true); //{ .. }

                    //If(1){}, jumps out.
                    exitJumps ~= cast(uint) currentFunction.instructions.length;
                    addInstruction(GrOpcode.jump);

                    //Jumps to if(0) for "if", if(!= 0) for "unless".
                    setInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual, jumpPosition,
                        cast(int)(currentFunction.instructions.length - jumpPosition), true);
                }
                else
                    parseBlock(true);
            }
        }
        while (isElseIf);

        foreach (uint position; exitJumps)
            setInstruction(GrOpcode.jump, position,
                cast(int)(currentFunction.instructions.length - position), true);
    }

    private GrType parseChannelBuilder() {
        GrType channelType = GrType.Base.channel;
        int channelSize = 1;

        checkAdvance();
        if (get().type != GrLexeme.Type.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexeme.Type.channelType)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));
        checkAdvance();
        GrType subType = parseType();

        GrLexeme lex = get();
        if (lex.type == GrLexeme.Type.comma) {
            checkAdvance();
            lex = get();
            if (lex.type != GrLexeme.Type.int_)
                logError(getError(Error.chanSizeMustBePositive),
                    format(getError(Error.expectedIntFoundX), getPrettyLexemeType(get().type)));
            channelSize = lex.ivalue > int.max ? 1 : cast(int) lex.ivalue;
            if (channelSize < 1)
                logError(getError(Error.chanSizeMustBeOneOrHigher),
                    format(getError(Error.expectedAtLeastSizeOf1FoundX), channelSize));
            checkAdvance();
        }
        else if (lex.type != GrLexeme.Type.rightParenthesis) {
            logError(getError(Error.missingCommaOrRightParenthesisInsideChanSignature),
                format(getError(Error.expectedCommaOrRightParenthesisFoundX), getPrettyLexemeType(get()
                    .type)));
        }
        lex = get();
        if (lex.type != GrLexeme.Type.rightParenthesis)
            logError(getError(Error.missingParenthesesAfterChanSignature),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.rightParenthesis), getPrettyLexemeType(get().type)));
        checkAdvance();
        channelType.mangledType = grMangleSignature([subType]);

        final switch (subType.base) with (GrType.Base) {
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.channel_int, channelSize);
            break;
        case real_:
            addInstruction(GrOpcode.channel_real, channelSize);
            break;
        case string_:
            addInstruction(GrOpcode.channel_string, channelSize);
            break;
        case class_:
        case array:
        case foreign:
        case channel:
        case reference:
            addInstruction(GrOpcode.channel_object, channelSize);
            break;
        case void_:
        case null_:
        case internalTuple:
            logError(format(getError(Error.chanCantBeOfTypeX), getPrettyType(grChannel(subType))),
                getError(Error.invalidChanType));
        }
        return channelType;
    }

    /**
    ---
    switch(SUBEXPR)
    case(SUBEXPR) BLOCK
    case(SUBEXPR) BLOCK
    case() BLOCK
    ---
    */
    private void parseSwitchStatement() {
        advance();
        if (get().type != GrLexeme.Type.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexeme.Type.switch_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));

        advance();
        const uint fileId = get().fileId;
        GrType switchType = parseSubExpression().type;
        GrVariable switchVar = registerSpecialVariable("switch", switchType);
        addSetInstruction(switchVar, fileId);
        advance();

        /* A switch is breakable. */
        openBreakableSection();
        uint[] exitJumps;
        uint jumpPosition, casePosition, defaultCasePosition, defaultCaseKeywordPosition;
        bool hasCase, hasDefaultCase;

        while (get().type == GrLexeme.Type.case_ || get().type == GrLexeme.Type.default_) {
            casePosition = current;
            if (get().type == GrLexeme.Type.default_) {
                advance();
                if (hasDefaultCase)
                    logError(format(getError(Error.onlyOneDefaultCasePerX), getPrettyLexemeType(GrLexeme.Type.switch_)),
                        getError(Error.defaultCaseAlreadyDef), "",
                        casePosition - current, getError(Error.prevDefaultCaseDef),
                        defaultCaseKeywordPosition);
                hasDefaultCase = true;
                defaultCasePosition = current;
                defaultCaseKeywordPosition = casePosition;
                skipBlock();
                continue;
            }
            advance();
            if (get().type != GrLexeme.Type.leftParenthesis)
                logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexeme.Type.case_)),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));
            advance();
            hasCase = true;
            addGetInstruction(switchVar);
            GrType caseType = parseSubExpression().type;
            addBinaryOperator(GrLexeme.Type.equal, switchType, caseType, fileId);
            advance();

            jumpPosition = cast(uint) currentFunction.instructions.length;
            //Jumps to if(0).
            addInstruction(GrOpcode.jumpEqual);

            parseBlock(true);

            exitJumps ~= cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.jump);

            //Jumps to if(0).
            setInstruction(GrOpcode.jumpEqual, jumpPosition,
                cast(int)(currentFunction.instructions.length - jumpPosition), true);
        }

        if (hasDefaultCase) {
            const uint tmp = current;
            current = defaultCasePosition;
            parseBlock(true);
            current = tmp;
        }

        /* A switch is breakable. */
        closeBreakableSection();

        foreach (uint position; exitJumps)
            setInstruction(GrOpcode.jump, position,
                cast(int)(currentFunction.instructions.length - position), true);
    }

    /**
    ---
    select
    case(SUBEXPR) BLOCK
    case(SUBEXPR) BLOCK
    case() BLOCK
    ---
    */
    private void parseSelectStatement() {
        advance();

        /* A select is breakable. */
        openBreakableSection();
        uint[] exitJumps;
        uint jumpPosition, casePosition, defaultCasePosition, defaultCaseKeywordPosition;
        bool hasCase, hasDefaultCase;
        uint startJump = cast(uint) currentFunction.instructions.length;

        addInstruction(GrOpcode.startSelectChannel);
        while (get().type == GrLexeme.Type.case_ || get().type == GrLexeme.Type.default_) {
            casePosition = current;
            if (get().type == GrLexeme.Type.default_) {
                advance();
                if (hasDefaultCase)
                    logError(format(getError(Error.onlyOneDefaultCasePerX), getPrettyLexemeType(GrLexeme.Type.select)),
                        getError(Error.defaultCaseAlreadyDef), "",
                        casePosition - current, getError(Error.prevDefaultCaseDef),
                        defaultCaseKeywordPosition);
                hasDefaultCase = true;
                defaultCasePosition = current;
                defaultCaseKeywordPosition = casePosition;
                skipBlock();
                continue;
            }
            advance();
            if (get().type != GrLexeme.Type.leftParenthesis)
                logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexeme.Type.case_)),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));
            advance();
            hasCase = true;
            jumpPosition = cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.tryChannel);
            parseSubExpression();
            advance();

            addInstruction(GrOpcode.checkChannel);

            parseBlock(true);

            exitJumps ~= cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.jump);

            setInstruction(GrOpcode.tryChannel, jumpPosition,
                cast(int)(currentFunction.instructions.length - jumpPosition), true);
        }

        if (hasDefaultCase) {
            /* With a default case specified, it is processed if no previous case has been processed in the select statement.
             * The select statement is not blocking here because at least one case is executed. */
            const uint tmp = current;
            current = defaultCasePosition;
            parseBlock(true);
            current = tmp;
        }
        else {
            /* Without default case, the select statement is a blocking operation until one case is processed.
             * So, we add a yield then jump back to the beggining of the statement to evaluate the select statement again. */
            addInstruction(GrOpcode.yield);
            addInstruction(GrOpcode.jump,
                cast(int)(startJump - currentFunction.instructions.length), true);
        }

        /* A switch is breakable. */
        closeBreakableSection();

        foreach (uint position; exitJumps)
            setInstruction(GrOpcode.jump, position,
                cast(int)(currentFunction.instructions.length - position), true);
        addInstruction(GrOpcode.endSelectChannel);
    }

    /**
    ---
    while(SUBEXPR)
        BLOCK
    ---
    */
    private void parseWhileStatement() {
        const bool isNegative = get().type == GrLexeme.Type.until;
        advance();
        if (get().type != GrLexeme.Type.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(isNegative ? GrLexeme
                    .Type
                    .until : GrLexeme.Type.while_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));

        /* While is breakable and continuable. */
        openBreakableSection();
        openContinuableSection();

        /* Continue jump. */
        setContinuableSectionDestination();

        uint conditionPosition, blockPosition = cast(uint) currentFunction.instructions.length;

        advance();
        parseSubExpression();

        advance();
        conditionPosition = cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.jumpEqual);

        parseBlock(true);

        addInstruction(GrOpcode.jump,
            cast(int)(blockPosition - currentFunction.instructions.length), true);
        setInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual, conditionPosition,
            cast(int)(currentFunction.instructions.length - conditionPosition), true);

        /* While is breakable and continuable. */
        closeBreakableSection();
        closeContinuableSection();
    }

    /**
    ---
    do BLOCK
    while(SUBEXPR)
    ---
    */
    private void parseDoWhileStatement() {
        advance();

        /* While is breakable and continuable. */
        openBreakableSection();
        openContinuableSection();

        uint blockPosition = cast(uint) currentFunction.instructions.length;

        parseBlock(true);

        bool isNegative;
        if (get().type == GrLexeme.Type.until)
            isNegative = true;
        else if (get().type != GrLexeme.Type.while_)
            logError(getError(Error.missingWhileOrUntilAfterLoop),
                format(getError(Error.expectedWhileOrUntilFoundX), getPrettyLexemeType(get().type)));
        advance();

        /* Continue jump. */
        setContinuableSectionDestination();

        if (get().type != GrLexeme.Type.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(isNegative ? GrLexeme
                    .Type
                    .until : GrLexeme.Type.while_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));

        advance();
        parseSubExpression();
        advance();

        addInstruction(isNegative ? GrOpcode.jumpEqual : GrOpcode.jumpNotEqual,
            cast(int)(blockPosition - currentFunction.instructions.length), true);

        /* While is breakable and continuable. */
        closeBreakableSection();
        closeContinuableSection();
    }

    private GrVariable parseDeclarableArgument() {
        GrVariable lvalue;
        GrType type = GrType.Base.void_;
        bool isAuto, isTyped = true;
        switch (get().type) with (GrLexeme.Type) {
        case autoType:
            isAuto = true;
            checkAdvance();
            break;
        case integerType: .. case channelType:
            type = parseType();
            break;
        case identifier:
            if (_data.isTypeDeclared(get().svalue, get().fileId, false))
                type = parseType();
            else
                isTyped = false;
            break;
        default:
            logError(getError(Error.varDefOrRefExpected),
                format(getError(Error.varOrRefExpectedFoundX), getPrettyLexemeType(get()
                    .type)));
            break;
        }
        GrLexeme identifier = get();
        if (identifier.type != GrLexeme.Type.identifier)
            logError(getError(Error.varNameExpected),
                format(getError(Error.varNameExpectedFoundX), getPrettyLexemeType(get().type)));

        lvalue = registerLocalVariable(identifier.svalue, type);
        lvalue.isAuto = isTyped ? isAuto : true;

        //A composite type does not need to be initialized.
        if (lvalue.type == GrType.Base.class_)
            lvalue.isInitialized = true;

        checkAdvance();
        return lvalue;
    }

    /**
    The for statement takes an iterator and a array.
    */
    private void parseForStatement() {
        advance();
        const uint fileId = get().fileId;
        if (get().type != GrLexeme.Type.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexeme.Type.for_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));

        advance();
        currentFunction.openScope();

        GrVariable variable = parseDeclarableArgument();

        if (get().type != GrLexeme.Type.comma)
            logError(format(getError(Error.missingCommaInX), getPrettyLexemeType(GrLexeme.Type.for_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(GrLexeme.Type.comma), getPrettyLexemeType(
                    get().type)));
        advance();

        //From length to 0
        GrType containerType = parseSubExpression().type;

        switch (containerType.base) with (GrType.Base) {
        case array: {
                /* Init */
                GrType subType = grUnmangle(containerType.mangledType);
                GrVariable iterator = registerSpecialVariable("it", grInt);
                GrVariable index = registerSpecialVariable("idx", grInt);
                GrVariable array = registerSpecialVariable("ary", containerType);

                if (variable.isAuto && subType.base != GrType.Base.void_) {
                    variable.isAuto = false;
                    variable.type = subType;
                    setVariableRegister(variable);
                }

                addSetInstruction(array, fileId, containerType, true);
                final switch (subType.base) with (GrType.Base) {
                case bool_:
                case int_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.length_int);
                    break;
                case real_:
                    addInstruction(GrOpcode.length_real);
                    break;
                case string_:
                    addInstruction(GrOpcode.length_string);
                    break;
                case array:
                case class_:
                case foreign:
                case channel:
                case reference:
                    addInstruction(GrOpcode.length_object);
                    break;
                case void_:
                case null_:
                case internalTuple:
                    logError(format(getError(Error.arrayCantBeOfTypeX), getPrettyType(
                            grArray(subType))),
                        getError(Error.invalidArrayType));
                    break;
                }
                addInstruction(GrOpcode.setupIterator);
                addSetInstruction(iterator, fileId);

                //Set index to -1
                addIntConstant(-1);
                addSetInstruction(index, fileId);

                /* For is breakable and continuable. */
                openBreakableSection();
                openContinuableSection();

                /* Continue jump. */
                setContinuableSectionDestination();

                advance();
                uint blockPosition = cast(uint) currentFunction.instructions.length;

                addGetInstruction(iterator, GrType(GrType.Base.int_));
                addInstruction(GrOpcode.decrement_int);
                addSetInstruction(iterator, fileId);

                addGetInstruction(iterator, GrType(GrType.Base.int_));
                uint jumpPosition = cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.jumpEqual);

                //Set Index
                addGetInstruction(array);
                addGetInstruction(index);
                addInstruction(GrOpcode.increment_int);
                addSetInstruction(index, fileId, grVoid, true);
                final switch (subType.base) with (GrType.Base) {
                case bool_:
                case int_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.index2_int);
                    break;
                case real_:
                    addInstruction(GrOpcode.index2_real);
                    break;
                case string_:
                    addInstruction(GrOpcode.index2_string);
                    break;
                case array:
                case class_:
                case foreign:
                case channel:
                case reference:
                    addInstruction(GrOpcode.index2_object);
                    break;
                case void_:
                case null_:
                case internalTuple:
                    logError(format(getError(Error.arrayCantBeOfTypeX), getPrettyType(
                            grArray(subType))),
                        getError(Error.invalidArrayType));
                    break;
                }
                convertType(subType, variable.type, fileId);
                addSetInstruction(variable, fileId);

                parseBlock(true);

                addInstruction(GrOpcode.jump,
                    cast(int)(blockPosition - currentFunction.instructions.length), true);
                setInstruction(GrOpcode.jumpEqual, jumpPosition,
                    cast(int)(currentFunction.instructions.length - jumpPosition), true);

                /* For is breakable and continuable. */
                closeBreakableSection();
                closeContinuableSection();
            }
            break;
        case foreign:
        case class_: {
                GrVariable iterator = registerSpecialVariable("it", containerType);

                GrType subType;
                auto matching = getFirstMatchingFuncOrPrim("next", [
                        containerType
                    ], fileId);
                GrFunction nextFunc = matching.func;
                GrPrimitive nextPrim = matching.prim;
                if (nextPrim) {
                    if (nextPrim.outSignature.length != 2 || (nextPrim.outSignature.length >= 1
                            && nextPrim.outSignature[0].base != grBool)) {
                        logError(format(getError(Error.primXMustRetBoolAndVal), getPrettyFunctionCall("next",
                                [containerType])),
                            getError(Error.signatureMismatch));
                    }
                    subType = nextPrim.outSignature[1];
                }
                else if (nextFunc) {
                    if (nextFunc.outSignature.length != 2 || (nextFunc.outSignature.length >= 1
                            && nextFunc.outSignature[0].base != grBool)) {
                        logError(format(getError(Error.funcXMustRetBoolAndVal), getPrettyFunction(
                                nextFunc)),
                            getError(Error.signatureMismatch));
                    }
                    subType = nextFunc.outSignature[1];
                }
                else {
                    logError(format(getError(Error.xNotDef), getPrettyFunctionCall("next",
                            [containerType])), getError(Error.notIterable));
                }

                if (variable.isAuto && subType.base != GrType.Base.void_) {
                    variable.isAuto = false;
                    variable.type = subType;
                    setVariableRegister(variable);
                }
                addSetInstruction(iterator, fileId, containerType);

                /* For is breakable and continuable. */
                openBreakableSection();
                openContinuableSection();

                /* Continue jump. */
                setContinuableSectionDestination();

                advance();
                uint blockPosition = cast(uint) currentFunction.instructions.length;

                addGetInstruction(iterator, containerType);
                if (nextPrim)
                    addInstruction(GrOpcode.primitiveCall, nextPrim.index);
                else
                    addFunctionCall(nextFunc, fileId);
                addSetInstruction(variable, fileId);

                uint jumpPosition = cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.jumpEqual);

                parseBlock(true);

                addInstruction(GrOpcode.jump,
                    cast(int)(blockPosition - currentFunction.instructions.length), true);
                setInstruction(GrOpcode.jumpEqual, jumpPosition,
                    cast(int)(currentFunction.instructions.length - jumpPosition), true);

                /* For is breakable and continuable. */
                closeBreakableSection();
                closeContinuableSection();
            }
            break;
        default:
            logError(format(getError(Error.forCantIterateOverX), getPrettyType(containerType)),
                getError(Error.notIterable));
            break;
        }
        currentFunction.closeScope();
    }

    /// Skips everything from a `(` to its matching `)`.
    private void skipParenthesis() {
        if (get().type != GrLexeme.Type.leftParenthesis)
            return;
        advance();

        __loop: while (!isEnd()) {
            switch (get().type) with (GrLexeme.Type) {
            case rightParenthesis:
                advance();
                return;
            case rightBracket:
            case rightCurlyBrace:
            case semicolon:
                break __loop;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }
    }

    /// Skips everything from a `[` to its matching `]`.
    private void skipBrackets() {
        if (get().type != GrLexeme.Type.leftBracket)
            return;
        advance();

        __loop: while (!isEnd()) {
            switch (get().type) with (GrLexeme.Type) {
            case rightBracket:
                advance();
                return;
            case rightParenthesis:
            case rightCurlyBrace:
            case semicolon:
                break __loop;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }
    }

    /// Returns the number of parameters separated by commas inside a pair of (), [] or {}.
    private int checkArity() {
        int arity;
        const int position = current;

        bool useParenthesis, useBrackets, useCurlyBraces;

        switch (get().type) with (GrLexeme.Type) {
        case leftParenthesis:
            advance();
            useParenthesis = true;
            if (get(1).type != GrLexeme.Type.rightParenthesis)
                arity++;
            break;
        case leftBracket:
            advance();
            useBrackets = true;
            if (get(1).type != GrLexeme.Type.rightBracket)
                arity++;
            break;
        case leftCurlyBrace:
            advance();
            useCurlyBraces = true;
            if (get(1).type != GrLexeme.Type.rightCurlyBrace)
                arity++;
            break;
        default:
            logError(getError(Error.cantEvalArityUnknownCompound), getError(Error.arityEvalError));
            break;
        }

        __loop: while (!isEnd()) {
            switch (get().type) with (GrLexeme.Type) {
            case comma:
                arity++;
                advance();
                break;
            case rightParenthesis:
                if (!useParenthesis)
                    goto default;
                break __loop;
            case rightBracket:
                if (!useBrackets)
                    goto default;
                break __loop;
            case rightCurlyBrace:
                if (!useCurlyBraces)
                    goto default;
                break __loop;
            case semicolon:
                break __loop;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }

        current = position;
        return arity;
    }

    /**
    There are 3 types of loop.
    - The infinite loop with no parameters:
    ---
    loop printl("I'm infinite !");
    ---
    - The finite loop, with 1 parameter:
    ---
    loop(5) printl("I'm printed 5 times !");
    ---
    - The finite loop with an iterator:
    ---
    loop(i, 5) printl("Iterator = " ~ i as string);
    ---
    */
    private void parseLoopStatement() {
        bool isInfinite, hasCustomIterator;
        GrVariable iterator, customIterator;

        const uint fileId = get().fileId;
        currentFunction.openScope();
        advance();
        if (get().type == GrLexeme.Type.leftParenthesis) {
            const int arity = checkArity();
            advance();
            if (arity == 2) {
                hasCustomIterator = true;
                customIterator = parseDeclarableArgument();
                if (customIterator.isAuto) {
                    customIterator.isAuto = false;
                    customIterator.type = grInt;
                    setVariableRegister(customIterator);
                }
                else if (customIterator.type != grInt) {
                    logError(format(getError(Error.typeOfIteratorMustBeIntNotX), getPrettyType(
                            customIterator.type)),
                        getError(Error.iteratorMustBeInt));
                }

                addIntConstant(0);
                addSetInstruction(customIterator, fileId);

                if (get().type != GrLexeme.Type.comma)
                    logError(format(getError(Error.missingCommaInX), getPrettyLexemeType(GrLexeme.Type.loop)),
                        format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                            GrLexeme.Type.comma), getPrettyLexemeType(get().type)));
                advance();
            }

            /* Init */
            iterator = registerSpecialVariable("it", GrType(GrType.Base.int_));

            //Init counter
            GrType type = parseSubExpression().type;
            advance();

            convertType(type, grInt, fileId);
            addInstruction(GrOpcode.setupIterator);
            addSetInstruction(iterator, fileId);
        }
        else
            isInfinite = true;

        /* For is breakable and continuable. */
        openBreakableSection();
        openContinuableSection();

        /* Continue jump. */
        setContinuableSectionDestination();

        uint blockPosition = cast(uint) currentFunction.instructions.length;
        uint jumpPosition;

        if (!isInfinite) {
            addGetInstruction(iterator, grInt, false);
            addInstruction(GrOpcode.decrement_int);
            addSetInstruction(iterator, fileId);

            addGetInstruction(iterator, grInt);
            jumpPosition = cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.jumpEqual);
        }

        parseBlock(true);

        if (!isInfinite && hasCustomIterator) {
            addGetInstruction(customIterator, grInt, false);
            addInstruction(GrOpcode.increment_int);
            addSetInstruction(customIterator, fileId);
        }

        addInstruction(GrOpcode.jump,
            cast(int)(blockPosition - currentFunction.instructions.length), true);
        if (!isInfinite)
            setInstruction(GrOpcode.jumpEqual, jumpPosition,
                cast(int)(currentFunction.instructions.length - jumpPosition), true);

        /* For is breakable and continuable. */
        closeBreakableSection();
        closeContinuableSection();
        currentFunction.closeScope();
    }

    /**
    The type of the return must be that of the signature of the function.
    ---
    return "Hello"; // Returns a string.
    return; // Returns nothing but still end the function.
    ---
    */
    private void parseReturnStatement() {
        checkDeferStatement();
        checkAdvance();
        if (currentFunction.isTask) {
            if (!currentFunction.instructions.length
                || currentFunction.instructions[$ - 1].opcode != GrOpcode.die)
                addDie();
        }
        else {
            auto types = parseExpressionList();

            addReturn();
            if (types.length != currentFunction.outSignature.length) {
                logError(getError(Error.expectedXRetValFoundY),
                    format(getError(currentFunction.outSignature.length > 1 ? Error.expectedXRetValsFoundY
                        : Error.expectedXRetValFoundY),
                        currentFunction.outSignature.length, types.length),
                    format(getError(Error.retSignatureOfTypeX), getPrettyFunctionCall("",
                        currentFunction.outSignature)), -1);
            }
            for (int i; i < types.length; i++) {
                if (types[i] != currentFunction.outSignature[i])
                    logError(format(getError(Error.retTypeXNotMatchSignatureY), getPrettyType(
                            types[i]), getPrettyType(
                            currentFunction.outSignature[i])),
                        format(getError(Error.expectedXVal), getPrettyType(currentFunction.outSignature[i])),
                        format(getError(Error.retSignatureOfTypeX), getPrettyFunctionCall("",
                            currentFunction.outSignature)), -1);
            }
        }
    }

    /// Add a `return` instruction that pop the callstack.
    private void addReturn() {
        if (_options & GrOption.profile) {
            addInstruction(GrOpcode.debugProfileEnd);
        }
        addInstruction(GrOpcode.return_);
    }

    /// Add a `die` instruction that stops the current task.
    private void addDie() {
        checkDeferStatement();
        if (_options & GrOption.profile) {
            addInstruction(GrOpcode.debugProfileEnd);
        }
        addInstruction(GrOpcode.die);
    }

    /// Add a `quit` instruction that stops every tasks.
    private void addQuit() {
        checkDeferStatement();
        if (_options & GrOption.profile) {
            addInstruction(GrOpcode.debugProfileEnd);
        }
        addInstruction(GrOpcode.quit);
    }

    /// The more it is, the less you need parenthesis.
    private uint getLeftOperatorPriority(GrLexeme.Type type) {
        switch (type) with (GrLexeme.Type) {
        case assign: .. case powerAssign:
            return 0;
        case arrow:
            return 1;
        case or:
            return 2;
        case and:
            return 3;
        case equal:
        case doubleEqual:
        case threeWayComparison:
        case notEqual:
        case greaterOrEqual:
        case greater:
        case lesserOrEqual:
        case lesser:
            return 4;
        case concatenate:
            return 5;
        case interval:
            return 6;
        case bitwiseOr:
        case bitwiseAnd:
        case bitwiseXor:
            return 7;
        case leftShift:
        case rightShift:
            return 8;
        case add:
        case substract:
            return 9;
        case multiply:
        case divide:
            return 10;
        case remainder:
            return 11;
        case power:
            return 12;
        case send:
            return 13;
        case not:
        case plus:
        case minus:
        case receive:
            return 14;
        case bitwiseNot:
            return 15;
        case increment:
        case decrement:
            return 16;
        default:
            logError(getError(Error.opNotListedInOpPriorityTable),
                getError(Error.unknownOpPriority));
            return 0;
        }
    }

    /// The more it is, the less you need parenthesis.
    private uint getRightOperatorPriority(GrLexeme.Type type) {
        switch (type) with (GrLexeme.Type) {
        case assign: .. case powerAssign:
            return 20;
        case arrow:
            return 1;
        case or:
            return 2;
        case and:
            return 3;
        case equal:
        case doubleEqual:
        case threeWayComparison:
        case notEqual:
        case greaterOrEqual:
        case greater:
        case lesserOrEqual:
        case lesser:
            return 4;
        case concatenate:
            return 5;
        case interval:
            return 6;
        case bitwiseOr:
        case bitwiseAnd:
        case bitwiseXor:
            return 7;
        case leftShift:
        case rightShift:
            return 8;
        case add:
        case substract:
            return 9;
        case multiply:
        case divide:
            return 10;
        case remainder:
            return 11;
        case power:
            return 12;
        case send:
            return 13;
        case not:
        case plus:
        case minus:
        case receive:
            return 14;
        case bitwiseNot:
            return 15;
        case increment:
        case decrement:
            return 16;
        default:
            logError(getError(Error.opNotListedInOpPriorityTable),
                getError(Error.unknownOpPriority));
            return 0;
        }
    }

    /// Attempt to convert `src` type to the `dst` type.
    private GrType convertType(GrType src, GrType dst, uint fileId = 0,
        bool noFail = false, bool isExplicit = false) {
        if (src.base == dst.base) {
            final switch (src.base) with (GrType.Base) {
            case function_:
                if (src.mangledType == dst.mangledType
                    && src.mangledReturnType == dst.mangledReturnType)
                    return dst;
                break;
            case task:
                if (src.mangledType == dst.mangledType)
                    return dst;
                break;
            case null_:
                break;
            case void_:
            case bool_:
            case int_:
            case real_:
            case string_:
            case enum_:
                return dst;
            case class_:
                string className = src.mangledType;
                for (;;) {
                    if (className == dst.mangledType)
                        return dst;
                    const GrClassDefinition classType = getClass(className, fileId);
                    if (!classType.parent.length)
                        break;
                    className = classType.parent;
                }
                break;
            case array:
            case channel:
            case reference:
            case internalTuple:
                if (dst.mangledType == src.mangledType)
                    return dst;
                break;
            case foreign:
                string foreignName = src.mangledType;
                for (;;) {
                    if (dst.mangledType == foreignName)
                        return dst;
                    const GrForeignDefinition foreignType = _data.getForeign(foreignName);
                    if (!foreignType.parent.length)
                        break;
                    foreignName = foreignType.parent;
                }
                break;
            }
        }

        if (src.base == GrType.Base.null_ && (dst.base == GrType.Base.class_
                || dst.base == GrType.Base.foreign))
            return dst;

        if (src.base == GrType.Base.internalTuple || dst.base == GrType.Base.internalTuple)
            logError(format(getError(Error.expectedXFoundY), getPrettyType(dst), getPrettyType(src)),
                getError(Error.mismatchedTypes), "", -1);

        if (dst.base == GrType.Base.bool_) {
            final switch (src.base) with (GrType.Base) {
            case function_:
            case task:
            case void_:
            case bool_:
            case int_:
            case real_:
            case string_:
            case internalTuple:
            case enum_:
                break;
            case array:
            case class_:
            case foreign:
            case channel:
            case reference:
            case null_:
                addInstruction(GrOpcode.isNonNull_object);
                return dst;
            }
        }

        //User-defined conversions.
        if (addCustomConversion(src, dst, isExplicit, get().fileId) == dst)
            return dst;

        if (!noFail)
            logError(format(getError(Error.expectedXFoundY), getPrettyType(dst), getPrettyType(src)),
                getError(Error.mismatchedTypes), "", -1);
        return GrType(GrType.Base.void_);
    }

    /// Convert with a primitive or function.
    private GrType addCustomConversion(GrType leftType, GrType rightType,
        bool isExplicit, uint fileId) {
        GrType resultType = GrType.Base.void_;

        //as opposed to other functions, we need the return type (rightType) to be part of the signature.
        string name = "@as";
        GrType[] signature = [leftType, rightType];

        //GrPrimitive check
        auto matching = getFirstMatchingFuncOrPrim(name, signature, fileId);
        if (matching.prim) {
            //Some implicit conversions are disabled.
            //ex: real -> int because we might lose information.
            if (matching.prim.isExplicit && !isExplicit)
                return resultType;
            addInstruction(GrOpcode.primitiveCall, matching.prim.index);
            if (matching.prim.outSignature.length != 1uL) {
                logError(getError(Error.opMustHave1RetVal),
                    format(getError(matching.prim.outSignature.length > 1 ? Error.expectedXRetValsFoundY
                        : Error.expectedXRetValFoundY), 1, matching.prim.outSignature.length));
            }
            resultType = rightType;
        }

        //GrFunction check
        if (resultType.base == GrType.Base.void_) {
            if (matching.func) {
                addFunctionCall(matching.func, fileId);
                if (matching.func.outSignature.length != 1uL) {
                    logError(getError(Error.opMustHave1RetVal),
                        format(getError(matching.func.outSignature.length > 1 ? Error.expectedXRetValsFoundY
                            : Error.expectedXRetValFoundY), 1, matching.func.outSignature.length));
                }
                resultType = rightType;
            }
        }
        return resultType;
    }

    private GrType parseObjectBuilder() {
        if (get().type != GrLexeme.Type.new_)
            logError(format(getError(Error.expectedXFoundY), getPrettyLexemeType(GrLexeme.Type.new_), getPrettyLexemeType(
                    get()
                    .type)), format(getError(Error.missingX), getPrettyLexemeType(
                    GrLexeme.Type.new_)));
        checkAdvance();
        if (get().type != GrLexeme.Type.identifier)
            logError(format(getError(Error.expectedXFoundY), getPrettyLexemeType(GrLexeme.Type.identifier), getPrettyLexemeType(
                    get()
                    .type)), getError(Error.missingIdentifier));
        uint fileId = get().fileId;
        GrType objectType = parseType(true);

        // Init
        if (get().type == GrLexeme.Type.leftCurlyBrace) {
            switch (objectType.base) with (GrType.Base) {
            case class_:
                GrClassDefinition class_ = getClass(objectType.mangledType, fileId);
                if (!class_)
                    logError(format(getError(Error.xNotDecl),
                            getPrettyType(objectType)), getError(Error.unknownClass), "", -1);
                addInstruction(GrOpcode.new_, cast(uint) class_.index);

                bool[] initFields;
                uint[] lexPositions;
                initFields.length = class_.fields.length;
                lexPositions.length = class_.fields.length;

                checkAdvance();
                while (!isEnd()) {
                    if (get().type == GrLexeme.Type.rightCurlyBrace) {
                        checkAdvance();
                        break;
                    }
                    else if (get().type == GrLexeme.Type.identifier) {
                        const string fieldName = get().svalue;
                        checkAdvance();
                        bool hasField = false;
                        for (int i; i < class_.fields.length; ++i) {
                            if (class_.fields[i] == fieldName) {
                                hasField = true;

                                if (initFields[i])
                                    logError(format(getError(Error.fieldXInitMultipleTimes), fieldName),
                                        format(getError(Error.xAlreadyInit), fieldName),
                                        "", -1, getError(Error.prevInit), lexPositions[i] - 1);

                                initFields[i] = true;
                                lexPositions[i] = current;

                                GrVariable fieldLValue = new GrVariable;
                                fieldLValue.isInitialized = false;
                                fieldLValue.isField = true;
                                fieldLValue.type = class_.signature[i];
                                fieldLValue.register = i;
                                fieldLValue.fileId = get().fileId;
                                fieldLValue.lexPosition = current;
                                addInstruction(GrOpcode.fieldLoad2, fieldLValue.register);
                                parseAssignList([fieldLValue], true);
                                break;
                            }
                        }
                        if (!hasField)
                            logError(format(getError(Error.fieldXNotExist), fieldName), getError(
                                    Error.unknownField));
                    }
                    else {
                        logError(format(getError(Error.expectedFieldNameFoundX), getPrettyLexemeType(get()
                                .type)), getError(Error.missingField));
                    }
                }

                for (int i; i < class_.fields.length; ++i) {
                    if (initFields[i])
                        continue;
                    GrVariable fieldLValue = new GrVariable;
                    fieldLValue.isInitialized = false;
                    fieldLValue.isField = true;
                    fieldLValue.type = class_.signature[i];
                    fieldLValue.register = i;
                    fieldLValue.fileId = get().fileId;
                    fieldLValue.lexPosition = current;
                    addInstruction(GrOpcode.fieldLoad2, fieldLValue.register);
                    addDefaultValue(fieldLValue.type, fileId);
                    addSetInstruction(fieldLValue, fileId, fieldLValue.type);
                }
                break;
            case foreign:
            default:
                logError(format(getError(Error.xNotClassType), getPrettyType(objectType)),
                    getError(Error.invalidType), "", -1);
                break;
            }
        }
        else {
            GrType[] signature;
            if (get().type == GrLexeme.Type.leftParenthesis) {
                advance();
                if (get().type == GrLexeme.Type.rightParenthesis) {
                    advance();
                }
                else {
                    for (;;) {
                        auto type = parseSubExpression(
                            GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                                | GR_SUBEXPR_EXPECTING_VALUE).type;
                        if (type.base == GrType.Base.internalTuple) {
                            auto types = grUnpackTuple(type);
                            if (types.length)
                                signature ~= types;
                            else
                                logError(getError(Error.exprYieldsNoVal),
                                    getError(Error.expectedValFoundNothing));
                        }
                        else
                            signature ~= type;

                        if (get().type == GrLexeme.Type.rightParenthesis) {
                            advance();
                            break;
                        }
                        advance();
                    }
                }
            }
            signature ~= objectType;

            //GrPrimitive call.
            auto matching = getFirstMatchingFuncOrPrim("@new", signature, fileId);
            if (matching.prim) {
                addInstruction(GrOpcode.primitiveCall, matching.prim.index);
                if (matching.prim.outSignature.length != 1uL || matching.prim.outSignature[0] != objectType) {
                    logError(getError(Error.opMustHave1RetVal),
                        format(getError(matching.prim.outSignature.length > 1 ? Error.expectedXRetValsFoundY
                            : Error.expectedXRetValFoundY), 1, matching
                            .prim.outSignature.length));
                }
            }
            else if (matching.func) {
                //GrFunction/Task call.
                addFunctionCall(matching.func, fileId);
                if (matching.func.outSignature.length != 1uL || matching.func.outSignature[0] != objectType) {
                    logError(getError(Error.opMustHave1RetVal),
                        format(getError(matching.func.outSignature.length > 1 ? Error.expectedXRetValsFoundY
                            : Error.expectedXRetValFoundY), 1, matching
                            .func.outSignature.length));
                }
            }
            else {
                logError(format(getError(Error.xNotDecl), getPrettyFunctionCall("@new",
                        signature)), getError(Error.unknownFunc), "", -1);
            }
        }

        return objectType;
    }

    /**
    Parse an array creation.
    The type is optional if the array is not empty.
    If no type is specified, the array subtype is set to the type of the first element.
    ---
    array(int)[1, 2, 3]
    ["1", "2", "3"]
    array(string)[]
    ---
    */
    private GrType parseArrayBuilder() {
        GrType arrayType = GrType(GrType.Base.array);
        GrType subType = grVoid;
        const uint fileId = get().fileId;
        int arraySize, defaultArraySize;

        //Explicit type like: array(int)[1, 2, 3] or default size like: array(int, 5)
        if (get().type == GrLexeme.Type.arrayType) {
            checkAdvance();
            if (get().type != GrLexeme.Type.leftParenthesis)
                logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexeme.Type.channelType)),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.leftParenthesis), getPrettyLexemeType(get().type)));
            checkAdvance();
            subType = parseType();

            GrLexeme lex = get();
            if (lex.type == GrLexeme.Type.comma) {
                checkAdvance();
                lex = get();
                if (lex.type != GrLexeme.Type.int_)
                    logError(getError(Error.arraySizeMustBePositive),
                        format(getError(Error.expectedIntFoundX), getPrettyLexemeType(get().type)));
                defaultArraySize = lex.ivalue > int.max ? 0 : cast(int) lex.ivalue;
                if (defaultArraySize < 0)
                    logError(getError(Error.arraySizeMustBeZeroOrHigher),
                        format(getError(Error.expectedAtLeastSizeOf1FoundX), defaultArraySize));
                checkAdvance();
            }
            else if (lex.type != GrLexeme.Type.rightParenthesis) {
                logError(getError(Error.missingCommaOrRightParenthesisInsideArraySignature),
                    format(getError(Error.expectedCommaOrRightParenthesisFoundX), getPrettyLexemeType(get()
                        .type)));
            }
            lex = get();
            if (lex.type != GrLexeme.Type.rightParenthesis)
                logError(getError(Error.missingParenthesesAfterArraySignature),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.rightParenthesis), getPrettyLexemeType(get().type)));
            checkAdvance();
            arrayType.mangledType = grMangleSignature([subType]);
        }

        if (get().type == GrLexeme.Type.leftBracket) {
            advance();

            while (get().type != GrLexeme.Type.rightBracket) {
                if (subType.base == GrType.Base.void_) {
                    //Implicit type specified by the type of the first element.
                    subType = parseSubExpression(
                        GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA
                            | GR_SUBEXPR_EXPECTING_VALUE).type;
                    arrayType.mangledType = grMangleSignature([subType]);
                    if (subType.base == GrType.Base.void_)
                        logError(format(getError(Error.arrayCantBeOfTypeX), getPrettyType(arrayType)),
                            getError(Error.invalidArrayType));
                }
                else {
                    convertType(parseSubExpression(
                            GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_EXPECTING_VALUE)
                            .type, subType, fileId);
                }
                arraySize++;

                if (get().type == GrLexeme.Type.rightBracket)
                    break;
                if (get().type != GrLexeme.Type.comma)
                    logError(getError(Error.indexesShouldBeSeparatedByComma),
                        format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                            GrLexeme.Type.comma), getPrettyLexemeType(get().type)));
                checkAdvance();
            }
            checkAdvance();
        }

        for (; arraySize < defaultArraySize; ++arraySize) {
            addDefaultValue(subType, fileId);
        }

        final switch (subType.base) with (GrType.Base) {
        case bool_:
        case int_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.array_int, arraySize);
            break;
        case real_:
            addInstruction(GrOpcode.array_real, arraySize);
            break;
        case string_:
            addInstruction(GrOpcode.array_string, arraySize);
            break;
        case array:
        case class_:
        case foreign:
        case channel:
        case reference:
            addInstruction(GrOpcode.array_object, arraySize);
            break;
        case void_:
        case null_:
        case internalTuple:
            logError(format(getError(Error.arrayCantBeOfTypeX), getPrettyType(grArray(subType))),
                getError(Error.invalidArrayType));
            break;
        }
        return arrayType;
    }

    private GrType parseArrayIndex(GrType arrayType) {
        const uint fileId = get().fileId;
        advance();

        for (;;) {
            if (get().type == GrLexeme.Type.comma)
                logError(getError(Error.expectedIndexFoundComma), getError(Error.missingVal));
            auto index = parseSubExpression(
                GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA
                    | GR_SUBEXPR_EXPECTING_VALUE).type;
            if (index.base == GrType.Base.void_)
                logError(getError(Error.expectedIntFoundNothing), getError(Error.missingVal));
            convertType(index, grInt, fileId);

            if (get().type == GrLexeme.Type.rightBracket) {
                switch (arrayType.base) with (GrType.Base) {
                case array:
                    const GrType subType = grUnmangle(arrayType.mangledType);
                    final switch (subType.base) with (GrType.Base) {
                    case bool_:
                    case int_:
                    case function_:
                    case task:
                    case enum_:
                        addInstruction(GrOpcode.index_int);
                        break;
                    case real_:
                        addInstruction(GrOpcode.index_real);
                        break;
                    case string_:
                        addInstruction(GrOpcode.index_string);
                        break;
                    case array:
                    case class_:
                    case foreign:
                    case channel:
                    case reference:
                        addInstruction(GrOpcode.index_object);
                        break;
                    case void_:
                    case null_:
                    case internalTuple:
                        logError(format(getError(Error.arrayCantBeOfTypeX), getPrettyType(
                                grArray(subType))),
                            getError(Error.invalidArrayType));
                        break;
                    }
                    arrayType = subType;
                    break;
                default:
                    logError(getError(Error.invalidArrayType),
                        format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                            GrLexeme.Type.arrayType),
                            getPrettyType(arrayType)));
                }
                break;
            }
            if (get().type != GrLexeme.Type.comma)
                logError(getError(Error.indexesShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.comma), getPrettyLexemeType(get().type)));
            checkAdvance();
            if (get().type == GrLexeme.Type.rightBracket)
                logError(getError(Error.indexesShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.comma), getPrettyLexemeType(get().type)));

            switch (arrayType.base) with (GrType.Base) {
            case array:
                const GrType subType = grUnmangle(arrayType.mangledType);
                final switch (subType.base) with (GrType.Base) {
                case bool_:
                case int_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.index_int);
                    break;
                case real_:
                    addInstruction(GrOpcode.index_real);
                    break;
                case string_:
                    addInstruction(GrOpcode.index_string);
                    break;
                case array:
                case class_:
                case foreign:
                case channel:
                case reference:
                    addInstruction(GrOpcode.index_object);
                    break;
                case void_:
                case null_:
                case internalTuple:
                    logError(format(getError(Error.arrayCantBeOfTypeX), getPrettyType(arrayType)),
                        getError(Error.invalidArrayType));
                    break;
                }
                arrayType = subType;
                break;
            default:
                logError(getError(Error.invalidArrayType),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.arrayType),
                        getPrettyType(arrayType)));
            }
        }
        advance();
        return arrayType;
    }

    /**
    Parse a cast, or `as` operation.
    ---
    1 as real
    ---
    */
    private GrType parseConversionOperator(GrType[] typeStack) {
        const uint fileId = get().fileId;
        if (!typeStack.length)
            logError(getError(Error.noValToConv), getError(Error.missingVal));
        advance();
        auto asType = parseType();
        convertType(typeStack[$ - 1], asType, fileId, false, true);
        typeStack[$ - 1] = asType;
        return asType;
    }

    /// Parse an assignable (named) element.
    private GrVariable parseLValue() {
        const uint fileId = get().fileId;
        if (get().type != GrLexeme.Type.identifier)
            logError(format(getError(Error.expectedVarFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingVar));

        const string identifierName = get().svalue;

        checkAdvance();

        GrVariable localLValue = currentFunction.getLocal(identifierName);
        if (localLValue !is null)
            return localLValue;

        GrVariable globalLValue = getGlobalVariable(identifierName, fileId);
        if (globalLValue !is null)
            return globalLValue;

        logError(format(getError(Error.expectedVarFoundX), getPrettyLexemeType(get()
                .type)), getError(Error.missingVar));
        return null;
    }

    /// Parse a single expression, not a statement.
    private void parseExpression() {
        bool isAssignmentList;
        const auto tempPos = current;
        __skipLoop: while (!isEnd()) {
            switch (get().type) with (GrLexeme.Type) {
            case leftBracket:
                skipBrackets();
                break;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            case semicolon:
                isAssignmentList = false;
                break __skipLoop;
            case comma:
                isAssignmentList = true;
                break __skipLoop;
            default:
                checkAdvance();
                break;
            }
        }
        current = tempPos;

        if (isAssignmentList) {
            //Get array of lvalues
            GrVariable[] lvalues;
            do {
                if (lvalues.length)
                    checkAdvance();
                //Identifier
                if (get().type != GrLexeme.Type.identifier)
                    logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                            .type)), getError(Error.missingIdentifier));
                lvalues ~= parseSubExpression(
                    GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_ASSIGN
                        | GR_SUBEXPR_EXPECTING_LVALUE).lvalue;
            }
            while (get().type == GrLexeme.Type.comma);

            parseAssignList(lvalues);
        }
        else {
            parseSubExpression(GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_MUST_CLEAN);
            checkAdvance();
        }
    }

    /// Parse the right side of a multiple assignment.
    private GrType[] parseExpressionList() {
        GrType[] expressionTypes;
        for (;;) {
            GrType type = parseSubExpression(
                GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_TERMINATE_COMMA
                    | GR_SUBEXPR_EXPECTING_VALUE).type;
            if (type.base == GrType.Base.internalTuple) {
                auto types = grUnpackTuple(type);
                if (!types.length)
                    logError(getError(Error.exprYieldsNoVal), getError(
                            Error.expectedValFoundNothing));
                else {
                    foreach (subType; types)
                        expressionTypes ~= subType;
                }
            }
            else if (type.base != GrType.Base.void_)
                expressionTypes ~= type;
            if (get().type != GrLexeme.Type.comma)
                break;
            checkAdvance();
        }
        if (get().type != GrLexeme.Type.semicolon)
            logError(getError(Error.missingSemicolonAfterExprList),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.semicolon), getPrettyLexemeType(get().type)));
        checkAdvance();
        return expressionTypes;
    }

    /// Parse the right side of a multiple assignment and associate them with the `lvalues`.
    private void parseAssignList(GrVariable[] lvalues, bool isInitialization = false) {
        const uint fileId = get().fileId;
        switch (get().type) with (GrLexeme.Type) {
        case assign:
            advance();
            GrType[] expressionTypes = parseExpressionList();

            if (expressionTypes.length > lvalues.length) {
                logError(format(getError(lvalues.length > 1 ? Error.tryingAssignXValsToYVars
                        : Error.tryingAssignXValsToYVar), expressionTypes.length, lvalues.length),
                    getError(Error.moreValThanVarToAssign), "", -1);
            }
            else if (!expressionTypes.length) {
                logError(getError(Error.assignationMissingVal), getError(Error.expressionEmpty), "", -1);
            }

            int variableIndex = to!int(lvalues.length) - 1;
            int expressionIndex = to!int(expressionTypes.length) - 1;
            bool passThrough;
            GrVariable[] skippedLvalues;
            while (variableIndex > expressionIndex) {
                addSetInstruction(lvalues[variableIndex], fileId,
                    expressionTypes[expressionIndex], true);
                variableIndex--;
                passThrough = true;
            }
            if (passThrough) {
                if (expressionTypes[expressionIndex].base == GrType.Base.void_) {
                    skippedLvalues ~= lvalues[variableIndex];
                }
                else {
                    addSetInstruction(lvalues[variableIndex], fileId,
                        lvalues[variableIndex + 1].type, false);
                }
                variableIndex--;
                expressionIndex--;
            }
            while (variableIndex >= 0) {
                if (expressionTypes[expressionIndex].base == GrType.Base.void_) {
                    skippedLvalues ~= lvalues[variableIndex];
                }
                else {
                    while (skippedLvalues.length) {
                        addSetInstruction(skippedLvalues[$ - 1], fileId,
                            expressionTypes[expressionIndex], true);
                        skippedLvalues.length--;
                    }
                    addSetInstruction(lvalues[variableIndex], fileId,
                        expressionTypes[expressionIndex], false);
                }
                variableIndex--;
                expressionIndex--;
            }
            if (skippedLvalues.length)
                logError(getError(Error.firstValOfAssignmentListCantBeEmpty), getError(
                        Error.missingVal));
            break;
        case semicolon:
            if (isInitialization) {
                foreach (lvalue; lvalues) {
                    if (lvalue.isAuto)
                        logError(getError(Error.cantInferTypeWithoutAssignment),
                            getError(Error.missingTypeInfoOrInitVal), "", -1);
                    addDefaultValue(lvalue.type, fileId);
                    addSetInstruction(lvalue, fileId, lvalue.type);
                }
            }
            advance();
            break;
        default:
            logError(getError(Error.missingSemicolonAfterAssignmentList),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexeme.Type.semicolon), getPrettyLexemeType(get().type)));
        }
    }

    private void addDefaultValue(GrType type, uint fileId) {
        final switch (type.base) with (GrType.Base) {
        case int_:
        case bool_:
        case enum_:
            addIntConstant(0);
            break;
        case real_:
            addRealConstant(0f);
            break;
        case string_:
            addStringConstant("");
            break;
        case function_:
            GrType[] inSignature = grUnmangleSignature(type.mangledType);
            GrType[] outSignature = grUnmangleSignature(type.mangledReturnType);
            string[] inputs;
            for (int i; i < inSignature.length; ++i) {
                inputs ~= to!string(i);
            }
            preBeginFunction("$anon", fileId, inSignature, inputs, false, outSignature, true);
            openDeferrableSection();
            foreach (outType; outSignature) {
                addDefaultValue(outType, fileId);
            }
            addReturn();
            closeDeferrableSection();
            registerDeferBlocks();
            endFunction();
            break;
        case task:
            GrType[] inSignature = grUnmangleSignature(type.mangledType);
            GrType[] outSignature = grUnmangleSignature(type.mangledReturnType);
            string[] inputs;
            for (int i; i < inSignature.length; ++i) {
                inputs ~= to!string(i);
            }
            preBeginFunction("$anon", fileId, inSignature, inputs, true, outSignature, true);
            openDeferrableSection();
            addDie();
            closeDeferrableSection();
            registerDeferBlocks();
            endFunction();
            break;
        case array:
            GrType[] subTypes = grUnmangleSignature(type.mangledType);
            if (subTypes.length != 1)
                logError(getError(Error.arrayCanOnlyContainOneTypeOfVal), getError(Error.conflictingArraySignature),
                    format(getError(Error.tryUsingXInstead), getPrettyType(grArray(subTypes[0]))));
            final switch (subTypes[0].base) with (GrType.Base) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(GrOpcode.array_int, 0);
                break;
            case real_:
                addInstruction(GrOpcode.array_real, 0);
                break;
            case string_:
                addInstruction(GrOpcode.array_string, 0);
                break;
            case array:
            case class_:
            case foreign:
            case channel:
            case reference:
                addInstruction(GrOpcode.array_object, 0);
                break;
            case void_:
            case null_:
            case internalTuple:
                logError(format(getError(Error.arrayCantBeOfTypeX), getPrettyType(
                        grArray(subTypes[0]))),
                    getError(Error.invalidArrayType));
                break;
            }
            break;
        case class_:
            addInstruction(GrOpcode.const_null);
            break;
        case foreign:
            addInstruction(GrOpcode.const_null);
            break;
        case channel:
            GrType[] subTypes = grUnmangleSignature(type.mangledType);
            if (subTypes.length != 1)
                logError(getError(Error.channelCanOnlyContainOneTypeOfVal), getError(Error.conflictingChannelSignature),
                    format(getError(Error.tryUsingXInstead), getPrettyType(grChannel(subTypes[0]))));
            final switch (subTypes[0].base) with (GrType.Base) {
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                addInstruction(GrOpcode.channel_int, 1);
                break;
            case real_:
                addInstruction(GrOpcode.channel_real, 1);
                break;
            case string_:
                addInstruction(GrOpcode.channel_string, 1);
                break;
            case class_:
            case array:
            case foreign:
            case channel:
            case reference:
                addInstruction(GrOpcode.channel_object, 1);
                break;
            case void_:
            case null_:
            case internalTuple:
                logError(format(getError(Error.chanCantBeOfTypeX), getPrettyType(
                        grChannel(subTypes[0]))),
                    getError(Error.invalidChanType));
            }
            break;
        case reference:
        case void_:
        case null_:
        case internalTuple:
            logError(format(getError(Error.typeXHasNoDefaultVal), getPrettyType(type)),
                getError(Error.cantInitThisType));
        }
    }

    /**
    Count the number of D types used (int, real, string and void*).
    */
    private auto countSubTypes(GrType type) {
        struct TypeCounter {
            int iCount, fCount, sCount, oCount;
        }

        TypeCounter counter;
        void countSubTypes(GrType type, ref TypeCounter counter) {
            final switch (type.base) with (GrType.Base) {
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                counter.iCount++;
                break;
            case real_:
                counter.fCount++;
                break;
            case string_:
                counter.sCount++;
                break;
            case class_:
            case array:
            case foreign:
            case channel:
            case reference:
                counter.oCount++;
                break;
            case void_:
            case null_:
                throw new Exception("the type can't be counted as a subtype");
            case internalTuple:
                auto types = grUnpackTuple(type);
                if (!types.length)
                    logError(getError(Error.exprYieldsNoVal), getError(
                            Error.expectedValFoundNothing));
                else {
                    foreach (subType; types)
                        countSubTypes(subType, counter);
                }
                break;
            }
        }

        countSubTypes(type, counter);
        return counter;
    }

    /// Add an instruction to clean up a value from the stack.
    private void shiftStackPosition(GrType type, short count) {
        const auto counter = countSubTypes(type);
        if (counter.iCount)
            addInstruction(GrOpcode.shiftStack_int, counter.iCount * count, true);
        if (counter.fCount)
            addInstruction(GrOpcode.shiftStack_real, counter.fCount * count, true);
        if (counter.sCount)
            addInstruction(GrOpcode.shiftStack_string, counter.sCount * count, true);
        if (counter.oCount)
            addInstruction(GrOpcode.shiftStack_object, counter.oCount * count, true);
    }

    /// Does this operation require a left-expr ?
    private bool requireLValue(GrLexeme.Type operatorType) {
        switch (operatorType) with (GrLexeme.Type) {
        case increment:
        case decrement:
        case assign: .. case powerAssign:
            return true;
        default:
            return false;
        }
    }

    /**
    Parse a function reference expression. \
    Converts a public function/task into an anonymous one.
    */
    private GrType parseFunctionPointer(GrType currentType) {
        const uint fileId = get().fileId;
        checkAdvance();
        if (get().type == GrLexeme.Type.leftParenthesis) {
            checkAdvance();
            GrType refType = parseType();
            if (get().type != GrLexeme.Type.rightParenthesis)
                logError(getError(Error.missingParenthesesAfterType),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.rightParenthesis), getPrettyLexemeType(get().type)));
            checkAdvance();
            if (currentType.base == GrType.Base.void_)
                currentType = refType;
            else
                currentType = convertType(refType, currentType, fileId);
        }
        if (get().type != GrLexeme.Type.identifier)
            logError(format(getError(Error.expectedFuncNameFoundX), getPrettyLexemeType(get()
                    .type)), getError(
                    Error.missingFuncName));
        if (currentType.base != GrType.Base.function_ && currentType.base != GrType
            .Base.task)
            logError(format(getError(Error.cantInferTypeOfX), get().svalue),
                getError(Error.funcTypeCantBeInferred));

        GrType funcType = addFunctionAddress(get().svalue,
            grUnmangleSignature(currentType.mangledType), get().fileId);
        convertType(funcType, currentType, fileId);
        checkAdvance();
        return currentType;
    }

    private enum {
        GR_SUBEXPR_TERMINATE_SEMICOLON = 0x1,
        GR_SUBEXPR_TERMINATE_BRACKET = 0x2,
        GR_SUBEXPR_TERMINATE_COMMA = 0x4,
        GR_SUBEXPR_TERMINATE_PARENTHESIS = 0x8,
        GR_SUBEXPR_TERMINATE_ASSIGN = 0x10,
        GR_SUBEXPR_MUST_CLEAN = 0x20,
        GR_SUBEXPR_EXPECTING_VALUE = 0x40,
        GR_SUBEXPR_EXPECTING_LVALUE = 0x80,
    }

    private struct GrSubExprResult {
        GrType type;
        GrVariable lvalue;
    }

    /**
    Evaluate a single subexpression.
    */
    private GrSubExprResult parseSubExpression(
        int flags = GR_SUBEXPR_TERMINATE_PARENTHESIS | GR_SUBEXPR_EXPECTING_VALUE) {
        const bool useSemicolon = (flags & GR_SUBEXPR_TERMINATE_SEMICOLON) > 0;
        const bool useBracket = (flags & GR_SUBEXPR_TERMINATE_BRACKET) > 0;
        const bool useComma = (flags & GR_SUBEXPR_TERMINATE_COMMA) > 0;
        const bool useParenthesis = (flags & GR_SUBEXPR_TERMINATE_PARENTHESIS) > 0;
        const bool useAssign = (flags & GR_SUBEXPR_TERMINATE_ASSIGN) > 0;
        const bool mustCleanValue = (flags & GR_SUBEXPR_MUST_CLEAN) > 0;
        const bool isExpectingValue = (flags & GR_SUBEXPR_EXPECTING_VALUE) > 0;
        const bool isExpectingLValue = (flags & GR_SUBEXPR_EXPECTING_LVALUE) > 0;

        GrVariable[] lvalues;
        GrLexeme.Type[] operatorsStack;
        GrType[] typeStack;
        GrType currentType = grVoid, lastType = grVoid;
        bool hasValue = false, hadValue = false, hasLValue = false, hadLValue = false, hasReference = false,
        hadReference = false, isRightUnaryOperator = true, isEndOfExpression = false;

        GrSubExprResult result;
        uint fileId;

        do {
            if (hasValue && currentType != lastType && lastType != grVoid) {
                lastType = currentType;
                currentType = lastType;
            }
            else
                lastType = currentType;

            isRightUnaryOperator = false;
            hadValue = hasValue;
            hasValue = false;

            hadLValue = hasLValue;
            hasLValue = false;

            hadReference = hasReference;
            hasReference = false;

            GrLexeme lex = get();
            fileId = lex.fileId;
            switch (lex.type) with (GrLexeme.Type) {
            case semicolon:
                if (useSemicolon)
                    isEndOfExpression = true;
                else
                    logError(format(getError(Error.unexpectedXFoundInExpr), getPrettyLexemeType(lex.type)),
                        format(getError(Error.xCantExistInsideThisExpr), getPrettyLexemeType(
                            lex.type)));
                break;
            case comma:
                if (useComma)
                    isEndOfExpression = true;
                else
                    logError(format(getError(Error.unexpectedXFoundInExpr), getPrettyLexemeType(lex.type)),
                        format(getError(Error.xCantExistInsideThisExpr), getPrettyLexemeType(
                            lex.type)));
                break;
            case rightParenthesis:
                if (useParenthesis)
                    isEndOfExpression = true;
                else
                    logError(format(getError(Error.unexpectedXFoundInExpr), getPrettyLexemeType(lex.type)),
                        format(getError(Error.xCantExistInsideThisExpr), getPrettyLexemeType(
                            lex.type)));
                break;
            case rightBracket:
                if (useBracket)
                    isEndOfExpression = true;
                else
                    logError(format(getError(Error.unexpectedXFoundInExpr), getPrettyLexemeType(lex.type)),
                        format(getError(Error.xCantExistInsideThisExpr), getPrettyLexemeType(
                            lex.type)));
                break;
            case leftParenthesis:
                if (hadValue) {
                    currentType = parseAnonymousCall(typeStack[$ - 1]);
                    //Unpack function value for 1 or less return values
                    //Multiples values are left as a tuple for parseExpressionList()
                    if (currentType.base == GrType.Base.internalTuple) {
                        auto types = grUnpackTuple(currentType);
                        if (!types.length)
                            currentType = grVoid;
                        else if (types.length == 1uL)
                            currentType = types[0];
                    }
                    if (currentType.base == GrType.Base.void_) {
                        typeStack.length--;
                    }
                    else {
                        hadValue = false;
                        hasValue = true;
                        typeStack[$ - 1] = currentType;
                    }
                }
                else {
                    advance();
                    currentType = parseSubExpression().type;
                    advance();
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            case doubleColon:
                advance();
                if (!hadValue)
                    logError(getError(Error.methodCallMustBePlacedAfterVal), getError(
                            Error.missingVal));
                if (get().type != GrLexeme.Type.identifier)
                    logError(format(getError(Error.expectedFuncNameFoundX), getPrettyLexemeType(get()
                            .type)), getError(
                            Error.missingFuncName));

                GrType selfType = grVoid;
                selfType = typeStack[$ - 1];
                typeStack.length--;
                hadValue = false;

                GrVariable lvalue;
                currentType = parseIdentifier(lvalue, lastType, selfType, isExpectingLValue);
                //Unpack function value for 1 or less return values
                //Multiples values are left as a tuple for parseExpressionList()
                if (currentType.base == GrType.Base.internalTuple) {
                    auto types = grUnpackTuple(currentType);
                    if (!types.length)
                        currentType = grVoid;
                    else if (types.length == 1uL)
                        currentType = types[0];
                }

                const auto nextLexeme = get();
                if (nextLexeme.type == GrLexeme.Type.leftBracket)
                    hasReference = true;
                if (currentType != GrType(GrType.Base.void_)) {
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            case arrayType:
                currentType = parseArrayBuilder();
                typeStack ~= currentType;
                hasValue = true;
                break;
            case leftBracket:
                //Index
                if (hadValue) {
                    hadValue = false;
                    currentType = parseArrayIndex(lastType);
                    hasReference = true;
                    //Check if there is an assignement or not, discard if it's only a rvalue
                    const auto nextLexeme = get();
                    if (requireLValue(nextLexeme.type) || (isExpectingLValue
                            && nextLexeme.type == GrLexeme.Type.comma)) {
                        if ((nextLexeme.type > GrLexeme.Type.assign && nextLexeme.type <= GrLexeme.Type.powerAssign)
                            || nextLexeme.type == GrLexeme.Type.increment
                            || nextLexeme.type == GrLexeme.Type.decrement) {
                            final switch (currentType.base) with (GrType.Base) {
                            case bool_:
                            case int_:
                            case function_:
                            case task:
                            case enum_:
                                setInstruction(GrOpcode.index3_int,
                                    cast(int) currentFunction.instructions.length - 1);
                                break;
                            case real_:
                                setInstruction(GrOpcode.index3_real,
                                    cast(int) currentFunction.instructions.length - 1);
                                break;
                            case string_:
                                setInstruction(GrOpcode.index3_string,
                                    cast(int) currentFunction.instructions.length - 1);
                                break;
                            case array:
                            case class_:
                            case foreign:
                            case channel:
                            case reference:
                                setInstruction(GrOpcode.index3_object,
                                    cast(int) currentFunction.instructions.length - 1);
                                break;
                            case void_:
                            case null_:
                            case internalTuple:
                                logError(format(getError(Error.arrayCantBeIndexedByX), getPrettyType(
                                        currentType)),
                                    getError(Error.invalidArrayIndexType));
                                break;
                            }
                        }
                        hasLValue = true;
                        GrVariable refVar = new GrVariable;
                        refVar.type.base = GrType.Base.reference;
                        refVar.type.mangledType = grMangleSignature([
                            currentType
                        ]);
                        lvalues ~= refVar;
                    }
                    else {
                        final switch (currentType.base) with (GrType.Base) {
                        case bool_:
                        case int_:
                        case function_:
                        case task:
                        case enum_:
                            setInstruction(GrOpcode.index2_int,
                                cast(int) currentFunction.instructions.length - 1);
                            break;
                        case real_:
                            setInstruction(GrOpcode.index2_real,
                                cast(int) currentFunction.instructions.length - 1);
                            break;
                        case string_:
                            setInstruction(GrOpcode.index2_string,
                                cast(int) currentFunction.instructions.length - 1);
                            break;
                        case array:
                        case class_:
                        case foreign:
                        case channel:
                        case reference:
                            setInstruction(GrOpcode.index2_object,
                                cast(int) currentFunction.instructions.length - 1);
                            break;
                        case void_:
                        case null_:
                        case internalTuple:
                            logError(format(getError(Error.arrayCantBeIndexedByX), getPrettyType(
                                    currentType)),
                                getError(Error.invalidArrayIndexType));
                            break;
                        }
                    }
                    lastType = currentType;
                    typeStack[$ - 1] = currentType;
                    hasValue = true;
                }
                else {
                    currentType = parseArrayBuilder();
                    typeStack ~= currentType;
                    hasValue = true;
                }
                break;
            case int_:
                currentType = GrType(GrType.Base.int_);
                addIntConstant(lex.ivalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case real_:
                currentType = GrType(GrType.Base.real_);
                addRealConstant(lex.rvalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case bool_:
                currentType = GrType(GrType.Base.bool_);
                addBoolConstant(lex.bvalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case string_:
                currentType = GrType(GrType.Base.string_);
                addStringConstant(lex.svalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case null_:
                currentType = GrType(GrType.Base.null_);
                hasValue = true;
                typeStack ~= currentType;
                addInstruction(GrOpcode.const_null);
                checkAdvance();
                break;
            case new_:
                currentType = parseObjectBuilder();
                hasValue = true;
                typeStack ~= currentType;
                break;
            case channelType:
                currentType = parseChannelBuilder();
                hasValue = true;
                typeStack ~= currentType;
                break;
            case period:
                checkAdvance();
                if (currentType.base == GrType.Base.foreign) {
                    if (get().type != GrLexeme.Type.identifier)
                        logError(format(getError(Error.expectedFieldNameFoundX), getPrettyLexemeType(get()
                                .type)), getError(Error.missingField));
                    const string propertyName = get().svalue;
                    checkAdvance();
                    GrForeignDefinition foreign = _data.getForeign(currentType.mangledType);
                    if (!foreign)
                        logError(format(getError(Error.xNotDecl),
                                getPrettyType(currentType)), getError(Error.unknownType));

                    GrType[] signature = [currentType];
                    string callbackName;
                    switch (get().type) with (GrLexeme.Type) {
                    case assign:
                        checkAdvance();
                        GrType subType = parseSubExpression(
                            GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                                | GR_SUBEXPR_EXPECTING_VALUE | GR_SUBEXPR_TERMINATE_SEMICOLON).type;
                        if (subType.base == GrType.Base.internalTuple) {
                            auto types = grUnpackTuple(subType);
                            if (types.length)
                                signature ~= types;
                            else
                                logError(getError(Error.exprYieldsNoVal),
                                    getError(Error.expectedValFoundNothing));
                        }
                        else
                            signature ~= subType;
                        if (!callbackName.length)
                            callbackName = propertyName ~ "@set";
                        break;
                    case increment:
                        checkAdvance();
                        callbackName = propertyName ~ "@inc";
                        break;
                    case decrement:
                        checkAdvance();
                        callbackName = propertyName ~ "@dec";
                        break;
                    case addAssign:
                        callbackName = propertyName ~ "@add";
                        goto case assign;
                    case substractAssign:
                        callbackName = propertyName ~ "@sub";
                        goto case assign;
                    case multiplyAssign:
                        callbackName = propertyName ~ "@mul";
                        goto case assign;
                    case divideAssign:
                        callbackName = propertyName ~ "@div";
                        goto case assign;
                    case concatenateAssign:
                        callbackName = propertyName ~ "@cat";
                        goto case assign;
                    case remainderAssign:
                        callbackName = propertyName ~ "@rem";
                        goto case assign;
                    case powerAssign:
                        callbackName = propertyName ~ "@pow";
                        goto case assign;
                    case andAssign:
                        callbackName = propertyName ~ "@and";
                        goto case assign;
                    case orAssign:
                        callbackName = propertyName ~ "@or";
                        goto case assign;
                    case bitwiseAndAssign:
                        callbackName = propertyName ~ "@bitadd";
                        goto case assign;
                    case bitwiseOrAssign:
                        callbackName = propertyName ~ "@bitor";
                        goto case assign;
                    case bitwiseXorAssign:
                        callbackName = propertyName ~ "@bitxor";
                        goto case assign;
                    default:
                        callbackName = propertyName ~ "@get";
                        break;
                    }

                    //GrPrimitive call.
                    GrType returnType;
                    auto matching = getFirstMatchingFuncOrPrim(callbackName, signature, fileId);
                    if (matching.prim) {
                        addInstruction(GrOpcode.primitiveCall, matching.prim.index);
                        returnType = grPackTuple(matching.prim.outSignature);
                    }
                    else if (matching.func) {
                        //GrFunction call.
                        returnType = grPackTuple(addFunctionCall(matching.func, fileId));
                    }
                    else {
                        logError(format(getError(Error.xNotDecl), getPrettyFunctionCall(callbackName,
                                signature)), getError(Error.unknownFunc), "", -1);
                    }
                    currentType = returnType;

                    if (hadValue)
                        typeStack[$ - 1] = currentType;
                    else
                        typeStack ~= currentType;

                    hasValue = true;
                    hadValue = false;
                    hasLValue = false;
                    hadLValue = false;
                }
                else if (currentType.base == GrType.Base.class_) {
                    if (get().type != GrLexeme.Type.identifier)
                        logError(format(getError(Error.expectedFieldNameFoundX), getPrettyLexemeType(get()
                                .type)), getError(Error.missingField));
                    const string identifier = get().svalue;
                    checkAdvance();
                    GrClassDefinition class_ = getClass(currentType.mangledType, get().fileId);
                    if (!class_)
                        logError(format(getError(Error.xNotDecl),
                                getPrettyType(currentType)), getError(Error.unknownType));
                    const auto nbFields = class_.signature.length;
                    bool hasField;
                    for (int i; i < nbFields; i++) {
                        if (identifier == class_.fields[i]) {
                            if ((class_.fieldsInfo[i].fileId != fileId)
                                && !class_.fieldsInfo[i].isPublic)
                                logError(format(getError(Error.xOnTypeYIsPrivate), identifier, getPrettyType(
                                        currentType)),
                                    getError(Error.privateField), "", -1);
                            hasField = true;
                            currentType = class_.signature[i];
                            currentType.isField = true;
                            GrVariable fieldLValue = new GrVariable;
                            fieldLValue.isInitialized = true;
                            fieldLValue.isField = true;
                            fieldLValue.type = currentType;
                            fieldLValue.register = i;
                            fieldLValue.fileId = get().fileId;
                            fieldLValue.lexPosition = current;

                            if (requireLValue(get().type)) {
                                if (hadLValue)
                                    lvalues[$ - 1] = fieldLValue;
                                else
                                    lvalues ~= fieldLValue;
                            }

                            if (hadValue)
                                typeStack[$ - 1] = currentType;
                            else
                                typeStack ~= currentType;

                            hasValue = true;
                            hadValue = false;
                            hasLValue = true;
                            hadLValue = false;

                            switch (get().type) with (GrLexeme.Type) {
                            case period:
                                addInstruction(GrOpcode.fieldLoad_object, fieldLValue.register);
                                break;
                            case assign:
                                addInstruction(GrOpcode.fieldLoad, fieldLValue.register);
                                break;
                            case increment:
                            case decrement:
                            case bitwiseAndAssign: .. case powerAssign:
                                addLoadFieldInstruction(currentType, fieldLValue.register, true);
                                break;
                            case leftParenthesis:
                                lvalues.length--;
                                addLoadFieldInstruction(currentType, fieldLValue.register, false);
                                currentType = parseAnonymousCall(typeStack[$ - 1]);
                                //Unpack function value for 1 or less return values
                                //Multiples values are left as a tuple for parseExpressionList()
                                if (currentType.base == GrType.Base.internalTuple) {
                                    auto types = grUnpackTuple(currentType);
                                    if (!types.length)
                                        currentType = grVoid;
                                    else if (types.length == 1uL)
                                        currentType = types[0];
                                }
                                if (currentType.base == GrType.Base.void_) {
                                    typeStack.length--;
                                }
                                else {
                                    hadValue = false;
                                    hasValue = true;
                                    typeStack[$ - 1] = currentType;
                                }
                                break;
                            case comma:
                                if (isExpectingLValue)
                                    goto case assign;
                                goto default;
                            default:
                                addLoadFieldInstruction(currentType, fieldLValue.register, false);
                                break;
                            }
                            break;
                        }
                    }
                    if (!hasField) {
                        const string[] nearestValues = findNearestStrings(identifier, class_.fields);
                        string errorNote;
                        if (nearestValues.length) {
                            foreach (size_t i, const string value; nearestValues) {
                                errorNote ~= "`" ~ value ~ "`";
                                if ((i + 1) < nearestValues.length)
                                    errorNote ~= ", ";
                            }
                            errorNote ~= ".";
                        }
                        logError(format(getError(Error.noFieldXOnTypeY), identifier, getPrettyType(currentType)),
                            getError(Error.unknownField), format(getError(Error.availableFieldsAreX), errorNote), -1);
                    }
                }
                else {
                    logError(format(getError(Error.cantAccessFieldOnTypeX), getPrettyType(currentType)),
                        format(getError(Error.expectedClassFoundX), getPrettyType(currentType)));
                }
                break;
            case colon:
                const size_t methodCallPos = current;
                if (!hadValue)
                    logError(getError(Error.missingParamOnMethodCall),
                        getError(Error.methodCallMustBePlacedAfterVal));
                checkAdvance();
                GrType selfType = currentType;
                if (get().type != GrLexeme.Type.identifier)
                    logError(format(getError(Error.expectedFuncNameFoundX), getPrettyLexemeType(get()
                            .type)), getError(
                            Error.missingFuncName));
                const string identifier = get().svalue;
                checkAdvance();
                bool hasField;

                if (currentType.base == GrType.Base.class_) {
                    GrClassDefinition class_ = getClass(currentType.mangledType, get().fileId);
                    if (!class_)
                        logError(format(getError(Error.xNotDecl),
                                getPrettyType(currentType)), getError(Error.unknownClass), "", -1);
                    const auto nbFields = class_.signature.length;
                    for (int i; i < nbFields; i++) {
                        if (identifier == class_.fields[i]) {
                            if ((class_.fieldsInfo[i].fileId != fileId)
                                && !class_.fieldsInfo[i].isPublic) {
                                logError(format(getError(Error.xOnTypeYIsPrivate), identifier, getPrettyType(
                                        currentType)), getError(Error.privateField), "", -1);
                            }
                            hasField = true;
                            currentType = class_.signature[i];
                            currentType.isField = true;
                            GrVariable fieldLValue = new GrVariable;
                            fieldLValue.isInitialized = true;
                            fieldLValue.isField = true;
                            fieldLValue.type = currentType;
                            fieldLValue.register = i;
                            fieldLValue.fileId = get().fileId;
                            fieldLValue.lexPosition = current;

                            if (hadLValue)
                                lvalues.length--;

                            if (hadValue)
                                typeStack[$ - 1] = currentType;
                            else
                                typeStack ~= currentType;

                            hasValue = true;
                            hadValue = false;
                            hasLValue = true;
                            hadLValue = false;

                            addInstruction(GrOpcode.copy_object);
                            addLoadFieldInstruction(currentType, fieldLValue.register, false);
                            currentType = parseAnonymousCall(typeStack[$ - 1], selfType);
                            //Unpack function value for 1 or less return values
                            //Multiples values are left as a tuple for parseExpressionList()
                            if (currentType.base == GrType.Base.internalTuple) {
                                auto types = grUnpackTuple(currentType);
                                if (!types.length)
                                    currentType = grVoid;
                                else if (types.length == 1uL)
                                    currentType = types[0];
                            }
                            if (currentType.base == GrType.Base.void_) {
                                typeStack.length--;
                            }
                            else {
                                hadValue = false;
                                hasValue = true;
                                typeStack[$ - 1] = currentType;
                            }
                            break;
                        }
                    }
                }
                if (!hasField) {
                    current = methodCallPos;
                    goto case doubleColon;
                }
                break;
            case pointer:
                currentType = parseFunctionPointer(currentType);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case as:
                if (!hadValue)
                    logError(format(getError(Error.xMustBePlacedAfterVal), getPrettyLexemeType(
                            GrLexeme.Type.as)), getError(Error.missingVal));
                currentType = parseConversionOperator(typeStack);
                hasValue = true;
                hadValue = false;
                break;
            case self:
                // Parse a function call that refers to its parent. 
                checkAdvance();
                currentType = addFunctionAddress(currentFunction, get().fileId);
                if (currentType.base == GrType.Base.void_)
                    logError(format(getError(Error.xMustBeInsideFuncOrTask), getPrettyLexemeType(GrLexeme.Type.self)),
                        format(getError(Error.xRefNoFuncNorTask), getPrettyLexemeType(
                            GrLexeme.Type.self)), "", -1);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case functionType:
                currentType = parseAnonymousFunction(false);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case taskType:
                currentType = parseAnonymousFunction(true);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case assign:
                if (useAssign) {
                    isEndOfExpression = true;
                    break;
                }
                goto case bitwiseAndAssign;
            case bitwiseAndAssign: .. case powerAssign:
                if (!hadLValue)
                    logError(getError(Error.valBeforeAssignationNotReferenceable),
                        getError(Error.missingRefBeforeAssignation));
                hadLValue = false;
                goto case multiply;
            case add:
                if (!hadValue)
                    lex.type = GrLexeme.Type.plus;
                goto case multiply;
            case concatenate:
                if (!hadValue)
                    lex.type = GrLexeme.Type.bitwiseNot;
                goto case multiply;
            case substract:
                if (!hadValue)
                    lex.type = GrLexeme.Type.minus;
                goto case multiply;
            case send:
                if (!hadValue)
                    lex.type = GrLexeme.Type.receive;
                goto case multiply;
            case increment: .. case decrement:
                isRightUnaryOperator = true;
                goto case multiply;
            case and:
            case or:
            case multiply:
            case divide:
            case remainder: .. case not:
                if (isExpectingLValue)
                    logError(getError(
                            Error.cantDoThisKindOfOpOnLeftSideOfAssignement), getError(
                            Error.unexpectedOp)
                    );
                if (!hadValue && !isUnaryOperator(lex.type))
                    logError(getError(Error.binOpMustHave2Operands), getError(Error.missingVal));

                while (operatorsStack.length
                    && getLeftOperatorPriority(operatorsStack[$ - 1]) > getRightOperatorPriority(
                        lex.type)) {
                    GrLexeme.Type operator = operatorsStack[$ - 1];

                    switch (operator) with (GrLexeme.Type) {
                    case assign:
                        addSetInstruction(lvalues[$ - 1], fileId, currentType, true);
                        lvalues.length--;
                        break;
                    case bitwiseAndAssign: .. case powerAssign:
                        currentType = addOperator(operator - (GrLexeme.Type.bitwiseAndAssign - GrLexeme.Type.bitwiseAnd),
                            typeStack, fileId);
                        addSetInstruction(lvalues[$ - 1], fileId, currentType, true);
                        lvalues.length--;
                        break;
                    case increment: .. case decrement:
                        currentType = addOperator(operator, typeStack, fileId);
                        addSetInstruction(lvalues[$ - 1], fileId, currentType, true);
                        lvalues.length--;
                        break;
                    default:
                        currentType = addOperator(operator, typeStack, fileId);
                        break;
                    }

                    operatorsStack.length--;
                }

                operatorsStack ~= lex.type;
                if (hadValue && isRightUnaryOperator) {
                    hasValue = true;
                    hadValue = false;
                }
                else
                    hasValue = false;
                checkAdvance();
                break;
            case identifier:
                GrVariable lvalue;
                currentType = parseIdentifier(lvalue, lastType, grVoid, isExpectingLValue);
                //Unpack function value for 1 or less return values
                //Multiples values are left as a tuple for parseExpressionList()
                if (currentType.base == GrType.Base.internalTuple) {
                    auto types = grUnpackTuple(currentType);
                    if (!types.length)
                        currentType = grVoid;
                    else if (types.length == 1uL)
                        currentType = types[0];
                }

                //Check if there is an assignement or not, discard if it's only a rvalue
                const auto nextLexeme = get();
                if (lvalue !is null && (requireLValue(nextLexeme.type)
                        || (isExpectingLValue && nextLexeme.type == GrLexeme.Type.comma))) {
                    hasLValue = true;
                    lvalues ~= lvalue;

                    if (lvalue.isAuto)
                        hasValue = true;
                }

                if (!hasLValue && nextLexeme.type == GrLexeme.Type.leftBracket)
                    hasReference = true;

                if (currentType != GrType(GrType.Base.void_)) {
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            default:
                logError(format(getError(Error.unexpectedXSymbolInExpr), getPrettyLexemeType(
                        lex.type)),
                    getError(Error.unexpectedSymbol));
            }

            if (hasValue && hadValue)
                logError(getError(Error.missingSemicolonAtEndOfExpr),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexeme.Type.semicolon), getPrettyLexemeType(get().type)));
        }
        while (!isEndOfExpression);

        if (operatorsStack.length) {
            if (!hadValue) {
                logError(getError(Error.binOpMustHave2Operands), getError(Error.missingVal));
            }
        }

        while (operatorsStack.length) {
            GrLexeme.Type operator = operatorsStack[$ - 1];

            switch (operator) with (GrLexeme.Type) {
            case assign:
                addSetInstruction(lvalues[$ - 1], fileId, currentType,
                    isExpectingValue || operatorsStack.length > 1uL);
                lvalues.length--;

                if (operatorsStack.length <= 1uL)
                    hadValue = false;
                break;
            case bitwiseAndAssign: .. case powerAssign:
                currentType = addOperator(
                    operator - (GrLexeme.Type.bitwiseAndAssign - GrLexeme.Type.bitwiseAnd),
                    typeStack, fileId);
                addSetInstruction(lvalues[$ - 1], fileId, currentType,
                    isExpectingValue || operatorsStack.length > 1uL);
                lvalues.length--;

                if (operatorsStack.length <= 1uL)
                    hadValue = false;
                break;
            case increment: .. case decrement:
                currentType = addOperator(operator, typeStack, fileId);
                addSetInstruction(lvalues[$ - 1], fileId, currentType,
                    isExpectingValue || operatorsStack.length > 1uL);
                lvalues.length--;

                if (operatorsStack.length <= 1uL)
                    hadValue = false;
                break;
            default:
                currentType = addOperator(operator, typeStack, fileId);
                break;
            }

            operatorsStack.length--;
        }

        if (isExpectingLValue) {
            if (!hadLValue)
                logError(getError(Error.valBeforeAssignationNotReferenceable),
                    getError(Error.missingRefBeforeAssignation));
            result.lvalue = lvalues[$ - 1];
        }

        if (mustCleanValue && hadValue && currentType.base != GrType.Base.void_)
            shiftStackPosition(currentType, -1);

        result.type = currentType;
        return result;
    }

    private void addLoadFieldInstruction(GrType type, uint index, bool asCopy) {
        final switch (type.base) with (GrType.Base) {
        case bool_:
        case int_:
        case function_:
        case task:
        case enum_:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_int : GrOpcode.fieldLoad_int, index);
            break;
        case real_:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_real : GrOpcode.fieldLoad_real, index);
            break;
        case string_:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_string : GrOpcode.fieldLoad_string, index);
            break;
        case reference:
        case channel:
        case class_:
        case array:
        case foreign:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_object : GrOpcode.fieldLoad_object, index);
            break;
        case internalTuple:
        case null_:
        case void_:
            logError(format(getError(Error.cantLoadFieldOfTypeX), getPrettyType(type)),
                getError(Error.fieldTypeIsInvalid));
            break;
        }
    }

    /// Parse a function call from a runtime value.
    private GrType parseAnonymousCall(GrType type, GrType selfType = grVoid) {
        const uint fileId = get().fileId;

        GrVariable functionId;
        if (type.base == GrType.Base.function_) {
            functionId = registerSpecialVariable("anon", GrType(GrType.Base.int_));
            addSetInstruction(functionId, fileId, GrType(GrType.Base.int_));
        }
        else if (type.base != GrType.Base.task) {
            logError(format(getError(Error.xNotCallable), getPrettyType(type)),
                format(getError(Error.xNotFuncNorTask), getPrettyType(type)));
        }

        //Signature parsing with type conversion
        GrType[] signature;
        GrType[] anonSignature = grUnmangleSignature(type.mangledType);
        int i;
        if (selfType != grVoid) {
            signature ~= convertType(selfType, anonSignature[i], fileId);
            i++;
        }
        if (get().type == GrLexeme.Type.leftParenthesis) {
            checkAdvance();
            if (get().type != GrLexeme.Type.rightParenthesis) {
                for (;;) {
                    if (i >= anonSignature.length) {
                        logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButMoreWereSupplied : Error.funcTakesXArgButMoreWereSupplied), anonSignature
                                .length),
                            format(getError(anonSignature.length > 1 ? Error.expectedXArg : Error.expectedXArgs), anonSignature
                                .length),
                            format(getError(Error.funcIsOfTypeX), getPrettyType(type)));
                    }
                    GrType subType = parseSubExpression(
                        GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                            | GR_SUBEXPR_EXPECTING_VALUE).type;
                    if (subType.base == GrType.Base.internalTuple) {
                        auto types = grUnpackTuple(subType);
                        if (types.length) {
                            for (int y; y < types.length; y++, i++) {
                                if (i >= anonSignature.length) {
                                    logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButMoreWereSupplied
                                            : Error.funcTakesXArgButMoreWereSupplied), anonSignature
                                            .length),
                                        format(getError(anonSignature.length > 1 ? Error.expectedXArg : Error.expectedXArgs), anonSignature
                                            .length),
                                        format(getError(Error.funcIsOfTypeX), getPrettyType(type)));
                                }
                                signature ~= convertType(types[y], anonSignature[i], fileId);
                            }
                        }
                        else
                            logError(getError(Error.exprYieldsNoVal),
                                getError(Error.expectedValFoundNothing));
                    }
                    else {
                        signature ~= convertType(subType, anonSignature[i], fileId);
                        i++;
                    }
                    if (get().type == GrLexeme.Type.rightParenthesis) {
                        checkAdvance();
                        break;
                    }
                    advance();
                }
            }
            else {
                checkAdvance();
            }
        }
        if (signature.length != anonSignature.length) {
            logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButYWereSupplied
                    : Error.funcTakesXArgButYWereSupplied), anonSignature.length, signature.length),
                format(getError(anonSignature.length > 1 ? Error.expectedXArgsFoundY
                    : Error.expectedXArgFoundY), anonSignature.length, signature.length),
                format(getError(Error.funcIsOfTypeX), getPrettyType(type)));
        }

        //Push the values on the global stack for task spawning.
        if (type.base == GrType.Base.task)
            addGlobalPush(signature);

        //Anonymous call.
        GrType retTypes = grPackTuple(grUnmangleSignature(type.mangledReturnType));

        if (type.base == GrType.Base.function_) {
            addGetInstruction(functionId, GrType(GrType.Base.int_));
        }

        if (type.base == GrType.Base.function_)
            addInstruction(GrOpcode.anonymousCall, 0u);
        else
            addInstruction(GrOpcode.anonymousTask, 0u);
        return retTypes;
    }

    /// Parse an identifier or function call and return the deduced return type and lvalue.
    private GrType parseIdentifier(ref GrVariable variable, GrType expectedType,
        GrType selfType = grVoid, bool isAssignment = false) {
        GrType returnType = GrType.Base.void_;
        const GrLexeme identifier = get();
        bool isFunctionCall = false, isMethodCall = false, hasParenthesis = false;
        string identifierName = identifier.svalue;
        const uint fileId = identifier.fileId;

        advance();

        if (selfType.base != GrType.Base.void_) {
            isMethodCall = true;
            isFunctionCall = true;
        }

        if (get().type == GrLexeme.Type.leftParenthesis) {
            isFunctionCall = true;
            hasParenthesis = true;
        }

        if (isFunctionCall) {
            GrType[] signature;

            if (hasParenthesis)
                advance();

            GrVariable var = currentFunction.getLocal(identifierName);
            if (!var)
                var = getGlobalVariable(identifierName, fileId);
            if (var) {
                if (var.type.base != GrType.Base.function_ && var.type.base
                    != GrType.Base.task)
                    logError(format(getError(Error.xNotCallable), identifierName),
                        format(getError(Error.funcOrTaskExpectedFoundX), getPrettyType(var.type)),
                        "", -1);
                //Signature parsing with type conversion
                GrType[] anonSignature = grUnmangleSignature(var.type.mangledType);
                int i;
                if (isMethodCall) {
                    if (!anonSignature.length)
                        logError(getError(Error.missingParamOnMethodCall),
                            getError(Error.methodCallMustBePlacedAfterVal));
                    signature ~= convertType(selfType, anonSignature[i], fileId);
                    i++;
                }
                if (hasParenthesis && get().type != GrLexeme.Type.rightParenthesis) {
                    for (;;) {
                        if (i >= anonSignature.length) {
                            logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButMoreWereSupplied : Error.funcTakesXArgButMoreWereSupplied), anonSignature
                                    .length),
                                format(getError(anonSignature.length > 1 ? Error.expectedXArgs : Error.expectedXArg), anonSignature
                                    .length),
                                format(getError(Error.funcIsOfTypeX), getPrettyType(var.type)),
                                0, getError(Error.funcDefHere), var.lexPosition);
                        }
                        GrType subType = parseSubExpression(
                            GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                                | GR_SUBEXPR_EXPECTING_VALUE).type;
                        if (subType.base == GrType.Base.internalTuple) {
                            auto types = grUnpackTuple(subType);
                            if (types.length) {
                                for (int y; y < types.length; y++, i++) {
                                    if (i >= anonSignature.length) {
                                        logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButMoreWereSupplied
                                                : Error.funcTakesXArgButMoreWereSupplied), anonSignature
                                                .length),
                                            format(getError(anonSignature.length > 1 ? Error.expectedXArgs : Error.expectedXArg), anonSignature
                                                .length),
                                            format(getError(Error.funcIsOfTypeX), getPrettyType(var.type)),
                                            0, getError(Error.funcDefHere), var.lexPosition);
                                    }
                                    signature ~= convertType(types[y], anonSignature[i], fileId);
                                }
                            }
                            else
                                logError(getError(Error.exprYieldsNoVal),
                                    getError(Error.expectedValFoundNothing));
                        }
                        else {
                            signature ~= convertType(subType, anonSignature[i], fileId);
                            i++;
                        }
                        if (get().type == GrLexeme.Type.rightParenthesis) {
                            if (signature.length != anonSignature.length) {
                                logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButYWereSupplied : Error.funcTakesXArgButYWereSupplied), anonSignature
                                        .length, signature.length),
                                    format(getError(anonSignature.length > 1 ? Error.expectedXArgsFoundY : Error.expectedXArgFoundY), anonSignature
                                        .length, signature.length),
                                    format(getError(Error.funcIsOfTypeX), getPrettyType(var.type)));
                            }
                            break;
                        }
                        advance();
                    }
                    if (hasParenthesis && get().type == GrLexeme.Type.rightParenthesis)
                        advance();
                }
                else {
                    if (hasParenthesis && get().type == GrLexeme.Type.rightParenthesis)
                        advance();
                    if (signature.length != anonSignature.length) {
                        logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButYWereSupplied : Error.funcTakesXArgButYWereSupplied), anonSignature
                                .length, signature.length),
                            format(getError(anonSignature.length > 1 ? Error.expectedXArgsFoundY : Error.expectedXArgFoundY), anonSignature
                                .length, signature.length),
                            format(getError(Error.funcIsOfTypeX), getPrettyType(var.type)));
                    }
                }

                //Push the values on the global stack for task spawning.
                if (var.type.base == GrType.Base.task)
                    addGlobalPush(signature);

                //Anonymous call.
                //bool hasAnonFunc = false;
                addGetInstruction(var);

                returnType = grPackTuple(grUnmangleSignature(var.type.mangledReturnType));

                if (var.type.base == GrType.Base.function_)
                    addInstruction(GrOpcode.anonymousCall, 0u);
                else if (var.type.base == GrType.Base.task)
                    addInstruction(GrOpcode.anonymousTask, 0u);
            }
            else {
                if (isMethodCall) {
                    if (selfType.base == GrType.Base.internalTuple)
                        signature ~= grUnpackTuple(selfType);
                    else
                        signature ~= selfType;
                }
                //Signature parsing, no coercion is made
                if (hasParenthesis && get().type != GrLexeme.Type.rightParenthesis) {
                    for (;;) {
                        auto type = parseSubExpression(
                            GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                                | GR_SUBEXPR_EXPECTING_VALUE).type;
                        if (type.base == GrType.Base.internalTuple) {
                            auto types = grUnpackTuple(type);
                            if (types.length)
                                signature ~= types;
                            else
                                logError(getError(Error.exprYieldsNoVal),
                                    getError(Error.expectedValFoundNothing));
                        }
                        else
                            signature ~= type;

                        if (get().type == GrLexeme.Type.rightParenthesis)
                            break;
                        advance();
                    }
                }
                if (hasParenthesis && get().type == GrLexeme.Type.rightParenthesis)
                    advance();

                //GrPrimitive call.
                auto matching = getFirstMatchingFuncOrPrim(identifierName, signature, fileId);
                if (matching.prim) {
                    addInstruction(GrOpcode.primitiveCall, matching.prim.index);
                    returnType = grPackTuple(matching.prim.outSignature);
                }
                else if (matching.func) {
                    //GrFunction/Task call.
                    returnType = grPackTuple(addFunctionCall(matching.func, fileId));
                }
                else {
                    logError(format(getError(Error.xNotDecl), getPrettyFunctionCall(identifierName,
                            signature)), getError(Error.unknownFunc), "", -1);
                }
            }
        }
        else if (_data.isEnum(identifier.svalue, fileId, false)) {
            const GrEnumDefinition definition = _data.getEnum(identifier.svalue, fileId);
            if (get().type != GrLexeme.Type.period)
                logError(getError(Error.expectedDotAfterEnumType), getError(
                        Error.missingEnumConstantName));
            checkAdvance();
            if (get().type != GrLexeme.Type.identifier)
                logError(getError(Error.expectedConstNameAfterEnumType),
                    getError(Error.missingEnumConstantName));
            const string fieldName = get().svalue;
            if (!definition.hasField(fieldName)) {
                const string[] nearestValues = findNearestStrings(fieldName, definition.fields);
                string errorNote;
                if (nearestValues.length) {
                    foreach (size_t i, const string value; nearestValues) {
                        errorNote ~= "`" ~ value ~ "`";
                        if ((i + 1) < nearestValues.length)
                            errorNote ~= ", ";
                    }
                    errorNote ~= ".";
                }
                logError(format(getError(Error.noFieldXOnTypeY), fieldName, definition.name),
                    getError(Error.unknownField), format(getError(Error.availableFieldsAreX), errorNote));
            }
            checkAdvance();

            returnType = GrType(GrType.Base.enum_);
            returnType.mangledType = definition.name;
            addIntConstant(definition.getField(fieldName));
        }
        else {
            //Declared variable.
            variable = getVariable(identifierName, fileId);
            returnType = variable.type;
            //If it's an assignement, we want the GET instruction to be after the assignement, not there.
            const auto nextLexeme = get();
            if (!(nextLexeme.type == GrLexeme.Type.assign || (isAssignment
                    && nextLexeme.type == GrLexeme.Type.comma)))
                addGetInstruction(variable, expectedType);
        }
        return returnType;
    }

    private string getPrettyFunctionCall(string name, GrType[] signature) {
        return grGetPrettyFunctionCall(name, signature);
    }

    private string getPrettyFunction(GrFunction func) {
        return grGetPrettyFunction(func);
    }

    private string getPrettyType(GrType type) {
        return grGetPrettyType(type);
    }

    private string getPrettyLexemeType(GrLexeme.Type type) {
        return grGetPrettyLexemeType(type);
    }

    /// Check and raise an error.
    private void assertError(bool assertion, string message, string info,
        string note = "", int offset = 0) {
        if (assertion)
            return;
        logError(message, info, note, offset);
    }

    /// Log an error and throw an exception.
    private void logError(string message, string info, string note = "",
        int offset = 0, string otherInfo = "", uint otherPos = 0) {
        GrError error = new GrError;
        error.type = GrError.Type.parser;
        error.message = message;
        error.info = info;
        error.note = note;

        GrLexeme lex = (isEnd() && offset >= 0) ? get(-1) : get(offset);
        error.filePath = lex.getFile();
        error.lineText = lex.getLine().replace("\t", " ");
        error.line = lex.line + 1u; // By convention, the first line is 1, not 0.
        error.column = lex.column;
        error.textLength = lex.textLength;

        if (otherInfo.length) {
            error.otherInfo = otherInfo;

            set(otherPos);

            GrLexeme otherLex = isEnd() ? get(-1) : get();
            error.otherFilePath = otherLex.getFile();
            error.otherLineText = otherLex.getLine().replace("\t", " ");
            error.otherLine = otherLex.line + 1u; // By convention, the first line is 1, not 0.
            error.otherColumn = otherLex.column;
            error.otherTextLength = otherLex.textLength;
        }

        throw new GrParserException(error);
    }

    private enum Error {
        eofReached,
        eof,
        nameXDefMultipleTimes,
        xRedefHere,
        prevDefOfX,
        prevDefPrim,
        alreadyDef,
        cantDefVarOfTypeX,
        invalidType,
        xNotDef,
        unknownFunc,
        cantUseTypeAsParam,
        invalidParamType,
        xNotDecl,
        unknownVar,
        opMustHave1RetVal,
        expected1RetValFoundX,
        expected1RetValFoundXs,
        cantUseOpOnMultipleVal,
        exprYieldsMultipleVal,
        noXUnaryOpDefForY,
        noXBinaryOpDefForYAndZ,
        unknownOp,
        xIsConstAndCantBeModified,
        cantModifyAConstX,
        cantAssignToAXVar,
        ValNotAssignable,
        cantInferTypeOfVar,
        varNotInit,
        cantGetValueOfX,
        valNotFetchable,
        unknownClass,
        unknownType,
        locVarUsedNotAssigned,
        globalDeclExpected,
        globalDeclExpectedFoundX,
        funcMissingRetAtEnd,
        missingRet,
        expectedTypeAliasNameFoundX,
        expectedEnumNameFoundX,
        expectedXFoundY,
        missingIdentifier,
        missingAssignInType,
        missingSemicolonAfterType,
        enumDefNotHaveBody,
        expectedEnumFieldFoundX,
        missingSemicolonAfterEnumField,
        xAlreadyDecl,
        expectedClassNameFoundX,
        parentClassNameMissing,
        classHaveNoBody,
        missingSemicolonAfterClassFieldDecl,
        xCantInheritFromY,
        xIncludedRecursively,
        recursiveInheritence,
        fieldXDeclMultipleTimes,
        recursiveDecl,
        xNotValidType,
        expectedValidTypeFoundX,
        arrayCanOnlyContainOneTypeOfVal,
        conflictingArraySignature,
        tryUsingXInstead,
        channelCanOnlyContainOneTypeOfVal,
        conflictingChannelSignature,
        missingTemplateVal,
        templateValShouldBeSeparatedByComma,
        templateTypesShouldBeSeparatedByComma,
        missingParentheses,
        paramShouldBeSeparatedByComma,
        expectedIdentifierFoundX,
        typesShouldBeSeparatedByComma,
        addingPubBeforeEventIsRedundant,
        eventAlreadyPublic,
        cantOverrideXOp,
        opCantBeOverriden,
        missingConstraint,
        xIsNotAKnownConstraint,
        validConstraintsAreX,
        expectedColonAfterType,
        constraintTakesXArgButYWereSupplied,
        constraintTakesXArgsButYWereSupplied,
        convMustHave1RetVal,
        convMustHave1Param,
        expected1ParamFoundX,
        expected1ParamFoundXs,
        missingCurlyBraces,
        deferInsideDefer,
        cantDeferInsideDefer,
        xInsideDefer,
        cantXInsideDefer,
        breakOutsideLoop,
        cantBreakOutsideLoop,
        continueOutsideLoop,
        cantContinueOutsideLoop,
        xNotValidRetType,
        chanSizeMustBePositive,
        arraySizeMustBePositive,
        missingCommaOrRightParenthesisInsideChanSignature,
        missingCommaOrRightParenthesisInsideArraySignature,
        missingParenthesesAfterChanSignature,
        missingParenthesesAfterArraySignature,
        expectedIntFoundX,
        chanSizeMustBeOneOrHigher,
        arraySizeMustBeZeroOrHigher,
        expectedAtLeastSizeOf1FoundX,
        expectedCommaOrRightParenthesisFoundX,
        chanCantBeOfTypeX,
        invalidChanType,
        missingParenthesesAfterX,
        missingCommaInX,
        onlyOneDefaultCasePerX,
        defaultCaseAlreadyDef,
        prevDefaultCaseDef,
        missingWhileOrUntilAfterLoop,
        expectedWhileOrUntilFoundX,
        varDefOrRefExpected,
        varOrRefExpectedFoundX,
        varNameExpected,
        varNameExpectedFoundX,
        arrayCantBeOfTypeX,
        invalidArrayType,
        primXMustRetBoolAndVal,
        signatureMismatch,
        funcXMustRetBoolAndVal,
        notIterable,
        forCantIterateOverX,
        cantEvalArityUnknownCompound,
        arityEvalError,
        typeOfIteratorMustBeIntNotX,
        iteratorMustBeInt,
        mismatchedNumRetVal,
        expectedXRetValFoundY,
        expectedXRetValsFoundY,
        retSignatureOfTypeX,
        retTypeXNotMatchSignatureY,
        expectedXVal,
        opNotListedInOpPriorityTable,
        unknownOpPriority,
        mismatchedTypes,
        missingX,
        xNotClassType,
        fieldXInitMultipleTimes,
        xAlreadyInit,
        prevInit,
        fieldXNotExist,
        unknownField,
        expectedFieldNameFoundX,
        missingField,
        indexesShouldBeSeparatedByComma,
        missingVal,
        expectedIndexFoundComma,
        expectedIntFoundNothing,
        noValToConv,
        expectedVarFoundX,
        missingVar,
        exprYieldsNoVal,
        expectedValFoundNothing,
        missingSemicolonAfterExprList,
        tryingAssignXValsToYVar,
        tryingAssignXValsToYVars,
        moreValThanVarToAssign,
        assignationMissingVal,
        expressionEmpty,
        firstValOfAssignmentListCantBeEmpty,
        cantInferTypeWithoutAssignment,
        missingTypeInfoOrInitVal,
        missingSemicolonAfterAssignmentList,
        typeXHasNoDefaultVal,
        cantInitThisType,
        missingParenthesesAfterType,
        expectedFuncNameFoundX,
        missingFuncName,
        cantInferTypeOfX,
        funcTypeCantBeInferred,
        unexpectedXFoundInExpr,
        xCantExistInsideThisExpr,
        methodCallMustBePlacedAfterVal,
        arrayCantBeIndexedByX,
        invalidArrayIndexType,
        cantAccessFieldOnTypeX,
        expectedClassFoundX,
        xOnTypeYIsPrivate,
        privateField,
        noFieldXOnTypeY,
        availableFieldsAreX,
        missingParamOnMethodCall,
        xMustBePlacedAfterVal,
        xMustBeInsideFuncOrTask,
        xRefNoFuncNorTask,
        valBeforeAssignationNotReferenceable,
        missingRefBeforeAssignation,
        cantDoThisKindOfOpOnLeftSideOfAssignement,
        unexpectedOp,
        binOpMustHave2Operands,
        unexpectedXSymbolInExpr,
        unexpectedSymbol,
        missingSemicolonAtEndOfExpr,
        cantLoadFieldOfTypeX,
        fieldTypeIsInvalid,
        xNotCallable,
        xNotFuncNorTask,
        funcTakesXArgButMoreWereSupplied,
        funcTakesXArgsButMoreWereSupplied,
        funcIsOfTypeX,
        expectedXArg,
        expectedXArgs,
        funcTakesXArgButYWereSupplied,
        funcTakesXArgsButYWereSupplied,
        expectedXArgFoundY,
        expectedXArgsFoundY,
        funcOrTaskExpectedFoundX,
        funcDefHere,
        expectedDotAfterEnumType,
        missingEnumConstantName,
        expectedConstNameAfterEnumType,
        xIsAbstract,
        xIsAbstractAndCannotBeInstanciated
    }
    // format(getError(Error.), )
    /*

logError(format(getError(Error.xNotDecl), getPrettyFunctionCall(name,
        signature)), getError(Error.unknownType), "", -1);
    */
    private string getError(Error error) {
        immutable string[Error][GrLocale.max + 1] messages = [
            [ //en_US
                Error.eofReached: "reached the end of the file",
                Error.eof: "unexpected end of file",
                Error.unknownFunc: "unknown function",
                Error.unknownVar: "unknown variable",
                Error.unknownOp: "unknown operator",
                Error.unknownClass: "unknown class",
                Error.unknownType: "unknown type",
                Error.unknownOpPriority: "unknown operator priority",
                Error.unknownField: "unknown field",
                Error.invalidType: "invalid type",
                Error.invalidParamType: "invalid parameter type",
                Error.invalidChanType: "invalid channel type",
                Error.invalidArrayType: "invalid array type",
                Error.invalidArrayIndexType: "invalid array index type",
                Error.xNotDef: "`%s` is not defined",
                Error.xNotDecl: "`%s` is not declared",
                Error.nameXDefMultipleTimes: "the name `%s` is defined multiple times",
                Error.xRedefHere: "`%s` is redefined here",
                Error.prevDefOfX: "previous definition of `%s`",
                Error.prevDefPrim: "`%s` is already defined as a primitive",
                Error.alreadyDef: "`%s` is already declared",
                Error.cantDefVarOfTypeX: "can't define a variable of type %s",
                Error.cantUseTypeAsParam: "can't use `%s` as a parameter type",
                Error.opMustHave1RetVal: "an operator must have only one return value",
                Error.expected1RetValFoundX: "expected 1 return value, found %s return value",
                Error.expected1RetValFoundXs: "expected 1 return value, found %s return values",
                Error.cantUseOpOnMultipleVal: "can't use an operator on multiple values",
                Error.exprYieldsMultipleVal: "the expression yields multiple values",
                Error.noXUnaryOpDefForY: "there is no `%s` unary operator defined for `%s`",
                Error.noXBinaryOpDefForYAndZ: "there is no `%s` binary operator defined for `%s` and `%s`",
                Error.xIsConstAndCantBeModified: "`%s` is const and can't be modified",
                Error.cantModifyAConstX: "can't modify a const `%s`",
                Error.cantAssignToAXVar: "can't assign to a `%s` variable",
                Error.ValNotAssignable: "the value is not assignable",
                Error.cantInferTypeOfVar: "can't infer the type of variable",
                Error.varNotInit: "the variable has not been initialized",
                Error.locVarUsedNotAssigned: "the local variable is being used without being assigned",
                Error.cantGetValueOfX: "can't get the value of `%s`",
                Error.valNotFetchable: "the value is not fetchable",
                Error.globalDeclExpected: "a global declaration is expected",
                Error.globalDeclExpectedFoundX: "a global declaration is expected, found `%s`",
                Error.funcMissingRetAtEnd: "the function is missing a return at the end of the scope",
                Error.missingRet: "missing `return`",
                Error.expectedTypeAliasNameFoundX: "expected type alias name, found `%s`",
                Error.expectedEnumNameFoundX: "expected enum name, found `%s`",
                Error.expectedXFoundY: "expected `%s`, found `%s`",
                Error.missingIdentifier: "missing identifier",
                Error.missingAssignInType: "missing assignment in `type`",
                Error.missingSemicolonAfterType: "missing semicolon after `type`",
                Error.enumDefNotHaveBody: "the enum definition does not have a body",
                Error.expectedEnumFieldFoundX: "expected enum field, found `%s`",
                Error.missingSemicolonAfterEnumField: "missing semicolon after type enum field",
                Error.xAlreadyDecl: "`%s` is already declared",
                Error.expectedClassNameFoundX: "expected class name, found `%s`",
                Error.parentClassNameMissing: "the parent class name is missing",
                Error.classHaveNoBody: "the class does not have a body",
                Error.missingSemicolonAfterClassFieldDecl: "missing semicolon after class field declaration",
                Error.xCantInheritFromY: "`%s` can't inherit from `%s`",
                Error.xIncludedRecursively: "`%s` is included recursively",
                Error.recursiveInheritence: "recursive inheritence",
                Error.fieldXDeclMultipleTimes: "the field `%s` is declared multiple times",
                Error.recursiveDecl: "recursive declaration",
                Error.xNotValidType: "`%s` is not a valid type",
                Error.expectedValidTypeFoundX: "expected a valid type, found `%s`",
                Error.arrayCanOnlyContainOneTypeOfVal: "a array can only contain one type of value",
                Error.conflictingArraySignature: "conflicting array signature",
                Error.tryUsingXInstead: "try using `%s` instead",
                Error.channelCanOnlyContainOneTypeOfVal: "a channel can only contain one type of value",
                Error.conflictingChannelSignature: "conflicting channel signature",
                Error.missingTemplateVal: "missing template value",
                Error.templateValShouldBeSeparatedByComma: "template values should be separated by a comma",
                Error.templateTypesShouldBeSeparatedByComma: "template types should be separated by a comma",
                Error.missingParentheses: "missing parentheses",
                Error.paramShouldBeSeparatedByComma: "parameters should be separated by a comma",
                Error.expectedIdentifierFoundX: "expected identifier, found `%s`",
                Error.typesShouldBeSeparatedByComma: "types should be separated by a comma",
                Error.addingPubBeforeEventIsRedundant: "adding `public` before `event` is redundant",
                Error.eventAlreadyPublic: "event is already public",
                Error.cantOverrideXOp: "can't override `%s` operator",
                Error.opCantBeOverriden: "this operator can't be overriden",
                Error.missingConstraint: "missing constraint",
                Error.xIsNotAKnownConstraint: "`%s` is not a known constraint",
                Error.validConstraintsAreX: "valid constraints are: %s",
                Error.expectedColonAfterType: "`:` expected after a type",
                Error.constraintTakesXArgButYWereSupplied: "the constraint takes %s argument but %s were supplied",
                Error.constraintTakesXArgsButYWereSupplied: "the constraint takes %s arguments but %s were supplied",
                Error.convMustHave1RetVal: "a conversion must have only one return value",
                Error.convMustHave1Param: "a conversion must have only one parameter",
                Error.expected1ParamFoundX: "expected 1 parameter, found %s parameter",
                Error.expected1ParamFoundXs: "expected 1 parameter, found %s parameters",
                Error.missingCurlyBraces: "missing curly braces",
                Error.expectedIntFoundX: "expected int_, found `%s`",
                Error.deferInsideDefer: "`defer` inside another `defer`",
                Error.cantDeferInsideDefer: "can't `defer` inside another `defer`",
                Error.xInsideDefer: "`%s` inside a defer",
                Error.cantXInsideDefer: "can't `%s` inside a defer",
                Error.breakOutsideLoop: "`break` outside of a loop",
                Error.cantBreakOutsideLoop: "can't `break` outside of a loop",
                Error.continueOutsideLoop: "`continue` outside of a loop",
                Error.cantContinueOutsideLoop: "can't `continue` outside of a loop",
                Error.xNotValidRetType: "`%s` is not a valid return type",
                Error.chanSizeMustBePositive: "a channel size must be a positive integer value",
                Error.arraySizeMustBePositive: "an array size must be a positive integer value",
                Error.missingCommaOrRightParenthesisInsideChanSignature: "missing `,` or `)` inside channel signature",
                Error.missingCommaOrRightParenthesisInsideArraySignature: "missing `,` or `)` inside array signature",
                Error.missingParenthesesAfterChanSignature: "missing parentheses after the channel signature",
                Error.missingParenthesesAfterArraySignature: "missing parentheses after the array signature",
                Error.chanSizeMustBeOneOrHigher: "the channel size must be one or higher",
                Error.arraySizeMustBeZeroOrHigher: "the array size must be zero or higher",
                Error.expectedAtLeastSizeOf1FoundX: "expected at least a size of 1, found %s",
                Error.expectedCommaOrRightParenthesisFoundX: "expected `,` or `)`, found `%s`",
                Error.chanCantBeOfTypeX: "a channel can't be of type `%s`",
                Error.missingParenthesesAfterX: "missing parentheses after `%s`",
                Error.missingCommaInX: "missing comma in `%s`",
                Error.onlyOneDefaultCasePerX: "there must be only up to one default case per `%s`",
                Error.defaultCaseAlreadyDef: "default case already defined",
                Error.prevDefaultCaseDef: "previous default case definition",
                Error.missingWhileOrUntilAfterLoop: "missing `while` or `until` after the loop",
                Error.expectedWhileOrUntilFoundX: "expected `while` or `until`, found `%s`",
                Error.varDefOrRefExpected: "a variable definition or reference is expected",
                Error.varOrRefExpectedFoundX: "a variable or reference is expected, found `%s`",
                Error.varNameExpected: "a variable name is expected",
                Error.varNameExpectedFoundX: "a variable name is expected, found `%s`",
                Error.arrayCantBeOfTypeX: "a array can't be of type `%s`",
                Error.primXMustRetBoolAndVal: "the primitive `%s` must return a bool and a value",
                Error.signatureMismatch: "signature mismatch",
                Error.funcXMustRetBoolAndVal: "the function `%s` must return a bool and a value",
                Error.notIterable: "not iterable",
                Error.forCantIterateOverX: "for can't iterate over a `%s`",
                Error.cantEvalArityUnknownCompound: "can't evaluate the arity of an unknown compound",
                Error.arityEvalError: "arity evaluation error",
                Error.typeOfIteratorMustBeIntNotX: "the type of the iterator must be an int_, not `%s`",
                Error.iteratorMustBeInt: "the iterator must be an int_",
                Error.mismatchedNumRetVal: "mismatched number of return values",
                Error.expectedXRetValFoundY: "expected %s return value, found %s",
                Error.expectedXRetValsFoundY: "expected %s return values, found %s",
                Error.retSignatureOfTypeX: "the return signature is of type `%s`",
                Error.retTypeXNotMatchSignatureY: "the returned type `%s` does not match the signature `%s`",
                Error.expectedXVal: "expected `%s` value",
                Error.opNotListedInOpPriorityTable: "the operator is not listed in the operator priority table",
                Error.mismatchedTypes: "mismatched types",
                Error.missingX: "missing `%s`",
                Error.xNotClassType: "`%s` is not a class type",
                Error.fieldXInitMultipleTimes: "the field `%s` is initialized multiple times",
                Error.xAlreadyInit: "`%s` is already initialized",
                Error.prevInit: "previous initialization",
                Error.fieldXNotExist: "the field `%s` doesn't exist",
                Error.expectedFieldNameFoundX: "expected field name, found `%s`",
                Error.missingField: "missing field",
                Error.indexesShouldBeSeparatedByComma: "indexes should be separated by a comma",
                Error.missingVal: "missing value",
                Error.expectedIndexFoundComma: "an index is expected, found `,`",
                Error.expectedIntFoundNothing: "expected int_, found nothing",
                Error.noValToConv: "no value to convert",
                Error.expectedVarFoundX: "expected variable, found `%s`",
                Error.missingVar: "missing variable",
                Error.exprYieldsNoVal: "the expression yields no value",
                Error.expectedValFoundNothing: "expected value, found nothing",
                Error.missingSemicolonAfterExprList: "missing semicolon after expression array",
                Error.tryingAssignXValsToYVar: "trying to assign `%s` values to %s variable",
                Error.tryingAssignXValsToYVars: "trying to assign `%s` values to %s variables",
                Error.moreValThanVarToAssign: "there are more values than variable to assign to",
                Error.assignationMissingVal: "the assignation is missing a value",
                Error.expressionEmpty: "the expression is empty",
                Error.firstValOfAssignmentListCantBeEmpty: "first value of an assignment array can't be empty",
                Error.cantInferTypeWithoutAssignment: "can't infer the type without assignment",
                Error.missingTypeInfoOrInitVal: "missing type information or initial value",
                Error.missingSemicolonAfterAssignmentList: "missing semicolon after assignment array",
                Error.typeXHasNoDefaultVal: "the type `%s` has no default value",
                Error.cantInitThisType: "can't initialize this type",
                Error.missingParenthesesAfterType: "missing parentheses after the type",
                Error.expectedFuncNameFoundX: "expected function name, found `%s`",
                Error.missingFuncName: "missing function name",
                Error.cantInferTypeOfX: "can't infer the type of `%s`",
                Error.funcTypeCantBeInferred: "the function type can't be inferred",
                Error.unexpectedXFoundInExpr: "unexpected `%s` found in expression",
                Error.xCantExistInsideThisExpr: "a `%s` can't exist inside this expression",
                Error.methodCallMustBePlacedAfterVal: "a method call must be placed after a value",
                Error.arrayCantBeIndexedByX: "a array can't be indexed by a `%s`",
                Error.cantAccessFieldOnTypeX: "can't access a field on type `%s`",
                Error.expectedClassFoundX: "expected a class, found `%s`",
                Error.xOnTypeYIsPrivate: "`%s` on type `%s` is private",
                Error.privateField: "private field",
                Error.noFieldXOnTypeY: "no field `%s` on type `%s`",
                Error.availableFieldsAreX: "available fields are: %s",
                Error.missingParamOnMethodCall: "missing parameter on method call",
                Error.xMustBePlacedAfterVal: "`%s` must be placed after a value",
                Error.xMustBeInsideFuncOrTask: "`%s` must be inside a function or a task",
                Error.xRefNoFuncNorTask: "`%s` references no function nor task",
                Error.valBeforeAssignationNotReferenceable: "the value before assignation is not referenceable",
                Error.missingRefBeforeAssignation: "missing reference before assignation",
                Error.cantDoThisKindOfOpOnLeftSideOfAssignement: "can't do this kind of operation on the left side of an assignment",
                Error.unexpectedOp: "unexpected operation",
                Error.binOpMustHave2Operands: "a binary operation must have 2 operands",
                Error.unexpectedXSymbolInExpr: "unexpected `%s` symbol in the expression",
                Error.unexpectedSymbol: "unexpected symbol",
                Error.missingSemicolonAtEndOfExpr: "missing semicolon at the end of the expression",
                Error.cantLoadFieldOfTypeX: "can't load a field of type `%s`",
                Error.fieldTypeIsInvalid: "the field type is invalid",
                Error.xNotCallable: "`%s` is not callable",
                Error.xNotFuncNorTask: "`%s` is not a function nor a task",
                Error.funcTakesXArgButMoreWereSupplied: "the function takes %s argument but more were supplied",
                Error.funcTakesXArgsButMoreWereSupplied: "the function takes %s arguments but more were supplied",
                Error.funcIsOfTypeX: "the function is of type `%s`",
                Error.expectedXArg: "expected %s argument",
                Error.expectedXArgs: "expected %s arguments",
                Error.funcTakesXArgButYWereSupplied: "the function takes %s argument but %s were supplied",
                Error.funcTakesXArgsButYWereSupplied: "the function takes %s arguments but %s were supplied",
                Error.expectedXArgFoundY: "expected %s argument, found %s",
                Error.expectedXArgsFoundY: "expected %s arguments, found %s",
                Error.funcOrTaskExpectedFoundX: "function or task expected, found `%s`",
                Error.funcDefHere: "function defined here",
                Error.expectedDotAfterEnumType: "expected a `.` after the enum type",
                Error.missingEnumConstantName: "missing the enum constant name",
                Error.expectedConstNameAfterEnumType: "expected a constant name after the enum type",
                Error.xIsAbstract: "`%s` is abstract",
                Error.xIsAbstractAndCannotBeInstanciated: "`%s` is abstract and can't be instanciated"
            ],
            [ // fr_FR
                Error.eofReached: "fin de fichier atteinte",
                Error.eof: "fin de fichier inattendue",
                Error.unknownFunc: "fonction inconnue",
                Error.unknownVar: "variable inconnue",
                Error.unknownOp: "oprateur inconnu",
                Error.unknownClass: "classe inconnue",
                Error.unknownType: "type inconnu",
                Error.unknownOpPriority: "priorit doprateur inconnue",
                Error.unknownField: "champ inconnu",
                Error.invalidType: "type invalide",
                Error.invalidParamType: "type de paramtre invalide",
                Error.invalidChanType: "type de canal invalide",
                Error.invalidArrayType: "type de liste invalide",
                Error.invalidArrayIndexType: "type dindex de liste invalide",
                Error.xNotDef: "`%s` nest pas dfini",
                Error.xNotDecl: "`%s` nest pas dclar",
                Error.nameXDefMultipleTimes: "le nom `%s` est dfini plusieurs fois",
                Error.xRedefHere: "`%s` est redfini ici",
                Error.prevDefOfX: "prcdente dfinition de `%s`",
                Error.prevDefPrim: "`%s` est dj dfini en tant que primitive",
                Error.alreadyDef: "`%s` est dj dfini",
                Error.cantDefVarOfTypeX: "impossible dfinir une variable du type %s",
                Error.cantUseTypeAsParam: "impossible d'utiliser `%s` comme type de paramtre",
                Error.opMustHave1RetVal: "un operateur ne doit avoir qu'une valeur de retour",
                Error.expected1RetValFoundX: "1 valeur de retour attendue, %s valeur trouve",
                Error.expected1RetValFoundXs: "1 valeur de retour attendue, %s valeurs trouves",
                Error.cantUseOpOnMultipleVal: "impossible d'utiliser un oprateur sur plusieurs valeurs",
                Error.exprYieldsMultipleVal: "lexpression dlivre plusieurs valeurs",
                Error.noXUnaryOpDefForY: "il ny a pas doprateur unaire `%s` dfini pour `%s`",
                Error.noXBinaryOpDefForYAndZ: "il ny pas doprateur binaire `%s` dfini pour `%s` et `%s`",
                Error.xIsConstAndCantBeModified: "`%s` est constant et ne peut tre altr",
                Error.cantModifyAConstX: "impossible de modifier un `%s` constant",
                Error.cantAssignToAXVar: "impossible dassigner  une variable `%s`",
                Error.ValNotAssignable: "la valeur est non-assignable",
                Error.cantInferTypeOfVar: "impossible dinfrer le type de la variable",
                Error.varNotInit: "la variable na pas t initialise",
                Error.locVarUsedNotAssigned: "la variable locale est utilise sans avoir t assigne",
                Error.cantGetValueOfX: "impossible de rcuprer la valeure de `%s`",
                Error.valNotFetchable: "la valeur nest pas rcuprable",
                Error.globalDeclExpected: "une dclaration globale est attendue",
                Error.globalDeclExpectedFoundX: "une dclaration globale est attendue, `%s` trouv",
                Error.funcMissingRetAtEnd: "il manque un retour en fin de fonction",
                Error.missingRet: "`retourne` manquant",
                Error.expectedTypeAliasNameFoundX: "nom dalias de type attendu, `%s` trouv",
                Error.expectedEnumNameFoundX: "nom d'numration attendu, `%s` trouv",
                Error.expectedXFoundY: "`%s` attendu, `%s` trouv",
                Error.missingIdentifier: "identificateur attendu",
                Error.missingAssignInType: "assignation manquante dans `type`",
                Error.missingSemicolonAfterType: "point-virgule manquand dans `type`",
                Error.enumDefNotHaveBody: "la dfinition de lnumration na pas de corps",
                Error.expectedEnumFieldFoundX: "champ attendu dans lnumration, `%s` trouv",
                Error.missingSemicolonAfterEnumField: "point-virgule manquant aprs le champ de lnumration",
                Error.xAlreadyDecl: "`%s` est dj dclar",
                Error.expectedClassNameFoundX: "nom de classe attendu, `%s` trouv",
                Error.parentClassNameMissing: "le nom de la classe parente est manquante",
                Error.classHaveNoBody: "la classe na pas de corps",
                Error.missingSemicolonAfterClassFieldDecl: "point-virgule manquant aprs le champ de la classe",
                Error.xCantInheritFromY: "`%s` ne peut pas hriter de `%s`",
                Error.xIncludedRecursively: "`%s` est inclus rcursivement",
                Error.recursiveInheritence: "hritage rcursif",
                Error.fieldXDeclMultipleTimes: "le champ `%s` est dclar plusieurs fois",
                Error.recursiveDecl: "dclaration rcursive",
                Error.xNotValidType: "`%s` nest pas un type valide",
                Error.expectedValidTypeFoundX: "type valide attendu, `%s` trouv",
                Error.arrayCanOnlyContainOneTypeOfVal: "une liste ne peut contenir quun type de valeur",
                Error.conflictingArraySignature: "signature de liste conflictuelle",
                Error.tryUsingXInstead: "utilisez plutt `%s`",
                Error.channelCanOnlyContainOneTypeOfVal: "un canal ne peut contenir quun type de valeur",
                Error.conflictingChannelSignature: "signature de canal conflictuelle",
                Error.missingTemplateVal: "valeur de patron manquante",
                Error.templateValShouldBeSeparatedByComma: "les valeurs de patron doivent tre spares par des virgules",
                Error.templateTypesShouldBeSeparatedByComma: "les types de patron doivent tre spars par des virgules",
                Error.missingParentheses: "parenthses manquantes",
                Error.paramShouldBeSeparatedByComma: "les paramtres doivent tre spares par des virgules",
                Error.expectedIdentifierFoundX: "identificateur attendu, `%s` trouv",
                Error.typesShouldBeSeparatedByComma: "les types doivent tre spars par des virgules",
                Error.addingPubBeforeEventIsRedundant: "ajouter `public` devant `event` est redondant",
                Error.eventAlreadyPublic: "les events sont dj publiques",
                Error.cantOverrideXOp: "impossible de surcharger loprateur `%s`",
                Error.opCantBeOverriden: "cet oprateur ne peut tre surcharg",
                Error.missingConstraint: "contrainte manquante",
                Error.xIsNotAKnownConstraint: "`%s` nest pas une contrainte connue",
                Error.validConstraintsAreX: "les contraintes valides sont: %s",
                Error.expectedColonAfterType: "`:` attendu aprs le type",
                Error.constraintTakesXArgButYWereSupplied: "cette contrainte prend %s argument mais %s ont t fournis",
                Error.constraintTakesXArgsButYWereSupplied: "cette contrainte prend %s arguments mais %s ont t fournis",
                Error.convMustHave1RetVal: "une conversion ne peut avoir quune seule valeur de retour",
                Error.convMustHave1Param: "une conversion ne peut avoir quun seul paramtre",
                Error.expected1ParamFoundX: "1 paramtre attendu, %s paramtre trouv",
                Error.expected1ParamFoundXs: "1 paramtre attendu, %s paramtres trouvs",
                Error.missingCurlyBraces: "accolades manquantes",
                Error.expectedIntFoundX: "entier attendu, `%s` trouv",
                Error.deferInsideDefer: "`dcale`  lintrieur dun autre `dcale`",
                Error.cantDeferInsideDefer: "impossible de faire un `dcale` dans un autre `defer`",
                Error.xInsideDefer: "`%s`  lintrieur dun dcale",
                Error.cantXInsideDefer: "impossible de faire un `%s` dans un dcale",
                Error.breakOutsideLoop: "`casse` en dehors dune boucle",
                Error.cantBreakOutsideLoop: "impossible de `casse` en dehors dune boucle",
                Error.continueOutsideLoop: "`continue` en dehors dune boucle",
                Error.cantContinueOutsideLoop: "impossible de `continue` en dehors dune boucle",
                Error.xNotValidRetType: "`%s` nest pas un type de retour valide",
                Error.chanSizeMustBePositive: "la taille dun canal doit tre un entier positif",
                Error.arraySizeMustBePositive: "la taille dune liste doit tre un entier positif",
                Error.missingCommaOrRightParenthesisInsideChanSignature: "`,` ou `)` manquant dans la signature du canal",
                Error.missingCommaOrRightParenthesisInsideArraySignature: "`,` ou `)` manquant dans la signature de la liste",
                Error.missingParenthesesAfterChanSignature: "parenthses manquantes aprs la signature du canal",
                Error.missingParenthesesAfterArraySignature: "parenthses manquantes aprs la signature de la liste",
                Error.chanSizeMustBeOneOrHigher: "la taille du canal doit tre de un ou plus",
                Error.arraySizeMustBeZeroOrHigher: "la taille dune liste doit tre suprieure  zro",
                Error.expectedAtLeastSizeOf1FoundX: "une taille de 1 minimum attendue, %s trouv",
                Error.expectedCommaOrRightParenthesisFoundX: "`,` ou `)` attendu, `%s` trouv",
                Error.chanCantBeOfTypeX: "un canal ne peut tre de type `%s`",
                Error.missingParenthesesAfterX: "parenthses manquantes aprs `%s`",
                Error.missingCommaInX: "virgule manquante dans `%s`",
                Error.onlyOneDefaultCasePerX: "il ne peut y avoir un maximum dun cas par dfaut dans un `%s`",
                Error.defaultCaseAlreadyDef: "le cas par dfaut a dj t dfini",
                Error.prevDefaultCaseDef: "prcdente dfinition du cas par dfaut",
                Error.missingWhileOrUntilAfterLoop: "`tant` ou `jusque` manquant aprs la boucle",
                Error.expectedWhileOrUntilFoundX: "`tant` ou `jusque` attendu, `%s` trouv",
                Error.varDefOrRefExpected: "une dfinition de variable ou une rfrence est attendue",
                Error.varOrRefExpectedFoundX: "une variable ou rfrence est attendue, `%s` trouv",
                Error.varNameExpected: "un nom de variable est attendu",
                Error.varNameExpectedFoundX: "un nom de variable est attendu, `%s` trouv",
                Error.arrayCantBeOfTypeX: "une liste ne peut pas tre de type `%s`",
                Error.primXMustRetBoolAndVal: "la primitive `%s` doit retourner un boolen et une valeur",
                Error.signatureMismatch: "la signature ne correspond pas",
                Error.funcXMustRetBoolAndVal: "la function `%s` doit retourner un boolen et une valeur",
                Error.notIterable: "non-itrable",
                Error.forCantIterateOverX: "pour ne peut itrer sur `%s`",
                Error.cantEvalArityUnknownCompound: "impossible de calculer larit dun compos inconnu",
                Error.arityEvalError: "erreur de calcul darit",
                Error.typeOfIteratorMustBeIntNotX: "le type dun itrateur doit tre un entier, pas `%s`",
                Error.iteratorMustBeInt: "litrateur doit tre un entier",
                Error.mismatchedNumRetVal: "le nombre de valeur de retour ne correspond pas",
                Error.expectedXRetValFoundY: "%s valeur de retour attendue, %s trouv",
                Error.expectedXRetValsFoundY: "%s valeurs de retour attendues, %s trouv",
                Error.retSignatureOfTypeX: "la signature de retour est `%s`",
                Error.retTypeXNotMatchSignatureY: "le type retourn `%s` ne correspond pas avec la signature `%s`",
                Error.expectedXVal: "type `%s` attendu",
                Error.opNotListedInOpPriorityTable: "loprateur nest pas list dans la liste de priorit doprateurs",
                Error.mismatchedTypes: "types diffrents",
                Error.missingX: "`%s` manquant",
                Error.xNotClassType: "`%s` nest pas un type de classe",
                Error.fieldXInitMultipleTimes: "le champ `%s` est initialis plusieurs fois",
                Error.xAlreadyInit: "`%s` est dj initialis",
                Error.prevInit: "initialisation prcdente",
                Error.fieldXNotExist: "le champ `%s` nexiste pas",
                Error.expectedFieldNameFoundX: "nom de champ attendu, `%s` trouv",
                Error.missingField: "champ manquant",
                Error.indexesShouldBeSeparatedByComma: "les index doivent tre spars par une virgule",
                Error.missingVal: "valeur manquante",
                Error.expectedIndexFoundComma: "un index est attendu, `,` trouv",
                Error.expectedIntFoundNothing: "entier attendu, rien de trouv",
                Error.noValToConv: "aucune valeur  convertir",
                Error.expectedVarFoundX: "variable attendu, `%s` trouv",
                Error.missingVar: "variable manquante",
                Error.exprYieldsNoVal: "lexpression ne rend aucune valeur",
                Error.expectedValFoundNothing: "valeur attendue, rien de trouv",
                Error.missingSemicolonAfterExprList: "point-virgule manquant aprs la liste dexpressions",
                Error.tryingAssignXValsToYVar: "tentative dassigner `%s` valeurs  %s variable",
                Error.tryingAssignXValsToYVars: "tentative dassigner `%s` valeurs  %s variables",
                Error.moreValThanVarToAssign: "il y a plus de valeurs que de variables auquels affecter",
                Error.assignationMissingVal: "il manque une valeur  lassignation",
                Error.expressionEmpty: "lexpression est vide",
                Error.firstValOfAssignmentListCantBeEmpty: "la premire valeur dune liste dassignation ne peut tre vide",
                Error.cantInferTypeWithoutAssignment: "impossible dinfrer le type sans assignation",
                Error.missingTypeInfoOrInitVal: "information de type ou valeur initiale manquante",
                Error.missingSemicolonAfterAssignmentList: "point-virgule manquant aprs la liste dassignation",
                Error.typeXHasNoDefaultVal: "le type `%s` na pas de valeur par dfaut",
                Error.cantInitThisType: "impossible dinitialiser ce type",
                Error.missingParenthesesAfterType: "parenthses manquantes aprs le type",
                Error.expectedFuncNameFoundX: "nom de fonction attendu, `%s` trouv",
                Error.missingFuncName: "nom de fonction manquant",
                Error.cantInferTypeOfX: "impossible dinfrer le type de `%s`",
                Error.funcTypeCantBeInferred: "le type de la fonction ne peut pas tre infr",
                Error.unexpectedXFoundInExpr: "`%s` inattendu dans lexpression",
                Error.xCantExistInsideThisExpr: "un `%s` ne peut exister dans lexpression",
                Error.methodCallMustBePlacedAfterVal: "un appel de mthode doit se placer aprs une valeur",
                Error.arrayCantBeIndexedByX: "une liste ne peut pas tre index par un `%s`",
                Error.cantAccessFieldOnTypeX: "impossible daccder  un champ sur `%s`",
                Error.expectedClassFoundX: "classe attendue, `%s` trouv",
                Error.xOnTypeYIsPrivate: "`%s` du type `%s` est priv",
                Error.privateField: "champ priv",
                Error.noFieldXOnTypeY: "aucun champ `%s` dans `%s`",
                Error.availableFieldsAreX: "les champs disponibles sont: %s",
                Error.missingParamOnMethodCall: "paramtre manquant dans lappel de mthode",
                Error.xMustBePlacedAfterVal: "`%s` doit tre plac aprs une valeur",
                Error.xMustBeInsideFuncOrTask: "`%s` doit tre  lintrieur dune fonction ou dune tche",
                Error.xRefNoFuncNorTask: "`%s` ne rfrence aucune fonction ou tche",
                Error.valBeforeAssignationNotReferenceable: "la valeur devant lassignation nest pas rfrenable",
                Error.missingRefBeforeAssignation: "rfrence manquante avant lassignation",
                Error.cantDoThisKindOfOpOnLeftSideOfAssignement: "ce genre dopration est impossible  gauche dune assignation",
                Error.unexpectedOp: "opration inattendue",
                Error.binOpMustHave2Operands: "une opration binaire doit avoir 2 oprandes",
                Error.unexpectedXSymbolInExpr: "symbole `%s` inattendu dans lexpression",
                Error.unexpectedSymbol: "symbole inattendu",
                Error.missingSemicolonAtEndOfExpr: "point-virgule manquant en fin dexpression",
                Error.cantLoadFieldOfTypeX: "impossible de charger un champ de type `%s`",
                Error.fieldTypeIsInvalid: "le type de champ est invalide",
                Error.xNotCallable: "`%s` nest pas appelable",
                Error.xNotFuncNorTask: "`%s` nest ni une fonction ni une tche",
                Error.funcTakesXArgButMoreWereSupplied: "cette fonction prend %s argument mais plus ont t fournis",
                Error.funcTakesXArgsButMoreWereSupplied: "cette fonction prend %s arguments mais plus ont t fournis",
                Error.funcIsOfTypeX: "cette fonction est de type `%s`",
                Error.expectedXArg: "%s argument attendu",
                Error.expectedXArgs: "%s arguments attendus",
                Error.funcTakesXArgButYWereSupplied: "cette fonction prend %s argument mais %s ont t fournis",
                Error.funcTakesXArgsButYWereSupplied: "cette fonction prend %s arguments mais %s ont t fournis",
                Error.expectedXArgFoundY: "%s argument attendu, %s trouv",
                Error.expectedXArgsFoundY: "%s arguments attendus, %s trouv",
                Error.funcOrTaskExpectedFoundX: "fonction ou tche attendu, `%s` trouv",
                Error.funcDefHere: "fonction dfinie l",
                Error.expectedDotAfterEnumType: "`.` attendu aprs le type dnumration",
                Error.missingEnumConstantName: "nom de la constante dnumration attendu",
                Error.expectedConstNameAfterEnumType: "nom de la constante attendue aprs le type dnumration",
                Error.xIsAbstract: "`%s` est abstrait",
                Error.xIsAbstractAndCannotBeInstanciated: "`%s` est abstrait et ne peut pas tre instanci"
            ]
        ];
        return messages[_locale][error];
    }
}

/**
Syntatic error during parsing
*/
package final class GrParserException : Exception {
    GrError error;

    /// Ctor
    this(GrError error_, string file = __FILE__, size_t line = __LINE__) {
        super(error_.message, file, line);
        error = error_;
    }
}
