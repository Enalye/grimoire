/** 
 * Copyright: Enalye
 * License: Zlib
 * Authors: Enalye
 */
module grimoire.compiler.parser;

import std.stdio;
import std.format;
import std.string;
import std.array;
import std.conv;
import std.math;
import std.file;
import std.meta;

import grimoire.runtime;
import grimoire.assembly;
import grimoire.compiler.util;
import grimoire.compiler.lexer;
import grimoire.compiler.mangle;
import grimoire.compiler.type;
import grimoire.compiler.primitive;
import grimoire.compiler.data;
import grimoire.compiler.pretty;
import grimoire.compiler.error;

/**
Analyses the syntax and produce the data for the VM
The parser analyses the lexemes generated by the lexer and produce machine code.
*/
final class GrParser {
    package {
        GrInt[] iconsts;
        GrFloat[] fconsts;
        GrString[] sconsts;

        uint scopeLevel;

        GrVariable[] globalVariables;
        GrFunction[] instanciatedFunctions, functionsQueue, functions, actions;
        GrFunction[] anonymousFunctions;
        GrTemplateFunction[] templatedFunctions;

        uint current;
        GrFunction currentFunction;
        GrFunction[] functionStack;
        GrFunctionCall[] functionCalls;

        uint[][] breaksJumps;
        uint[][] continuesJumps;
        uint[] continuesDestinations;

        GrLexeme[] lexemes;

        bool isTypeChecking;

        /// Number of int based global variables declared.
        uint iglobalsCount, /// Number of float based global variables declared.
            fglobalsCount, /// Number of string based global variables declared.
            sglobalsCount, /// Number of ptr based global variables declared.
            oglobalsCount;

        GrLocale _locale;
    }

    private {
        GrData _data;
        bool _isAssignationOptimizable;
        int _options;
    }

    /// Ctor
    this(GrLocale locale) {
        _locale = locale;
    }

    /// Reset to the start of the sequence.
    private void reset() {
        current = 0u;
    }

    /// Advance to the next lexeme.
    private void advance() {
        if (current < lexemes.length)
            current++;
    }

    /// Return to the last lexeme.
    private void goBack() {
        if (current > 0u)
            current--;
    }

    /// Check for the end the sequence, then advance to the next lexeme.
    private bool checkAdvance() {
        if (isEnd())
            return false;

        advance();
        return true;
    }

    /// Start of a block with `{`
    private void openBlock() {
        scopeLevel++;
        if (currentFunction)
            currentFunction.openScope();
    }

    /// End of a block with '}'
    private void closeBlock() {
        scopeLevel--;
        if (currentFunction)
            currentFunction.closeScope();
    }

    /// Check for the end of the sequence.
    private bool isEnd(int offset = 0) {
        return (current + offset) >= cast(uint) lexemes.length;
    }

    private void set(uint position_) {
        current = position_;
        if (current < 0 || current >= cast(uint) lexemes.length) {
            current = 0;
        }
    }

    /// Return the lexeme at the current position.
    private GrLexeme get(int offset = 0) {
        const uint position = current + offset;
        if (position < 0 || position >= cast(uint) lexemes.length) {
            logError(getError(Error.eofReached), getError(Error.eof));
        }
        return lexemes[position];
    }

    /// Register an integral value and returns its id.
    private uint registerIntConstant(GrInt value) {
        foreach (size_t index, GrInt iconst; iconsts) {
            if (iconst == value)
                return cast(uint) index;
        }
        iconsts ~= value;
        return cast(uint) iconsts.length - 1;
    }

    /// Register an floating point value and returns its id.
    private uint registerFloatConstant(GrFloat value) {
        foreach (size_t index, GrFloat fconst; fconsts) {
            if (fconst == value)
                return cast(uint) index;
        }
        fconsts ~= value;
        return cast(uint) fconsts.length - 1;
    }

    /// Register an string value and returns its id.
    private uint registerStringConstant(GrString value) {
        foreach (size_t index, GrString sconst; sconsts) {
            if (sconst == value)
                return cast(uint) index;
        }
        sconsts ~= value;
        return cast(uint) sconsts.length - 1;
    }

    /// Register a special local variable, used for iterators, etc.
    private GrVariable registerSpecialVariable(string name, GrType type) {
        name = "~" ~ name;
        GrVariable specialVariable = registerLocalVariable(name, type);
        specialVariable.isAuto = false;
        specialVariable.isInitialized = true; //We shortcut this check
        return specialVariable;
    }

    /// Register a global variable
    private GrVariable registerGlobalVariable(string name, GrType type, bool isAuto, bool isPublic) {
        //Check if declared globally.
        assertNoGlobalDeclaration(name, get().fileId, isPublic);

        GrVariable variable = new GrVariable;
        variable.isAuto = isAuto;
        variable.isGlobal = true;
        variable.isInitialized = false;
        variable.type = type;
        variable.name = name;
        variable.isPublic = isPublic;
        variable.fileId = get().fileId;
        variable.lexPosition = current;
        if (!isAuto)
            setVariableRegister(variable);
        globalVariables ~= variable;

        return variable;
    }

    private GrVariable getGlobalVariable(string name, uint fileId, bool isPublic = false) {
        foreach (GrVariable var; globalVariables) {
            if (var.name == name && (var.fileId == fileId || var.isPublic || isPublic))
                return var;
        }
        return null;
    }

    private void assertNoGlobalDeclaration(string name, uint fileId, bool isPublic) {
        GrVariable var;
        GrFunction func;
        if ((var = getGlobalVariable(name, fileId, isPublic)) !is null)
            logError(format(getError(Error.nameXDefMultipleTimes), name),
                format(getError(Error.xRedefHere), name), "", 0,
                format(getError(Error.prevDefOfX), name), var.lexPosition);
        if (_data.isPrimitiveDeclared(name))
            logError(format(getError(Error.nameXDefMultipleTimes), name),
                format(getError(Error.prevDefPrim), name));
        if ((func = getFunction(name, fileId, isPublic)) !is null)
            logError(format(getError(Error.nameXDefMultipleTimes), name),
                format(getError(Error.xRedefHere), name), "", 0,
                format(getError(Error.prevDefOfX), name), func.lexPosition);
        if ((func = getAction(name)) !is null)
            logError(format(getError(Error.nameXDefMultipleTimes), name),
                format(getError(Error.xRedefHere), name), "", 0,
                format(getError(Error.prevDefOfX), name), func.lexPosition);
    }

    private void setVariableRegister(GrVariable variable) {
        final switch (variable.type.baseType) with (GrBaseType) {
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            if (variable.isGlobal) {
                variable.register = iglobalsCount;
                iglobalsCount++;
            }
            else {
                if (currentFunction.iregisterAvailables.length) {
                    variable.register = currentFunction.iregisterAvailables[$ - 1];
                    currentFunction.iregisterAvailables.length--;
                }
                else {
                    variable.register = currentFunction.ilocalsCount;
                    currentFunction.ilocalsCount++;
                }
            }
            break;
        case float_:
            if (variable.isGlobal) {
                variable.register = fglobalsCount;
                fglobalsCount++;
            }
            else {
                if (currentFunction.fregisterAvailables.length) {
                    variable.register = currentFunction.fregisterAvailables[$ - 1];
                    currentFunction.fregisterAvailables.length--;
                }
                else {
                    variable.register = currentFunction.flocalsCount;
                    currentFunction.flocalsCount++;
                }
            }
            break;
        case string_:
            if (variable.isGlobal) {
                variable.register = sglobalsCount;
                sglobalsCount++;
            }
            else {
                if (currentFunction.sregisterAvailables.length) {
                    variable.register = currentFunction.sregisterAvailables[$ - 1];
                    currentFunction.sregisterAvailables.length--;
                }
                else {
                    variable.register = currentFunction.slocalsCount;
                    currentFunction.slocalsCount++;
                }
            }
            break;
        case list_:
        case class_:
        case foreign:
        case chan:
            if (variable.isGlobal) {
                variable.register = oglobalsCount;
                oglobalsCount++;
            }
            else {
                if (currentFunction.oregisterAvailables.length) {
                    variable.register = currentFunction.oregisterAvailables[$ - 1];
                    currentFunction.oregisterAvailables.length--;
                }
                else {
                    variable.register = currentFunction.olocalsCount;
                    currentFunction.olocalsCount++;
                }
            }
            break;
        case internalTuple:
        case reference:
        case null_:
        case void_:
            logError(format(getError(Error.cantDefVarOfTypeX),
                    getPrettyType(variable.type)), getError(Error.invalidType));
            break;
        }
    }

    /// Register a local variable
    private GrVariable registerLocalVariable(string name, GrType type) {
        //Check if declared globally
        assertNoGlobalDeclaration(name, get().fileId, false);

        GrVariable variable = new GrVariable;
        variable.isGlobal = false;
        variable.type = type;
        variable.name = name;
        variable.fileId = get().fileId;
        variable.lexPosition = current;

        currentFunction.setLocal(variable);
        if (variable.type.baseType != GrBaseType.void_)
            setVariableRegister(variable);

        return variable;
    }

    private void beginGlobalScope() {
        GrFunction globalScope = getFunction("@global", 0);
        if (globalScope) {
            functionStack ~= currentFunction;
            currentFunction = globalScope;
        }
        else {
            GrFunction func = new GrFunction;
            func.name = "@global";
            func.mangledName = func.name;
            func.isTask = false;
            func.inSignature = [];
            func.outSignature = [];
            func.isPublic = true;
            func.fileId = 0;
            func.lexPosition = 0;
            functions ~= func;
            functionStack ~= currentFunction;
            currentFunction = func;
        }
    }

    private void endGlobalScope() {
        if (!functionStack.length)
            throw new Exception("global scope mismatch");

        currentFunction = functionStack[$ - 1];
        functionStack.length--;
    }

    private void beginFunction(string name, uint fileId, GrType[] signature, bool isAction = false) {
        const string mangledName = grMangleComposite(name, signature);

        GrFunction func;
        if (isAction)
            func = getAction(mangledName);
        else
            func = getFunction(mangledName, fileId);

        if (func is null)
            logError(format(getError(Error.xNotDef), name), getError(Error.unknownFunc));

        functionStack ~= currentFunction;
        currentFunction = func;
    }

    private void preBeginFunction(string name, uint fileId, GrType[] signature,
        string[] inputVariables, bool isTask, GrType[] outSignature = [],
        bool isAnonymous = false, bool isAction = false, bool isPublic = false) {
        GrFunction func = new GrFunction;
        func.isTask = isTask;
        func.inputVariables = inputVariables;
        func.inSignature = signature;
        func.outSignature = outSignature;
        func.fileId = fileId;

        if (isAnonymous) {
            //func.index = cast(uint) anonymousFunctions.length;
            func.anonParent = currentFunction;
            func.anonReference = cast(uint) currentFunction.instructions.length;
            func.name = currentFunction.name ~ "@anon" ~ to!string(func.index);
            func.mangledName = grMangleComposite(func.name, func.inSignature);
            anonymousFunctions ~= func;
            func.lexPosition = current;

            //Is replaced by the addr of the function later (see solveFunctionCalls).
            addInstruction(GrOpcode.const_int, 0u);
        }
        else {
            //func.index = cast(uint) functions.length;
            func.name = name;
            func.isPublic = isPublic;

            func.mangledName = grMangleComposite(name, signature);
            assertNoGlobalDeclaration(func.mangledName, fileId, isPublic);

            func.isAction = isAction;
            func.lexPosition = current;
            functionsQueue ~= func;
        }

        functionStack ~= currentFunction;
        currentFunction = func;
        generateFunctionInputs();
    }

    private void endFunction() {
        int prependInstructionCount;
        if (_options & GrOption.profile) {
            prependInstructionCount++;
            const uint index = registerStringConstant(getPrettyFunction(currentFunction));
            addInstructionInFront(GrOpcode.debugProfileBegin, index);
        }

        if (currentFunction.ilocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_int, currentFunction.ilocalsCount);
            prependInstructionCount++;
        }

        if (currentFunction.flocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_float, currentFunction.flocalsCount);
            prependInstructionCount++;
        }

        if (currentFunction.slocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_string, currentFunction.slocalsCount);
            prependInstructionCount++;
        }

        if (currentFunction.olocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_object, currentFunction.olocalsCount);
            prependInstructionCount++;
        }

        foreach (call; currentFunction.functionCalls)
            call.position += prependInstructionCount;

        currentFunction.offset += prependInstructionCount;

        if (!functionStack.length)
            throw new Exception("attempting to close a non-existing function");

        currentFunction = functionStack[$ - 1];
        functionStack.length--;
    }

    private void preEndFunction() {
        if (!functionStack.length)
            throw new Exception("attempting to close a non-existing function");
        currentFunction = functionStack[$ - 1];
        functionStack.length--;
    }

    /// Generate opcodes to fetch the function or the task's parameters
    void generateFunctionInputs() {
        void fetchParameter(string name, GrType type) {
            final switch (type.baseType) with (GrBaseType) {
            case void_:
            case null_:
                logError(format(getError(Error.cantUseTypeAsParam),
                        getPrettyType(type)), getError(Error.invalidParamType));
                break;
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                currentFunction.nbIntegerParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_int, 0u);
                break;
            case float_:
                currentFunction.nbFloatParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_float, 0u);
                break;
            case string_:
                currentFunction.nbStringParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_string, 0u);
                break;
            case class_:
            case list_:
            case foreign:
            case chan:
            case reference:
                currentFunction.nbObjectParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_object, 0u);
                break;
            case internalTuple:
                throw new Exception("tuples are not allowed here");
            }

            GrVariable newVar = new GrVariable;
            newVar.type = type;
            newVar.isInitialized = true;
            newVar.isGlobal = false;
            newVar.name = name;
            newVar.fileId = get().fileId;
            newVar.lexPosition = current;
            currentFunction.setLocal(newVar);
            setVariableRegister(newVar);
            addSetInstruction(newVar, currentFunction.fileId);
        }

        foreach_reverse (size_t i, inputVariable; currentFunction.inputVariables) {
            fetchParameter(currentFunction.inputVariables[i], currentFunction.inSignature[i]);
        }
    }

    GrFunction getFunction(string mangledName, uint fileId = 0, bool isPublic = false) {
        foreach (GrFunction func; functions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                return func;
            }
        }
        return null;
    }

    GrFunction getFunction(string name, GrType[] signature, uint fileId = 0, bool isPublic = false) {
        const string mangledName = grMangleComposite(name, signature);
        foreach (GrFunction func; functions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                return func;
            }
        }
        foreach (GrFunction func; functions) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic))
                    return func;
            }
        }
        foreach (GrFunction func; functionsQueue) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                return func;
            }
        }
        foreach (GrFunction func; functionsQueue) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic))
                    return func;
            }
        }
        foreach (GrFunction func; instanciatedFunctions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                functionsQueue ~= func;

                functionStack ~= currentFunction;
                currentFunction = func;
                generateFunctionInputs();
                currentFunction = functionStack[$ - 1];
                functionStack.length--;

                return func;
            }
        }
        foreach (GrFunction func; instanciatedFunctions) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic)) {
                    functionsQueue ~= func;

                    functionStack ~= currentFunction;
                    currentFunction = func;
                    generateFunctionInputs();
                    currentFunction = functionStack[$ - 1];
                    functionStack.length--;

                    return func;
                }
            }
        }
        return null;
    }

    /// Remove a declared function
    void removeFunction(string name) {
        import std.algorithm : remove;

        for (int i; i < functions.length; ++i) {
            if (functions[i].mangledName == name) {
                functions = remove(functions, i);
                return;
            }
        }
    }

    private GrFunction getAction(string name) {
        foreach (GrFunction func; actions) {
            if (func.mangledName == name)
                return func;
        }
        return null;
    }

    private GrFunction getAnonymousFunction(string name) {
        foreach (GrFunction func; anonymousFunctions) {
            if (func.mangledName == name)
                return func;
        }
        return null;
    }

    GrFunction getAnonymousFunction(string name, GrType[] signature, uint fileId) {
        foreach (GrFunction func; anonymousFunctions) {
            if (func.mangledName == name)
                return func;
        }
        foreach (GrFunction func; anonymousFunctions) {
            if (func.name == name) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId))
                    return func;
            }
        }
        return null;
    }

    /// Retrieve a declared variable
    private GrVariable getVariable(string name, uint fileId) {
        GrVariable globalVar = getGlobalVariable(name, fileId);
        if (globalVar !is null)
            return globalVar;

        GrVariable localVar = currentFunction.getLocal(name);
        if (!localVar)
            logError(format(getError(Error.xNotDecl), name), getError(Error.unknownVar), "", -1);
        return localVar;
    }

    private void addIntConstant(GrInt value) {
        addInstruction(GrOpcode.const_int, registerIntConstant(value));
    }

    private void addFloatConstant(GrFloat value) {
        addInstruction(GrOpcode.const_float, registerFloatConstant(value));
    }

    private void addBoolConstant(bool value) {
        addInstruction(GrOpcode.const_bool, value);
    }

    private void addStringConstant(GrString value) {
        addInstruction(GrOpcode.const_string, registerStringConstant(value));
    }

    private void addMetaConstant(GrString value) {
        addInstruction(GrOpcode.const_meta, registerStringConstant(value));
    }

    private void addInstruction(GrOpcode opcode, int value = 0, bool isSigned = false) {
        if (currentFunction is null)
            throw new Exception(
                "the expression is located outside of a function or task, which is forbidden");

        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;
        currentFunction.instructions ~= instruction;

        if (_options & GrOption.symbols) {
            generateInstructionSymbol();
        }
    }

    private void addInstructionInFront(GrOpcode opcode, int value = 0, bool isSigned = false) {
        if (currentFunction is null)
            throw new Exception(
                "the expression is located outside of a function or task, which is forbidden");

        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;
        currentFunction.instructions = instruction ~ currentFunction.instructions;

        if (_options & GrOption.symbols) {
            generateInstructionSymbol();
        }
    }

    private void generateInstructionSymbol() {
        GrFunction.DebugPositionSymbol symbol;
        int lexPos = (cast(int) current) - 2;
        if (lexPos < 0) {
            lexPos = 0;
        }
        if (lexPos >= cast(uint) lexemes.length) {
            lexPos = cast(uint)((cast(int) lexemes.length) - 1);
        }
        GrLexeme lex = lexemes[lexPos];
        symbol.line = lex.line + 1;
        symbol.column = lex.column;
        currentFunction.debugSymbol ~= symbol;
    }

    private void setInstruction(GrOpcode opcode, uint index, int value = 0u, bool isSigned = false) {
        if (currentFunction is null)
            throw new Exception(
                "the expression is located outside of a function or task, which is forbidden");

        if (index >= currentFunction.instructions.length)
            throw new Exception("an instruction's index is exeeding the function size");

        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;
        currentFunction.instructions[index] = instruction;
    }

    private bool isBinaryOperator(GrLexemeType lexType) {
        if (lexType >= GrLexemeType.bitwiseAnd && lexType <= GrLexemeType.arrow)
            return true;
        else if (lexType == GrLexemeType.send)
            return true;
        else
            return false;
    }

    private bool isUnaryOperator(GrLexemeType lexType) {
        if (lexType >= GrLexemeType.plus && lexType <= GrLexemeType.minus)
            return true;
        else if (lexType >= GrLexemeType.increment && lexType <= GrLexemeType.decrement)
            return true;
        else if (lexType == GrLexemeType.not || lexType == GrLexemeType.bitwiseNot)
            return true;
        else if (lexType == GrLexemeType.receive)
            return true;
        else
            return false;
    }

    private GrType addCustomBinaryOperator(GrLexemeType lexType, GrType leftType,
        GrType rightType, uint fileId) {
        string name = "@op_" ~ getPrettyLexemeType(lexType);
        GrType[] signature = [leftType, rightType];

        //GrPrimitive check
        const GrPrimitive primitive = _data.getPrimitive(name, signature);
        if (primitive) {
            addInstruction(GrOpcode.primitiveCall, primitive.index);
            if (primitive.outSignature.length != 1uL) {
                logError(getError(Error.opMustHave1RetVal), format(getError(primitive.outSignature.length > 1
                        ? Error.expected1RetValFoundX : Error.expected1RetValFoundXs),
                        primitive.outSignature.length));
            }
            return primitive.outSignature[0];
        }

        //GrFunction check
        GrFunction func = getFunction(name, signature, fileId);
        if (func) {
            auto outSignature = addFunctionCall(func, fileId);
            if (outSignature.length != 1uL) {
                logError(getError(Error.opMustHave1RetVal), format(getError(primitive.outSignature.length > 1
                        ? Error.expected1RetValFoundX : Error.expected1RetValFoundXs),
                        primitive.outSignature.length));
            }
            return outSignature[0];
        }

        return grVoid;
    }

    private GrType addCustomUnaryOperator(GrLexemeType lexType, const GrType type, uint fileId) {
        string name = "@op_" ~ getPrettyLexemeType(lexType);
        GrType[] signature = [type];

        //GrPrimitive check
        const GrPrimitive primitive = _data.getPrimitive(name, signature);
        if (primitive) {
            addInstruction(GrOpcode.primitiveCall, primitive.index);
            if (primitive.outSignature.length != 1uL) {
                logError(getError(Error.opMustHave1RetVal), format(getError(primitive.outSignature.length > 1
                        ? Error.expected1RetValFoundX : Error.expected1RetValFoundXs),
                        primitive.outSignature.length));
            }
            return primitive.outSignature[0];
        }

        //GrFunction check
        GrFunction func = getFunction(name, signature, fileId);
        if (func) {
            auto outSignature = addFunctionCall(func, fileId);
            if (outSignature.length != 1uL) {
                logError(getError(Error.opMustHave1RetVal), format(getError(primitive.outSignature.length > 1
                        ? Error.expected1RetValFoundX : Error.expected1RetValFoundXs),
                        primitive.outSignature.length));
            }
            return outSignature[0];
        }

        return grVoid;
    }

    private GrType addBinaryOperator(GrLexemeType lexType, const GrType leftType,
        const GrType rightType, uint fileId) {
        if (leftType.baseType == GrBaseType.internalTuple
            || rightType.baseType == GrBaseType.internalTuple)
            logError(getError(Error.cantUseOpOnMultipleVal), getError(Error.exprYieldsMultipleVal));
        GrType resultType = GrBaseType.void_;

        if (leftType.baseType == GrBaseType.enum_ && rightType.baseType == GrBaseType.enum_
            && leftType.mangledType == rightType.mangledType) {
            resultType = addInternalOperator(lexType, leftType);
        }
        else if (leftType.baseType == GrBaseType.chan) {
            GrType chanType = grUnmangle(leftType.mangledType);
            convertType(rightType, chanType, fileId);
            resultType = addInternalOperator(lexType, leftType);
            if (resultType.baseType == GrBaseType.void_) {
                resultType = addCustomBinaryOperator(lexType, leftType, rightType, fileId);
            }
        }
        else if (lexType == GrLexemeType.concatenate
            && leftType.baseType == GrBaseType.list_ && leftType != rightType) {
            const GrType subType = grUnmangle(leftType.mangledType);
            convertType(rightType, subType, fileId);
            final switch (subType.baseType) with (GrBaseType) {
            case int_:
            case bool_:
            case enum_:
            case function_:
            case task:
                addInstruction(GrOpcode.append_int);
                break;
            case float_:
                addInstruction(GrOpcode.append_float);
                break;
            case string_:
                addInstruction(GrOpcode.append_string);
                break;
            case class_:
            case list_:
            case foreign:
            case chan:
                addInstruction(GrOpcode.append_object);
                break;
            case null_:
            case void_:
            case reference:
            case internalTuple:
                break;
            }
            resultType = leftType;
        }
        else if (lexType == GrLexemeType.concatenate
            && rightType.baseType == GrBaseType.list_ && leftType != rightType) {
            const GrType subType = grUnmangle(rightType.mangledType);
            convertType(leftType, subType, fileId);
            final switch (subType.baseType) with (GrBaseType) {
            case int_:
            case bool_:
            case enum_:
            case function_:
            case task:
                addInstruction(GrOpcode.prepend_int);
                break;
            case float_:
                addInstruction(GrOpcode.prepend_float);
                break;
            case string_:
                addInstruction(GrOpcode.prepend_string);
                break;
            case class_:
            case list_:
            case foreign:
            case chan:
                addInstruction(GrOpcode.prepend_object);
                break;
            case null_:
            case void_:
            case reference:
            case internalTuple:
                break;
            }
            resultType = rightType;
        }
        else if (lexType == GrLexemeType.concatenate
            && leftType.baseType == GrBaseType.string_ && leftType != rightType) {
            convertType(rightType, leftType, fileId);
            resultType = addInternalOperator(lexType, leftType);
        }
        else if (lexType == GrLexemeType.concatenate
            && rightType.baseType == GrBaseType.string_ && leftType != rightType) {
            convertType(leftType, rightType, fileId);
            resultType = addInternalOperator(lexType, rightType, true);
        }
        else if (leftType.baseType == GrBaseType.int_ && rightType.baseType == GrBaseType.float_) {
            // Special case, we need to convert int to float, then swap the 2 values when needed.
            convertType(leftType, rightType, fileId);
            resultType = addInternalOperator(lexType, rightType, true);
        }
        else if (leftType != rightType) {
            //Check custom operator
            resultType = addCustomBinaryOperator(lexType, leftType, rightType, fileId);

            //If there is no custom operator defined, we try to convert and then try again
            if (resultType.baseType == GrBaseType.void_) {
                resultType = convertType(rightType, leftType, fileId, true);
                if (resultType.baseType != GrBaseType.void_) {
                    resultType = addBinaryOperator(lexType, resultType, resultType, fileId);
                }
            }
        }
        else {
            resultType = addInternalOperator(lexType, leftType);
            if (resultType.baseType == GrBaseType.void_) {
                resultType = addCustomBinaryOperator(lexType, leftType, rightType, fileId);
            }
        }
        if (resultType.baseType == GrBaseType.void_)
            logError(format(getError(Error.noXBinaryOpDefForYAndZ), getPrettyLexemeType(lexType),
                    getPrettyType(leftType), getPrettyType(rightType)),
                getError(Error.unknownOp), "", -1);
        return resultType;
    }

    private GrType addUnaryOperator(GrLexemeType lexType, const GrType type, uint fileId) {
        if (type.baseType == GrBaseType.internalTuple)
            logError(getError(Error.cantUseOpOnMultipleVal), getError(Error.exprYieldsMultipleVal));
        GrType resultType = GrBaseType.void_;

        resultType = addInternalOperator(lexType, type);
        if (resultType.baseType == GrBaseType.void_) {
            resultType = addCustomUnaryOperator(lexType, type, fileId);
        }

        if (resultType.baseType == GrBaseType.void_)
            logError(format(getError(Error.noXUnaryOpDefForY), getPrettyLexemeType(lexType),
                    getPrettyType(type)), getError(Error.unknownOp));
        return resultType;
    }

    private GrType addOperator(GrLexemeType lexType, ref GrType[] typeStack, uint fileId) {
        if (isBinaryOperator(lexType)) {
            typeStack[$ - 2] = addBinaryOperator(lexType, typeStack[$ - 2],
                typeStack[$ - 1], fileId);
            typeStack.length--;
            return typeStack[$ - 1];
        }
        else if (isUnaryOperator(lexType)) {
            typeStack[$ - 1] = addUnaryOperator(lexType, typeStack[$ - 1], fileId);
            return typeStack[$ - 1];
        }

        return GrType(GrBaseType.void_);
    }

    private GrType addInternalOperator(GrLexemeType lexType, GrType varType, bool isSwapped = false) {
        switch (varType.baseType) with (GrBaseType) {
        case class_:
        case foreign:
            switch (lexType) with (GrLexemeType) {
            case not:
                addInstruction(GrOpcode.isNonNull_object);
                addInstruction(GrOpcode.not_int);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case enum_:
            switch (lexType) with (GrLexemeType) {
            case equal:
                addInstruction(GrOpcode.equal_int);
                return GrType(GrBaseType.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_int);
                return GrType(GrBaseType.bool_);
            case greater:
                addInstruction(GrOpcode.greater_int);
                return GrType(GrBaseType.bool_);
            case greaterOrEqual:
                addInstruction(GrOpcode.greaterOrEqual_int);
                return GrType(GrBaseType.bool_);
            case lesser:
                addInstruction(GrOpcode.lesser_int);
                return GrType(GrBaseType.bool_);
            case lesserOrEqual:
                addInstruction(GrOpcode.lesserOrEqual_int);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case bool_:
            switch (lexType) with (GrLexemeType) {
            case and:
                addInstruction(GrOpcode.and_int);
                return GrType(GrBaseType.bool_);
            case or:
                addInstruction(GrOpcode.or_int);
                return GrType(GrBaseType.bool_);
            case not:
                addInstruction(GrOpcode.not_int);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case int_:
            switch (lexType) with (GrLexemeType) {
            case add:
                addInstruction(GrOpcode.add_int);
                return GrType(GrBaseType.int_);
            case substract:
                addInstruction(GrOpcode.substract_int);
                return GrType(GrBaseType.int_);
            case multiply:
                addInstruction(GrOpcode.multiply_int);
                return GrType(GrBaseType.int_);
            case divide:
                addInstruction(GrOpcode.divide_int);
                return GrType(GrBaseType.int_);
            case remainder:
                addInstruction(GrOpcode.remainder_int);
                return GrType(GrBaseType.int_);
            case minus:
                addInstruction(GrOpcode.negative_int);
                return GrType(GrBaseType.int_);
            case plus:
                return GrType(GrBaseType.int_);
            case increment:
                addInstruction(GrOpcode.increment_int);
                return GrType(GrBaseType.int_);
            case decrement:
                addInstruction(GrOpcode.decrement_int);
                return GrType(GrBaseType.int_);
            case equal:
                addInstruction(GrOpcode.equal_int);
                return GrType(GrBaseType.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_int);
                return GrType(GrBaseType.bool_);
            case greater:
                addInstruction(GrOpcode.greater_int);
                return GrType(GrBaseType.bool_);
            case greaterOrEqual:
                addInstruction(GrOpcode.greaterOrEqual_int);
                return GrType(GrBaseType.bool_);
            case lesser:
                addInstruction(GrOpcode.lesser_int);
                return GrType(GrBaseType.bool_);
            case lesserOrEqual:
                addInstruction(GrOpcode.lesserOrEqual_int);
                return GrType(GrBaseType.bool_);
            case not:
                addInstruction(GrOpcode.not_int);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case float_:
            switch (lexType) with (GrLexemeType) {
            case add:
                addInstruction(GrOpcode.add_float);
                return GrType(GrBaseType.float_);
            case substract:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_float);
                addInstruction(GrOpcode.substract_float);
                return GrType(GrBaseType.float_);
            case multiply:
                addInstruction(GrOpcode.multiply_float);
                return GrType(GrBaseType.float_);
            case divide:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_float);
                addInstruction(GrOpcode.divide_float);
                return GrType(GrBaseType.float_);
            case remainder:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_float);
                addInstruction(GrOpcode.remainder_float);
                return GrType(GrBaseType.float_);
            case minus:
                addInstruction(GrOpcode.negative_float);
                return GrType(GrBaseType.float_);
            case plus:
                return GrType(GrBaseType.float_);
            case increment:
                addInstruction(GrOpcode.increment_float);
                return GrType(GrBaseType.float_);
            case decrement:
                addInstruction(GrOpcode.decrement_float);
                return GrType(GrBaseType.float_);
            case equal:
                addInstruction(GrOpcode.equal_float);
                return GrType(GrBaseType.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_float);
                return GrType(GrBaseType.bool_);
            case greater:
                if (isSwapped)
                    addInstruction(GrOpcode.lesserOrEqual_float);
                else
                    addInstruction(GrOpcode.greater_float);
                return GrType(GrBaseType.bool_);
            case greaterOrEqual:
                if (isSwapped)
                    addInstruction(GrOpcode.lesser_float);
                else
                    addInstruction(GrOpcode.greaterOrEqual_float);
                return GrType(GrBaseType.bool_);
            case lesser:
                if (isSwapped)
                    addInstruction(GrOpcode.greaterOrEqual_float);
                else
                    addInstruction(GrOpcode.lesser_float);
                return GrType(GrBaseType.bool_);
            case lesserOrEqual:
                if (isSwapped)
                    addInstruction(GrOpcode.greater_float);
                else
                    addInstruction(GrOpcode.lesserOrEqual_float);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case string_:
            switch (lexType) with (GrLexemeType) {
            case concatenate:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_string);
                addInstruction(GrOpcode.concatenate_string);
                return GrType(GrBaseType.string_);
            case equal:
                addInstruction(GrOpcode.equal_string);
                return GrType(GrBaseType.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_string);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case list_:
            switch (lexType) with (GrLexemeType) {
            case equal:
                const GrType subType = grUnmangle(varType.mangledType);
                final switch (subType.baseType) with (GrBaseType) {
                case int_:
                case bool_:
                case enum_:
                case function_:
                case task:
                    addInstruction(GrOpcode.equal_intList);
                    return grBool;
                case float_:
                    addInstruction(GrOpcode.equal_floatList);
                    return grBool;
                case string_:
                    addInstruction(GrOpcode.equal_stringList);
                    return grBool;
                case null_:
                case void_:
                case reference:
                case internalTuple:
                case list_:
                case class_:
                case foreign:
                case chan:
                    break;
                }
                break;
            case notEqual:
                const GrType subType = grUnmangle(varType.mangledType);
                final switch (subType.baseType) with (GrBaseType) {
                case int_:
                case bool_:
                case enum_:
                case function_:
                case task:
                    addInstruction(GrOpcode.notEqual_intList);
                    return grBool;
                case float_:
                    addInstruction(GrOpcode.notEqual_floatList);
                    return grBool;
                case string_:
                    addInstruction(GrOpcode.notEqual_stringList);
                    return grBool;
                case null_:
                case void_:
                case reference:
                case internalTuple:
                case list_:
                case class_:
                case foreign:
                case chan:
                    break;
                }
                break;
            case concatenate:
                const GrType subType = grUnmangle(varType.mangledType);
                final switch (subType.baseType) with (GrBaseType) {
                case int_:
                case bool_:
                case enum_:
                case function_:
                case task:
                    addInstruction(GrOpcode.concatenate_intList);
                    return varType;
                case float_:
                    addInstruction(GrOpcode.concatenate_floatList);
                    return varType;
                case string_:
                    addInstruction(GrOpcode.concatenate_stringList);
                    return varType;
                case class_:
                case list_:
                case foreign:
                case chan:
                    addInstruction(GrOpcode.concatenate_objectList);
                    return varType;
                case null_:
                case void_:
                case reference:
                case internalTuple:
                    break;
                }
                break;
            default:
                break;
            }
            break;
        case chan:
            switch (lexType) with (GrLexemeType) {
            case send:
                GrType chanType = grUnmangle(varType.mangledType);
                final switch (chanType.baseType) with (GrBaseType) {
                case int_:
                case bool_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.send_int);
                    return chanType;
                case float_:
                    addInstruction(GrOpcode.send_float);
                    return chanType;
                case string_:
                    addInstruction(GrOpcode.send_string);
                    return chanType;
                case class_:
                case list_:
                case foreign:
                case chan:
                    addInstruction(GrOpcode.send_object);
                    return chanType;
                case void_:
                case null_:
                case internalTuple:
                case reference:
                    break;
                }
                break;
            case receive:
                GrType chanType = grUnmangle(varType.mangledType);
                final switch (chanType.baseType) with (GrBaseType) {
                case int_:
                case bool_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.receive_int);
                    return chanType;
                case float_:
                    addInstruction(GrOpcode.receive_float);
                    return chanType;
                case string_:
                    addInstruction(GrOpcode.receive_string);
                    return chanType;
                case class_:
                case list_:
                case foreign:
                case chan:
                    addInstruction(GrOpcode.receive_object);
                    return chanType;
                case void_:
                case null_:
                case internalTuple:
                case reference:
                    break;
                }
                break;
            default:
                break;
            }
            break;
        default:
            break;
        }
        return GrType(GrBaseType.void_);
    }

    private void addSetInstruction(GrVariable variable, uint fileId,
        GrType valueType = grVoid, bool isExpectingValue = false) {
        _isAssignationOptimizable = true;
        if (variable.isConstant)
            logError(format(getError(Error.xIsConstAndCantBeModified), variable.name),
                format(getError(Error.cantModifyAConstX), getPrettyType(variable.type)));
        if (variable.type.baseType == GrBaseType.reference) {
            valueType = convertType(valueType, grUnmangle(variable.type.mangledType), fileId);
            final switch (valueType.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case chan:
            case enum_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_int : GrOpcode.refStore_int);
                break;
            case float_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_float : GrOpcode
                        .refStore_float);
                break;
            case string_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_string
                        : GrOpcode.refStore_string);
                break;
            case class_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_object
                        : GrOpcode.refStore_object);
                break;
            case list_:
            case foreign:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_object
                        : GrOpcode.refStore_object);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError(format(getError(Error.cantAssignToAXVar),
                        getPrettyType(variable.type)), getError(Error.ValNotAssignable));
            }
            return;
        }

        if (variable.isAuto && !variable.isInitialized) {
            variable.isInitialized = true;
            variable.isAuto = false;
            variable.type = valueType;
            if (valueType.baseType == GrBaseType.void_)
                logError(getError(Error.cantInferTypeOfVar), getError(Error.varNotInit));
            else
                setVariableRegister(variable);
        }

        if (valueType.baseType != GrBaseType.void_)
            convertType(valueType, variable.type, fileId);

        //if(!variable.isInitialized && isExpectingValue)
        //    logError("Uninitialized variable", "The variable is being used without being assigned");
        variable.isInitialized = true;

        if (variable.isField) {
            final switch (variable.type.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(GrOpcode.fieldStore_int, isExpectingValue ? 0 : -1, true);
                break;
            case float_:
                addInstruction(GrOpcode.fieldStore_float, isExpectingValue ? 0 : -1, true);
                break;
            case string_:
                addInstruction(GrOpcode.fieldStore_string, isExpectingValue ? 0 : -1, true);
                break;
            case foreign:
            case reference:
            case chan:
            case list_:
            case class_:
                addInstruction(GrOpcode.fieldStore_object, isExpectingValue ? 0 : -1, true);
                break;
            case void_:
            case null_:
            case internalTuple:
                logError(format(getError(Error.cantAssignToAXVar),
                        getPrettyType(variable.type)), getError(Error.ValNotAssignable));
            }
        }
        else if (variable.isGlobal) {
            final switch (variable.type.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_int
                        : GrOpcode.globalStore_int, variable.register);
                break;
            case float_:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_float
                        : GrOpcode.globalStore_float, variable.register);
                break;
            case string_:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_string
                        : GrOpcode.globalStore_string, variable.register);
                break;
            case chan:
            case class_:
            case list_:
            case foreign:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_object
                        : GrOpcode.globalStore_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError(format(getError(Error.cantAssignToAXVar),
                        getPrettyType(variable.type)), getError(Error.ValNotAssignable));
            }
        }
        else {
            final switch (variable.type.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_int
                        : GrOpcode.localStore_int, variable.register);
                break;
            case float_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_float
                        : GrOpcode.localStore_float, variable.register);
                break;
            case string_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_string
                        : GrOpcode.localStore_string, variable.register);
                break;
            case class_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_object
                        : GrOpcode.localStore_object, variable.register);
                break;
            case list_:
            case foreign:
            case chan:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_object
                        : GrOpcode.localStore_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError(format(getError(Error.cantAssignToAXVar),
                        getPrettyType(variable.type)), getError(Error.ValNotAssignable));
            }
        }
    }

    ///Add a load opcode, or optimize a previous store.
    void addGetInstruction(GrVariable variable, GrType expectedType = grVoid,
        bool allowOptimization = true) {
        if (!_isAssignationOptimizable) {
            /+--------------------------
                Optimizing getters should take care of scope levels as jumps will break the VM.
                This shouldn't be optimized as the stack will be empty on the second pass.
                "function foo() {
                    bool a = true;
                    loop {
                        if(a) {}  //a is just after a = true, so will be optimized.
                        yield;
                    } //We jump back to the loop where lstore2 is, crashing the VM.
                }"
                To avoid that, we disallow optimization of different scope levels.
            -------------------------+/
            allowOptimization = false;
        }

        if (variable.isField) {
            throw new Exception("attempt to get field value");
        }
        else if (variable.isGlobal) {
            final switch (variable.type.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_int
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_int;
                else
                    addInstruction(GrOpcode.globalLoad_int, variable.register);
                break;
            case float_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_float
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_float;
                else
                    addInstruction(GrOpcode.globalLoad_float, variable.register);
                break;
            case string_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_string
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_string;
                else
                    addInstruction(GrOpcode.globalLoad_string, variable.register);
                break;
            case class_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_object;
                else
                    addInstruction(GrOpcode.globalLoad_object, variable.register);
                break;
            case list_:
            case foreign:
            case chan:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_object;
                else
                    addInstruction(GrOpcode.globalLoad_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError(format(getError(Error.cantGetValueOfX),
                        getPrettyType(variable.type)), getError(Error.valNotFetchable));
            }
        }
        else {
            if (!variable.isInitialized)
                logError(getError(Error.locVarUsedNotAssigned), getError(Error.varNotInit));

            final switch (variable.type.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_int
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_int;
                else
                    addInstruction(GrOpcode.localLoad_int, variable.register);
                break;
            case float_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_float
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_float;
                else
                    addInstruction(GrOpcode.localLoad_float, variable.register);
                break;
            case string_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_string
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_string;
                else
                    addInstruction(GrOpcode.localLoad_string, variable.register);
                break;
            case class_:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_object;
                else
                    addInstruction(GrOpcode.localLoad_object, variable.register);
                break;
            case list_:
            case foreign:
            case chan:
                if (allowOptimization && currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_object
                    && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_object;
                else
                    addInstruction(GrOpcode.localLoad_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError(format(getError(Error.cantGetValueOfX),
                        getPrettyType(variable.type)), getError(Error.valNotFetchable));
            }
        }
    }

    private GrType addFunctionAddress(string name, GrType[] signature, uint fileId) {
        if (name == "@global")
            return grVoid;
        GrFunctionCall call = new GrFunctionCall;
        call.name = name;
        call.signature = signature;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = true;
        auto func = getFunction(name, signature, fileId);
        if (func is null)
            func = getAnonymousFunction(name, signature, fileId);
        if (func !is null) {
            call.functionToCall = func;
            call.position = cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.const_int, 0);

            return grGetFunctionAsType(func);
        }
        return grVoid;
    }

    private GrType addFunctionAddress(GrFunction func, uint fileId) {
        if (func.name == "@global")
            return grVoid;
        GrFunctionCall call = new GrFunctionCall;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = true;
        call.functionToCall = func;
        call.position = cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.const_int, 0);
        return grGetFunctionAsType(func);
    }

    private GrType[] addFunctionCall(string name, GrType[] signature, uint fileId) {
        GrFunctionCall call = new GrFunctionCall;
        call.name = name;
        call.signature = signature;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = false;
        call.fileId = fileId;

        GrFunction func = getFunction(name, signature, call.fileId, false);
        if (func) {
            call.functionToCall = func;
            if (func.isTask) {
                if (func.nbIntegerParameters > 0)
                    addInstruction(GrOpcode.globalPush_int, func.nbIntegerParameters);
                if (func.nbFloatParameters > 0)
                    addInstruction(GrOpcode.globalPush_float, func.nbFloatParameters);
                if (func.nbStringParameters > 0)
                    addInstruction(GrOpcode.globalPush_string, func.nbStringParameters);
                if (func.nbObjectParameters > 0)
                    addInstruction(GrOpcode.globalPush_object, func.nbObjectParameters);
            }

            call.position = cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.call, 0);

            return func.outSignature;
        }
        else
            logError(format(getError(Error.xNotDecl), getPrettyFunctionCall(name,
                    signature)), getError(Error.unknownFunc), "", -1);

        return [];
    }

    private GrType[] addFunctionCall(GrFunction func, uint fileId) {
        GrFunctionCall call = new GrFunctionCall;
        call.name = func.name;
        call.signature = func.inSignature;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = false;
        call.fileId = fileId;

        call.functionToCall = func;
        if (func.isTask) {
            if (func.nbIntegerParameters > 0)
                addInstruction(GrOpcode.globalPush_int, func.nbIntegerParameters);
            if (func.nbFloatParameters > 0)
                addInstruction(GrOpcode.globalPush_float, func.nbFloatParameters);
            if (func.nbStringParameters > 0)
                addInstruction(GrOpcode.globalPush_string, func.nbStringParameters);
            if (func.nbObjectParameters > 0)
                addInstruction(GrOpcode.globalPush_object, func.nbObjectParameters);
        }

        call.position = cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.call, 0);

        return func.outSignature;
    }

    private void setOpcode(ref uint[] opcodes, uint position, GrOpcode opcode,
        uint value = 0u, bool isSigned = false) {
        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;

        uint makeOpcode(uint instr, uint value) {
            return ((value << 8u) & 0xffffff00) | (instr & 0xff);
        }

        opcodes[position] = makeOpcode(cast(uint) instruction.opcode, instruction.value);
    }

    package void solveFunctionCalls(ref uint[] opcodes) {
        foreach (GrFunctionCall call; functionCalls) {
            GrFunction func = call.functionToCall;
            if (!func)
                func = getFunction(call.name, call.signature, call.fileId);
            if (!func)
                func = getAnonymousFunction(call.name, call.signature, call.fileId);
            if (func) {
                if (call.isAddress)
                    setOpcode(opcodes, call.position, GrOpcode.const_int,
                        registerIntConstant(func.position));
                else if (func.isTask)
                    setOpcode(opcodes, call.position, GrOpcode.task, func.position);
                else
                    setOpcode(opcodes, call.position, GrOpcode.call, func.position);
            }
            else
                logError(format(getError(Error.xNotDecl), getPrettyFunctionCall(call.name,
                        call.signature)), getError(Error.unknownFunc));
        }

        foreach (func; anonymousFunctions)
            setOpcode(opcodes, func.anonParent.position + func.anonParent.offset + func.anonReference,
                GrOpcode.const_int, registerIntConstant(func.position));
    }

    package void dump() {
        writeln("Code Generated:\n");
        foreach (size_t i, GrInt ivalue; iconsts)
            writeln(".iconst " ~ to!string(ivalue) ~ "\t;" ~ to!string(i));

        foreach (size_t i, GrFloat fvalue; fconsts)
            writeln(".fconst " ~ to!string(fvalue) ~ "\t;" ~ to!string(i));

        foreach (size_t i, GrString svalue; sconsts)
            writeln(".sconst " ~ to!string(svalue) ~ "\t;" ~ to!string(i));

        foreach (GrFunction func; functions) {
            if (func.isTask)
                writeln("\n.task " ~ func.name);
            else
                writeln("\n.function " ~ func.name);

            foreach (size_t i, GrInstruction instruction; func.instructions) {
                writeln("[" ~ to!string(i) ~ "] " ~ to!string(
                        instruction.opcode) ~ " " ~ to!string(instruction.value));
            }
        }
    }

    package void parseScript(GrData data, GrLexer lexer, int options) {
        _data = data;
        _options = options;

        bool isPublic;
        lexemes = lexer.lexemes;

        beginGlobalScope();
        foreach (GrVariableDefinition variableDef; _data._variableDefinitions) {
            GrVariable variable = registerGlobalVariable(variableDef.name,
                variableDef.type, false, true);
            variable.isConstant = variableDef.isConstant;
            variableDef.register = variable.register;
        }
        endGlobalScope();

        //Type definitions
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexemeType.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexemeType) {
            case semicolon:
                checkAdvance();
                break;
            case class_:
                registerClassDeclaration(isPublic);
                break;
            case enum_:
                parseEnumDeclaration(isPublic);
                break;
            case action:
            case taskType:
            case functionType:
                skipDeclaration();
                break;
            case type_:
            case template_:
            default:
                skipExpression();
                break;
            }
        }

        //Type aliases
        reset();
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexemeType.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexemeType) {
            case semicolon:
                checkAdvance();
                break;
            case type_:
                parseTypeAliasDeclaration(isPublic);
                break;
            case action:
            case taskType:
            case functionType:
            case class_:
            case enum_:
                skipDeclaration();
                break;
            case template_:
            default:
                skipExpression();
                break;
            }
        }

        //Function definitions
        reset();
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexemeType.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexemeType) {
            case semicolon:
                checkAdvance();
                break;
            case enum_:
            case class_:
                skipDeclaration();
                break;
            case action:
                parseActionDeclaration(isPublic);
                break;
            case taskType:
                if (get(1).type != GrLexemeType.identifier && get(1).type != GrLexemeType.lesser)
                    goto case intType;
                parseTaskDeclaration(isPublic);
                break;
            case functionType:
                if (get(1).type != GrLexemeType.identifier && !get(1)
                    .isOperator && get(1).type != GrLexemeType.as && get(1)
                    .type != GrLexemeType.lesser)
                    goto case intType;
                parseFunctionDeclaration(isPublic);
                break;
            case intType: .. case chanType:
            case autoType:
            case identifier:
            case type_:
            case template_:
                skipExpression();
                break;
            default:
                logError(getError(Error.globalDeclExpected),
                    format(getError(Error.globalDeclExpectedFoundX), getPrettyLexemeType(get()
                        .type)));
            }
        }

        //Global variable definitions
        reset();
        beginGlobalScope();
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexemeType.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexemeType) {
            case semicolon:
                checkAdvance();
                break;
            case action:
            case enum_:
            case class_:
                skipDeclaration();
                break;
            case template_:
                parseTemplateDeclaration(isPublic);
                break;
            case taskType:
                if (get(1).type != GrLexemeType.identifier && get(1).type != GrLexemeType.lesser)
                    goto case intType;
                skipDeclaration();
                break;
            case functionType:
                if (get(1).type != GrLexemeType.identifier && !get(1)
                    .isOperator && get(1).type != GrLexemeType.as && get(1)
                    .type != GrLexemeType.lesser)
                    goto case intType;
                skipDeclaration();
                break;
            case intType: .. case chanType:
            case autoType:
                parseGlobalDeclaration(isPublic);
                break;
            case identifier:
                if (_data.isTypeDeclared(get().svalue, get().fileId, false)) {
                    parseGlobalDeclaration(isPublic);
                    break;
                }
                goto default;
            case type_:
                skipExpression();
                break;
            default:
                logError(getError(Error.globalDeclExpected),
                    format(getError(Error.globalDeclExpectedFoundX), getPrettyLexemeType(get()
                        .type)));
            }
        }
        endGlobalScope();

        while (functionsQueue.length) {
            GrFunction func = functionsQueue[$ - 1];
            functionsQueue.length--;
            parseFunction(func);
        }
    }

    /**
    Parse the body of global functions
    */
    void parseFunction(GrFunction func) {
        if (func.isAction) {
            func.index = cast(uint) actions.length;
            actions ~= func;
        }
        else {
            func.index = cast(uint) functions.length;
            functions ~= func;
        }

        functionStack ~= currentFunction;
        currentFunction = func;

        for (int i; i < func.templateVariables.length; ++i) {
            _data.addTemplateAlias(func.templateVariables[i],
                func.templateSignature[i], func.fileId, func.isPublic);
        }

        openDeferrableSection();
        current = func.lexPosition;
        parseBlock();
        if (func.isTask || func.isAction) {
            if (!currentFunction.instructions.length
                || currentFunction.instructions[$ - 1].opcode != GrOpcode.kill_)
                addKill();
        }
        else {
            if (!currentFunction.outSignature.length) {
                if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    addReturn();
            }
            else {
                if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    logError(getError(Error.funcMissingRetAtEnd), getError(Error.missingRet));
            }
        }
        closeDeferrableSection();
        registerDeferBlocks();

        endFunction();
        _data.clearTemplateAliases();
    }

    /**
    Declare a new alias of a type.
    */
    private void parseTypeAliasDeclaration(bool isPublic) {
        const uint fileId = get().fileId;
        checkAdvance();
        if (get().type != GrLexemeType.identifier)
            logError(format(getError(Error.expectedTypeAliasNameFoundX),
                    getPrettyLexemeType(get().type)), getError(Error.missingIdentifier));
        const string typeAliasName = get().svalue;
        checkAdvance();
        if (get().type != GrLexemeType.assign)
            logError(getError(Error.missingAssignInType),
                format(getError(Error.expectedXFoundY), "=", getPrettyLexemeType(get().type)));
        checkAdvance();
        GrType type = parseType(true);
        if (get().type != GrLexemeType.semicolon)
            logError(getError(Error.missingSemicolonAfterType),
                format(getError(Error.expectedXFoundY), ";", getPrettyLexemeType(get().type)));

        if (_data.isTypeDeclared(typeAliasName, fileId, isPublic))
            logError(format(getError(Error.nameXDefMultipleTimes), typeAliasName),
                format(getError(Error.alreadyDef), typeAliasName));
        _data.addTypeAlias(typeAliasName, type, fileId, isPublic);
    }

    private void parseEnumDeclaration(bool isPublic) {
        const uint fileId = get().fileId;
        checkAdvance();
        if (get().type != GrLexemeType.identifier)
            logError(format(getError(Error.expectedEnumNameFoundX),
                    getPrettyLexemeType(get().type)), getError(Error.missingIdentifier));
        const string enumName = get().svalue;
        checkAdvance();
        if (get().type != GrLexemeType.leftCurlyBrace)
            logError(getError(Error.enumDefNotHaveBody),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.leftCurlyBrace), getPrettyLexemeType(get().type)));
        checkAdvance();

        string[] fields;
        while (!isEnd()) {
            if (get().type == GrLexemeType.rightCurlyBrace) {
                checkAdvance();
                break;
            }
            if (get().type != GrLexemeType.identifier)
                logError(format(getError(Error.expectedEnumFieldFoundX), getPrettyLexemeType(get()
                        .type)), getError(Error.missingIdentifier));

            auto fieldName = get().svalue;
            checkAdvance();
            fields ~= fieldName;

            if (get().type != GrLexemeType.semicolon)
                logError(getError(Error.missingSemicolonAfterEnumField),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.semicolon), getPrettyLexemeType(get().type)));
            checkAdvance();
        }
        if (_data.isTypeDeclared(enumName, fileId, isPublic))
            logError(format(getError(Error.nameXDefMultipleTimes), enumName),
                format(getError(Error.xAlreadyDecl), enumName));
        _data.addEnum(enumName, fields, fileId, isPublic);
    }

    private void registerClassDeclaration(bool isPublic) {
        checkAdvance();
        string[] templateVariables = parseTemplateVariables();
        const uint fileId = get().fileId;
        const uint declPosition = current;
        if (get().type != GrLexemeType.identifier)
            logError(format(getError(Error.expectedClassNameFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));
        const string className = get().svalue;
        if (_data.isTypeDeclared(className, fileId, isPublic))
            logError(format(getError(Error.nameXDefMultipleTimes), className),
                format(getError(Error.xAlreadyDecl), className));
        _data.registerClass(className, fileId, isPublic, templateVariables, declPosition);
        skipDeclaration();
    }

    private GrClassDefinition getClass(string mangledType, uint fileId) {
        GrClassDefinition class_ = _data.getClass(mangledType, fileId);
        if (!class_)
            return null;
        parseClassDeclaration(class_);
        return class_;
    }

    private void parseClassDeclaration(GrClassDefinition class_) {
        if (class_.isParsed)
            return;
        class_.isParsed = true;
        uint tempPos = current;
        current = class_.position;

        for (int i; i < class_.templateVariables.length; ++i) {
            _data.addTemplateAlias(class_.templateVariables[i],
                class_.templateTypes[i], class_.fileId, class_.isPublic);
        }

        uint[] fieldPositions;
        if (get().type != GrLexemeType.identifier)
            logError(format(getError(Error.expectedClassNameFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));
        const string className = get().svalue;
        string parentClassName;
        checkAdvance();

        //Inheritance
        if (get().type == GrLexemeType.colon) {
            checkAdvance();
            if (get().type != GrLexemeType.identifier)
                logError(getError(Error.parentClassNameMissing),
                    format(getError(Error.expectedClassNameFoundX), getPrettyLexemeType(get()
                        .type)));
            parentClassName = get().svalue;
            checkAdvance();
            parentClassName = grMangleComposite(parentClassName, parseTemplateSignature());
        }
        if (get().type != GrLexemeType.leftCurlyBrace)
            logError(getError(Error.classHaveNoBody),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.leftCurlyBrace), getPrettyLexemeType(get().type)));
        checkAdvance();

        string[] fields;
        GrType[] signature;
        bool[] fieldScopes;
        while (!isEnd()) {
            if (get().type == GrLexemeType.rightCurlyBrace) {
                checkAdvance();
                break;
            }

            bool isFieldPublic = false;
            if (get().type == GrLexemeType.public_) {
                isFieldPublic = true;
                checkAdvance();
            }

            GrType fieldType = parseType();
            do {
                if (get().type == GrLexemeType.comma)
                    checkAdvance();

                const string fieldName = get().svalue;
                signature ~= fieldType;
                fields ~= fieldName;
                fieldScopes ~= isFieldPublic;
                fieldPositions ~= current;
                checkAdvance();
            }
            while (get().type == GrLexemeType.comma);

            if (get().type != GrLexemeType.semicolon)
                logError(getError(Error.missingSemicolonAfterClassFieldDecl),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.semicolon), getPrettyLexemeType(get().type)));
            checkAdvance();

            if (get().type == GrLexemeType.rightCurlyBrace) {
                checkAdvance();
                break;
            }
        }

        class_.parent = parentClassName;
        class_.signature = signature;
        class_.fields = fields;

        class_.fieldsInfo.length = fields.length;
        for (int i; i < class_.fieldsInfo.length; ++i) {
            class_.fieldsInfo[i].fileId = class_.fileId;
            class_.fieldsInfo[i].isPublic = fieldScopes[i];
            class_.fieldsInfo[i].position = fieldPositions[i];
        }
        current = tempPos;
        _data.clearTemplateAliases();
        resolveClassInheritence(class_);
    }

    /// Fetch fields and signature of parent classes
    private void resolveClassInheritence(GrClassDefinition class_) {
        uint fileId = class_.fileId;
        string parent = class_.parent;
        GrClassDefinition lastClass = class_;
        string[] usedClasses = [class_.name];

        while (parent.length) {
            GrClassDefinition parentClass = getClass(parent, fileId);
            if (!parentClass) {
                set(lastClass.position + 2u);
                logError(format(getError(Error.xCantInheritFromY), getPrettyType(
                        grGetClassType(class_.name)), parent),
                    getError(Error.unknownClass));
            }
            for (int i; i < usedClasses.length; ++i) {
                if (parent == usedClasses[i]) {
                    set(lastClass.position + 2u);
                    logError(format(getError(Error.xIncludedRecursively), getPrettyType(
                            grGetClassType(parent))),
                        getError(Error.recursiveInheritence));
                }
            }
            usedClasses ~= parent;
            class_.fields = parentClass.fields ~ class_.fields;
            class_.signature = parentClass.signature ~ class_.signature;
            class_.fieldsInfo = parentClass.fieldsInfo ~ class_.fieldsInfo;
            fileId = parentClass.fileId;
            parent = parentClass.parent;
            lastClass = parentClass;
        }
        for (int i; i < class_.signature.length; ++i) {
            for (int y; y < class_.fields.length; ++y) {
                if (i != y && class_.fields[i] == class_.fields[y]) {
                    int first;
                    int second;
                    if (class_.fieldsInfo[i].position < class_.fieldsInfo[y].position) {
                        first = i;
                        second = y;
                    }
                    else {
                        first = y;
                        second = i;
                    }
                    set(class_.fieldsInfo[second].position);
                    logError(format(getError(Error.fieldXDeclMultipleTimes), class_.fields[second]),
                        format(getError(Error.xRedefHere), class_.fields[second]),
                        "", 0, format(getError(Error.prevDefOfX), class_.fields[first]),
                        class_.fieldsInfo[first].position);
                }
            }
            if (class_.signature[i].baseType != GrBaseType.class_) {
                for (int y; y < usedClasses.length; ++y) {
                    if (class_.signature[i].mangledType == usedClasses[y]) {
                        set(class_.fieldsInfo[i].position);
                        logError(format(getError(Error.xIncludedRecursively), class_
                                .signature[i].mangledType),
                            getError(Error.recursiveDecl));
                    }
                }
            }
        }
    }

    private void skipDeclaration() {
        checkAdvance();
        while (!isEnd()) {
            if (get().type != GrLexemeType.leftCurlyBrace) {
                checkAdvance();
            }
            else {
                skipBlock();
                return;
            }
        }
    }

    private void skipExpression() {
        checkAdvance();
        while (!isEnd()) {
            switch (get().type) with (GrLexemeType) {
            case semicolon:
                checkAdvance();
                return;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                checkAdvance();
                break;
            }
        }
    }

    private GrType parseType(bool mustBeType = true) {
        GrType currentType = GrBaseType.void_;

        GrLexeme lex = get();
        if (!lex.isType) {
            if (lex.type == GrLexemeType.identifier
                && _data.isTypeAlias(lex.svalue, lex.fileId, false)) {
                currentType = _data.getTypeAlias(lex.svalue, lex.fileId).type;
                checkAdvance();
                return currentType;
            }
            else if (lex.type == GrLexemeType.identifier
                && _data.isClass(lex.svalue, lex.fileId, false)) {
                currentType.baseType = GrBaseType.class_;
                checkAdvance();
                currentType.mangledType = grMangleComposite(lex.svalue, parseTemplateSignature());
                if (mustBeType) {
                    GrClassDefinition class_ = getClass(currentType.mangledType, lex.fileId);
                    if (!class_)
                        logError(format(getError(Error.xNotDecl),
                                getPrettyType(currentType)), getError(Error.unknownClass), "", -1);
                }
                return currentType;
            }
            else if (lex.type == GrLexemeType.identifier
                && _data.isEnum(lex.svalue, lex.fileId, false)) {
                currentType.baseType = GrBaseType.enum_;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                return currentType;
            }
            else if (lex.type == GrLexemeType.identifier && _data.isForeign(lex.svalue)) {
                currentType.baseType = GrBaseType.foreign;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                currentType.mangledType = grMangleComposite(lex.svalue, parseTemplateSignature());
                return currentType;
            }
            else if (mustBeType) {
                const string typeName = lex.type == GrLexemeType.identifier
                    ? lex.svalue : getPrettyLexemeType(lex.type);
                logError(format(getError(Error.xNotValidType), typeName),
                    format(getError(Error.expectedValidTypeFoundX), typeName));
            }
            else {
                return currentType;
            }
        }

        switch (lex.type) with (GrLexemeType) {
        case intType:
            currentType.baseType = GrBaseType.int_;
            checkAdvance();
            break;
        case floatType:
            currentType.baseType = GrBaseType.float_;
            checkAdvance();
            break;
        case boolType:
            currentType.baseType = GrBaseType.bool_;
            checkAdvance();
            break;
        case stringType:
            currentType.baseType = GrBaseType.string_;
            checkAdvance();
            break;
        case listType:
            currentType.baseType = GrBaseType.list_;
            checkAdvance();
            string[] temp;
            auto signature = parseInSignature(temp, true);
            if (signature.length > 1) {
                logError(getError(Error.listCanOnlyContainOneTypeOfVal), getError(Error.conflictingListSignature),
                    format(getError(Error.tryUsingXInstead), getPrettyType(grList(signature[0]))), -1);
            }
            else if (signature.length == 0) {
                logError(getError(Error.listCanOnlyContainOneTypeOfVal), getError(
                        Error.conflictingListSignature), "", -1);
            }
            currentType.mangledType = grMangleSignature(signature);
            break;
        case functionType:
            currentType.baseType = GrBaseType.function_;
            checkAdvance();
            string[] temp;
            currentType.mangledType = grMangleSignature(parseInSignature(temp, true));
            currentType.mangledReturnType = grMangleSignature(parseOutSignature());
            break;
        case taskType:
            currentType.baseType = GrBaseType.task;
            checkAdvance();
            string[] temp;
            currentType.mangledType = grMangleSignature(parseInSignature(temp, true));
            break;
        case chanType:
            currentType.baseType = GrBaseType.chan;
            checkAdvance();
            string[] temp;
            GrType[] signature = parseInSignature(temp, true);
            if (signature.length != 1)
                logError(getError(Error.channelCanOnlyContainOneTypeOfVal), getError(Error.conflictingChannelSignature),
                    format(getError(Error.tryUsingXInstead), getPrettyType(grChannel(signature[0]))), -1);
            currentType.mangledType = grMangleSignature(signature);
            break;
        default:
            logError(format(getError(Error.xNotValidType), getPrettyLexemeType(lex.type)),
                format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get().type)));
        }

        return currentType;
    }

    private void addGlobalPop(GrType type) {
        final switch (type.baseType) with (GrBaseType) {
        case internalTuple:
        case null_:
        case void_:
            logError(format(getError(Error.xNotValidType), getPrettyType(type)), format(
                    getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get().type)));
            break;
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.globalPop_int, 0u);
            break;
        case float_:
            addInstruction(GrOpcode.globalPop_float, 0u);
            break;
        case string_:
            addInstruction(GrOpcode.globalPop_string, 0u);
            break;
        case class_:
        case list_:
        case foreign:
        case chan:
        case reference:
            addInstruction(GrOpcode.globalPop_object, 0u);
            break;
        }
    }

    private void addGlobalPush(GrType type, int nbPush = 1u) {
        if (nbPush == 0)
            return;
        final switch (type.baseType) with (GrBaseType) {
        case internalTuple:
        case null_:
        case void_:
            logError(format(getError(Error.xNotValidType), getPrettyType(type)), format(
                    getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get().type)));
            break;
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.globalPush_int, nbPush);
            break;
        case float_:
            addInstruction(GrOpcode.globalPush_float, nbPush);
            break;
        case string_:
            addInstruction(GrOpcode.globalPush_string, nbPush);
            break;
        case class_:
        case list_:
        case foreign:
        case chan:
        case reference:
            addInstruction(GrOpcode.globalPush_object, nbPush);
            break;
        }
    }

    private void addGlobalPush(GrType[] signature) {
        struct TypeCounter {
            uint nbIntParams, nbFloatParams, nbStringParams, nbObjectParams;
        }

        void countParameters(ref TypeCounter typeCounter, GrType type) {
            final switch (type.baseType) with (GrBaseType) {
            case internalTuple:
            case null_:
            case void_:
                logError(format(getError(Error.xNotValidType), getPrettyType(type)), format(
                        getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(
                        get().type)));
                break;
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                typeCounter.nbIntParams++;
                break;
            case float_:
                typeCounter.nbFloatParams++;
                break;
            case string_:
                typeCounter.nbStringParams++;
                break;
            case class_:
            case list_:
            case foreign:
            case chan:
            case reference:
                typeCounter.nbObjectParams++;
                break;
            }
        }

        TypeCounter typeCounter;
        foreach (type; signature) {
            countParameters(typeCounter, type);
        }

        if (typeCounter.nbIntParams > 0)
            addInstruction(GrOpcode.globalPush_int, typeCounter.nbIntParams);
        if (typeCounter.nbFloatParams > 0)
            addInstruction(GrOpcode.globalPush_float, typeCounter.nbFloatParams);
        if (typeCounter.nbStringParams > 0)
            addInstruction(GrOpcode.globalPush_string, typeCounter.nbStringParams);
        if (typeCounter.nbObjectParams > 0)
            addInstruction(GrOpcode.globalPush_object, typeCounter.nbObjectParams);
    }

    private string[] parseTemplateVariables() {
        string[] variables;
        if (get().type != GrLexemeType.lesser)
            return variables;
        checkAdvance();
        if (get().type == GrLexemeType.greater) {
            checkAdvance();
            return variables;
        }
        for (;;) {
            if (get().type != GrLexemeType.identifier)
                logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                        .type)), getError(Error.missingTemplateVal));
            variables ~= get().svalue;
            checkAdvance();

            const GrLexeme lex = get();
            if (lex.type == GrLexemeType.greater) {
                checkAdvance();
                break;
            }
            else if (lex.type != GrLexemeType.comma)
                logError(getError(Error.templateValShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.comma), getPrettyLexemeType(lex.type)));
            checkAdvance();
        }
        return variables;
    }

    private GrType[] parseTemplateSignature() {
        GrType[] signature;
        if (get().type != GrLexemeType.lesser)
            return signature;
        checkAdvance();
        if (get().type == GrLexemeType.greater) {
            checkAdvance();
            return signature;
        }
        for (;;) {
            signature ~= parseType();

            const GrLexeme lex = get();
            if (lex.type == GrLexemeType.greater) {
                checkAdvance();
                break;
            }
            else if (lex.type != GrLexemeType.comma)
                logError(getError(Error.templateTypesShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.comma), getPrettyLexemeType(lex.type)));
            checkAdvance();
        }
        return signature;
    }

    private GrType[] parseInSignature(ref string[] inputVariables, bool asType = false) {
        GrType[] inSignature;

        if (get().type != GrLexemeType.leftParenthesis)
            logError(getError(Error.missingParentheses),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));

        bool startLoop = true;
        for (;;) {
            checkAdvance();
            GrLexeme lex = get();

            if (startLoop && lex.type == GrLexemeType.rightParenthesis)
                break;
            startLoop = false;

            inSignature ~= parseType();

            //If we want to know whether it's a type or an anon, we can't throw exceptions.
            if (isTypeChecking) {
                lex = get();
                if (get().type == GrLexemeType.identifier) {
                    inputVariables ~= lex.svalue;
                    checkAdvance();
                    lex = get();
                }

                if (lex.type == GrLexemeType.rightParenthesis)
                    break;
                else if (lex.type != GrLexemeType.comma)
                    logError(getError(Error.paramShouldBeSeparatedByComma),
                        format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                            GrLexemeType.comma), getPrettyLexemeType(get().type)));
            }
            else {
                //Is it a function type or a function declaration ?
                if (!asType) {
                    lex = get();
                    if (get().type != GrLexemeType.identifier)
                        logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                                .type)), getError(Error.missingIdentifier));
                    inputVariables ~= lex.svalue;
                    checkAdvance();
                }

                lex = get();
                if (lex.type == GrLexemeType.rightParenthesis)
                    break;
                else if (lex.type != GrLexemeType.comma)
                    logError(getError(Error.paramShouldBeSeparatedByComma),
                        format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                            GrLexemeType.comma), getPrettyLexemeType(get().type)));
            }
        }
        checkAdvance();

        return inSignature;
    }

    private GrType[] parseOutSignature() {
        GrType[] outSignature;
        if (get().type != GrLexemeType.leftParenthesis)
            return outSignature;
        checkAdvance();
        if (get().type == GrLexemeType.rightParenthesis) {
            checkAdvance();
            return outSignature;
        }
        for (;;) {
            outSignature ~= parseType();

            const GrLexeme lex = get();
            if (lex.type == GrLexemeType.rightParenthesis) {
                checkAdvance();
                break;
            }
            else if (lex.type != GrLexemeType.comma)
                logError(getError(Error.typesShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.comma), getPrettyLexemeType(lex.type)));
            checkAdvance();
        }
        return outSignature;
    }

    private void parseActionDeclaration(bool isPublic) {
        if (isPublic)
            logError(getError(Error.addingPubBeforeActionIsRedundant), getError(
                    Error.actionAlreadyPublic));
        checkAdvance();
        if (get().type != GrLexemeType.identifier)
            logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));
        string name = get().svalue;
        string[] inputs;
        checkAdvance();
        GrType[] signature = parseInSignature(inputs);
        preBeginFunction(name, get().fileId, signature, inputs, false, [], false, true, true);
        skipBlock();
        preEndFunction();
    }

    private void parseTaskDeclaration(bool isPublic) {
        checkAdvance();
        string[] templateVariables = parseTemplateVariables();
        if (get().type != GrLexemeType.identifier)
            logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));

        string name = get().svalue;
        checkAdvance();

        GrTemplateFunction temp = new GrTemplateFunction;
        temp.isTask = true;
        temp.name = name;
        temp.templateVariables = templateVariables;
        temp.fileId = get().fileId;
        temp.isPublic = isPublic;
        temp.lexPosition = current;

        if (templateVariables.length)
            templatedFunctions ~= temp;
        else
            instanciatedFunctions ~= parseTemplatedFunctionDeclaration(temp, []);

        if (get().type == GrLexemeType.leftParenthesis)
            skipParenthesis();
        skipBlock();
    }

    private void parseFunctionDeclaration(bool isPublic) {
        checkAdvance();
        string[] templateVariables = parseTemplateVariables();
        string name;
        bool isConversion;
        if (get().type == GrLexemeType.as) {
            name = "@as";
            isConversion = true;
        }
        else if (get().type == GrLexemeType.identifier) {
            name = get().svalue;
        }
        else if (get().isOverridableOperator()) {
            name = "@op_" ~ getPrettyLexemeType(get().type);
        }
        else if (get().isOperator) {
            logError(format(getError(Error.cantOverrideXOp), getPrettyLexemeType(get()
                    .type)), getError(Error.opCantBeOverriden));
        }
        else {
            logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));
        }

        checkAdvance();

        GrTemplateFunction temp = new GrTemplateFunction;
        temp.isTask = false;
        temp.name = name;
        temp.isConversion = isConversion;
        temp.templateVariables = templateVariables;
        temp.fileId = get().fileId;
        temp.isPublic = isPublic;
        temp.lexPosition = current;

        if (templateVariables.length)
            templatedFunctions ~= temp;
        else
            instanciatedFunctions ~= parseTemplatedFunctionDeclaration(temp, []);

        if (get().type == GrLexemeType.leftParenthesis)
            skipParenthesis();
        if (get().type == GrLexemeType.leftParenthesis)
            skipParenthesis();
        skipBlock();
    }

    private void parseTemplateDeclaration(bool isPublic) {
        checkAdvance();
        if (get().type != GrLexemeType.lesser)
            logError(getError(Error.missingTemplateSignature),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(GrLexemeType.lesser), getPrettyLexemeType(
                    get().type)));

        GrType[] templateList = parseTemplateSignature();

        string name;
        if (get().type == GrLexemeType.identifier) {
            name = get().svalue;
        }
        else if (get().isOverridableOperator()) {
            name = "@op_" ~ getPrettyLexemeType(get().type);
        }
        else if (get().isOperator) {
            logError(format(getError(Error.cantOverrideXOp), getPrettyLexemeType(get()
                    .type)), getError(Error.opCantBeOverriden));
        }
        else {
            logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingIdentifier));
        }

        const uint fileId = get().fileId;
        checkAdvance();

        if (!templateList.length)
            logError(getError(Error.emptyTemplateSignature), getError(
                    Error.templateSignatureCantBeEmpty), "", -1);

        if (get().type != GrLexemeType.semicolon)
            logError(getError(Error.missingSemicolonAfterTemplateDecl),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.semicolon), getPrettyLexemeType(get().type)));
        checkAdvance();

        foreach (GrTemplateFunction temp; templatedFunctions) {
            if (temp.name == name && (temp.fileId == fileId || temp.isPublic)
                && temp.templateVariables.length == templateList.length) {
                GrFunction func = parseTemplatedFunctionDeclaration(temp, templateList);
                func.isPublic = isPublic;
                instanciatedFunctions ~= func;
            }
        }
    }

    private GrFunction parseTemplatedFunctionDeclaration(GrTemplateFunction temp,
        GrType[] templateList) {
        const auto lastPosition = current;
        current = temp.lexPosition;

        for (int i; i < temp.templateVariables.length; ++i) {
            _data.addTemplateAlias(temp.templateVariables[i], templateList[i],
                temp.fileId, temp.isPublic);
        }

        string[] inputs;
        GrType[] inSignature = parseInSignature(inputs);
        GrType[] outSignature;

        if (!temp.isTask) {
            //Return Type.
            if (temp.isConversion) {
                if (inSignature.length != 1uL) {
                    logError(getError(Error.convMustHave1Param),
                        format(getError(inSignature.length > 1 ? Error.expected1ParamFoundXs
                            : Error
                            .expected1ParamFoundX), inSignature.length));
                }
                outSignature = parseOutSignature();
                if (outSignature.length != 1uL) {
                    logError(getError(Error.convMustHave1RetVal),
                        format(getError(outSignature.length > 1 ? Error.expected1RetValFoundXs
                            : Error.expected1RetValFoundX), outSignature.length));
                }

                inSignature ~= outSignature[0];
            }
            else
                outSignature = parseOutSignature();
        }

        GrFunction func = new GrFunction;
        func.isTask = temp.isTask;
        func.name = temp.name;
        func.inputVariables = inputs;
        func.inSignature = inSignature;
        func.outSignature = outSignature;
        func.fileId = temp.fileId;
        func.isPublic = temp.isPublic;
        func.lexPosition = current;
        func.templateVariables = temp.templateVariables;
        func.templateSignature = templateList;

        _data.clearTemplateAliases();
        current = lastPosition;
        return func;
    }

    private GrType parseAnonymousFunction(bool isTask) {
        checkAdvance();
        string[] inputs;
        GrType[] outSignature;
        GrType[] inSignature = parseInSignature(inputs);

        if (!isTask) {
            //Return Type.
            outSignature = parseOutSignature();
        }
        preBeginFunction("$anon", get().fileId, inSignature, inputs, isTask, outSignature, true);
        openDeferrableSection();
        parseBlock();

        if (isTask) {
            if (!currentFunction.instructions.length
                || currentFunction.instructions[$ - 1].opcode != GrOpcode.kill_)
                addKill();
        }
        else {
            if (!outSignature.length) {
                if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    addReturn();
            }
            else {
                if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    logError(getError(Error.funcMissingRetAtEnd), getError(Error.missingRet));
            }
        }

        closeDeferrableSection();
        registerDeferBlocks();

        endFunction();

        GrType functionType = isTask ? GrBaseType.task : GrBaseType.function_;
        functionType.mangledType = grMangleSignature(inSignature);
        functionType.mangledReturnType = grMangleSignature(outSignature);

        return functionType;
    }

    /**
    Parse either multiple lines between `{` and `}` or a single expression.
    */
    private void parseBlock(bool changeOptimizationBlockLevel = false) {
        if (changeOptimizationBlockLevel)
            _isAssignationOptimizable = false;
        bool isMultiline;
        if (get().type == GrLexemeType.leftCurlyBrace) {
            isMultiline = true;
            if (!checkAdvance())
                logError(getError(Error.eof),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.rightCurlyBrace), getPrettyLexemeType(get().type)));
        }
        openBlock();

        void parseStatement() {
            switch (get().type) with (GrLexemeType) {
            case semicolon:
            case rightCurlyBrace:
                advance();
                break;
            case leftCurlyBrace:
                parseBlock();
                break;
            case defer:
                parseDeferStatement();
                break;
            case if_:
            case unless:
                parseIfStatement();
                break;
            case switch_:
                parseSwitchStatement();
                break;
            case select:
                parseSelectStatement();
                break;
            case until:
            case while_:
                parseWhileStatement();
                break;
            case do_:
                parseDoWhileStatement();
                break;
            case for_:
                parseForStatement();
                break;
            case loop:
                parseLoopStatement();
                break;
            case raise_:
                parseRaiseStatement();
                break;
            case try_:
                parseExceptionHandler();
                break;
            case return_:
                parseReturnStatement();
                break;
            case kill:
                parseKill();
                break;
            case killAll:
                parseKillAll();
                break;
            case yield:
                parseYield();
                break;
            case continue_:
                parseContinue();
                break;
            case break_:
                parseBreak();
                break;
            case intType: .. case autoType:
                if (isDeclaration())
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            case identifier:
                if (_data.isTypeDeclared(get().svalue, get().fileId, false)
                    && get(1).type != GrLexemeType.leftParenthesis)
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            default:
                parseExpression();
                break;
            }
        }

        if (isMultiline) {
            while (!isEnd()) {
                if (get().type == GrLexemeType.rightCurlyBrace)
                    break;
                parseStatement();
            }
        }
        else {
            if (get().type != GrLexemeType.semicolon)
                parseStatement();
        }

        if (isMultiline) {
            if (get().type != GrLexemeType.rightCurlyBrace)
                logError(getError(Error.missingCurlyBraces),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.rightCurlyBrace), getPrettyLexemeType(get().type)));
            checkAdvance();
        }
        closeBlock();
        if (changeOptimizationBlockLevel)
            _isAssignationOptimizable = false;
    }

    private bool isDeclaration() {
        const auto tempPos = current;
        isTypeChecking = true;
        if (get().type == GrLexemeType.autoType)
            checkAdvance();
        else
            parseType(false);
        isTypeChecking = false;
        bool isDecl;
        if (get().type == GrLexemeType.identifier)
            isDecl = true;
        current = tempPos;
        return isDecl;
    }

    private void skipBlock() {
        bool isMultiline;
        if (get().type == GrLexemeType.leftCurlyBrace) {
            isMultiline = true;
            if (!checkAdvance())
                logError(getError(Error.eof),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.rightCurlyBrace), getPrettyLexemeType(get().type)));
        }
        openBlock();

        void skipStatement() {
            switch (get().type) with (GrLexemeType) {
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            case defer:
                checkAdvance();
                skipBlock();
                break;
            case switch_:
                checkAdvance();
                skipParenthesis();
                while (get().type == GrLexemeType.case_) {
                    checkAdvance();
                    if (get().type == GrLexemeType.leftParenthesis)
                        skipParenthesis();
                    skipBlock();
                }
                break;
            case if_:
            case unless:
                checkAdvance();
                skipParenthesis();
                skipBlock();
                break;
            case select:
                checkAdvance();
                while (get().type == GrLexemeType.case_) {
                    checkAdvance();
                    if (get().type == GrLexemeType.leftParenthesis)
                        skipParenthesis();
                    skipBlock();
                }
                break;
            case until:
            case while_:
                checkAdvance();
                skipBlock();
                break;
            case do_:
                checkAdvance();
                skipBlock();
                checkAdvance();
                skipParenthesis();
                break;
            case for_:
                checkAdvance();
                skipParenthesis();
                skipBlock();
                break;
            case loop:
                checkAdvance();
                if (get().type == GrLexemeType.leftParenthesis)
                    skipParenthesis();
                skipBlock();
                break;
            case raise_:
                checkAdvance();
                skipBlock();
                break;
            case try_:
                checkAdvance();
                skipBlock();
                if (get().type == GrLexemeType.catch_) {
                    checkAdvance();
                    skipParenthesis();
                    skipBlock();
                }
                break;
            case yield:
                checkAdvance();
                break;
            case return_:
                checkAdvance();
                skipBlock();
                break;
            default:
                checkAdvance();
                break;
            }
        }

        if (isMultiline) {
            while (!isEnd()) {
                if (get().type == GrLexemeType.rightCurlyBrace)
                    break;
                switch (get().type) with (GrLexemeType) {
                case leftParenthesis:
                    skipParenthesis();
                    break;
                case leftBracket:
                    skipBrackets();
                    break;
                case leftCurlyBrace:
                    skipBlock();
                    break;
                default:
                    checkAdvance();
                    break;
                }
            }

            if (get().type != GrLexemeType.rightCurlyBrace)
                logError(getError(Error.missingCurlyBraces),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.rightCurlyBrace), getPrettyLexemeType(get().type)));
            checkAdvance();
        }
        else {
            if (get().type != GrLexemeType.semicolon)
                skipStatement();
        }
        closeBlock();
    }

    private void parseKill() {
        if (!currentFunction.instructions.length
            || currentFunction.instructions[$ - 1].opcode != GrOpcode.kill_)
            addKill();
        advance();
    }

    private void parseKillAll() {
        if (!currentFunction.instructions.length
            || currentFunction.instructions[$ - 1].opcode != GrOpcode.killAll_)
            addKillAll();
        advance();
    }

    private void parseYield() {
        addInstruction(GrOpcode.yield, 0u);
        advance();
    }

    //Exception handling
    private void parseRaiseStatement() {
        advance();
        GrType type = parseSubExpression(GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_EXPECTING_VALUE)
            .type;
        checkAdvance();
        convertType(type, grString);
        addInstruction(GrOpcode.raise_);
        checkDeferStatement();
    }

    private void parseExceptionHandler() {
        advance();

        const auto tryPosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.try_);

        parseBlock();

        const uint fileId = get().fileId;
        if (get().type != GrLexemeType.catch_)
            logError(getError(Error.tryMustBeFollowedByCatch),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(GrLexemeType.catch_), getPrettyLexemeType(
                    get().type)));
        advance();

        if (get().type != GrLexemeType.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexemeType.catch_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));
        advance();

        if (get().type != GrLexemeType.identifier)
            logError(getError(Error.missingIdentifier),
                format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get().type)));
        GrVariable errVariable = registerLocalVariable(get().svalue, grString);

        advance();
        if (get().type != GrLexemeType.rightParenthesis)
            logError(getError(Error.missingParentheses),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.rightParenthesis), getPrettyLexemeType(get().type)));
        advance();

        const auto catchPosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.catch_);

        addInstruction(GrOpcode.globalPop_string);
        addSetInstruction(errVariable, fileId, grString);

        parseBlock(true);

        const auto endPosition = currentFunction.instructions.length;

        setInstruction(GrOpcode.try_, cast(uint) tryPosition,
            cast(uint)(catchPosition - tryPosition), true);
        setInstruction(GrOpcode.catch_, cast(uint) catchPosition,
            cast(uint)(endPosition - catchPosition), true);
    }

    //defer
    private void openDeferrableSection() {
        auto deferrableSection = new GrDeferrableSection;
        deferrableSection.deferInitPositions = cast(uint) currentFunction.instructions.length;
        currentFunction.deferrableSections ~= deferrableSection;

        currentFunction.isDeferrableSectionLocked.length++;
    }

    private void closeDeferrableSection() {
        if (!currentFunction.deferrableSections.length)
            throw new Exception("attempting to close a non-existing function");

        foreach (deferBlock; currentFunction.deferrableSections[$ - 1].deferredBlocks) {
            currentFunction.registeredDeferBlocks ~= deferBlock;
        }

        currentFunction.deferrableSections.length--;
        currentFunction.isDeferrableSectionLocked.length--;
    }

    private void parseDeferStatement() {
        if (currentFunction.isDeferrableSectionLocked[$ - 1])
            logError(getError(Error.deferInsideDefer), getError(Error.cantDeferInsideDefer));
        advance();

        //Register the position of the block for a late parsing.
        GrDeferBlock deferBlock = new GrDeferBlock;
        deferBlock.position = cast(uint) currentFunction.instructions.length;
        deferBlock.parsePosition = current;
        deferBlock.scopeLevel = scopeLevel;
        currentFunction.deferrableSections[$ - 1].deferredBlocks ~= deferBlock;

        addInstruction(GrOpcode.defer);

        //Parse the deferred block at the end of the outer block.
        skipBlock();
    }

    private void checkDeferStatement() {
        if (currentFunction.isDeferrableSectionLocked[$ - 1]) {
            GrLexemeType type = get().type;
            logError(format(getError(Error.xInsideDefer), getPrettyLexemeType(type)),
                format(getError(Error.cantXInsideDefer), getPrettyLexemeType(type)));
        }
    }

    private void registerDeferBlocks() {
        const auto tempParsePosition = current;
        const auto startDeferPos = cast(uint) currentFunction.instructions.length;

        const int tempScopeLevel = scopeLevel;
        while (currentFunction.registeredDeferBlocks.length) {
            GrDeferBlock deferBlock = currentFunction.registeredDeferBlocks[0];
            currentFunction.registeredDeferBlocks = currentFunction.registeredDeferBlocks[1 .. $];

            setInstruction(GrOpcode.defer, deferBlock.position,
                cast(int)(currentFunction.instructions.length - deferBlock.position), true);
            current = deferBlock.parsePosition;
            scopeLevel = deferBlock.scopeLevel;

            currentFunction.isDeferrableSectionLocked[$ - 1] = true;
            parseBlock(true);
            currentFunction.isDeferrableSectionLocked[$ - 1] = false;

            addInstruction(GrOpcode.unwind);
        }
        currentFunction.registeredDeferBlocks.length = 0;
        current = tempParsePosition;
        scopeLevel = tempScopeLevel;
    }

    //Break
    private void openBreakableSection() {
        breaksJumps ~= [null];
        _isAssignationOptimizable = false;
    }

    private void closeBreakableSection() {
        if (!breaksJumps.length)
            throw new Exception("attempting to close a non-existing function");

        uint[] breaks = breaksJumps[$ - 1];
        breaksJumps.length--;

        foreach (position; breaks)
            setInstruction(GrOpcode.jump, position,
                cast(int)(currentFunction.instructions.length - position), true);
        _isAssignationOptimizable = false;
    }

    private void parseBreak() {
        if (!breaksJumps.length)
            logError(getError(Error.breakOutsideLoop), getError(Error.cantBreakOutsideLoop));

        breaksJumps[$ - 1] ~= cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.jump);
        advance();
    }

    //Continue
    private void openContinuableSection() {
        continuesJumps.length++;
        _isAssignationOptimizable = false;
    }

    private void closeContinuableSection() {
        if (!continuesJumps.length)
            throw new Exception("attempting to close a non-existing function");

        uint[] continues = continuesJumps[$ - 1];
        const uint destination = continuesDestinations[$ - 1];
        continuesJumps.length--;
        continuesDestinations.length--;

        foreach (position; continues)
            setInstruction(GrOpcode.jump, position, cast(int)(destination - position), true);
        _isAssignationOptimizable = false;
    }

    private void setContinuableSectionDestination() {
        continuesDestinations ~= cast(uint) currentFunction.instructions.length;
    }

    private void parseContinue() {
        if (!continuesJumps.length)
            logError(getError(Error.continueOutsideLoop), getError(Error.cantContinueOutsideLoop));

        continuesJumps[$ - 1] ~= cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.jump);
        advance();
    }

    private void parseGlobalDeclaration(bool isPublic) {
        //GrVariable type
        GrType type = GrBaseType.void_;
        bool isAuto;

        if (get().type == GrLexemeType.autoType) {
            isAuto = true;
            checkAdvance();
        }
        else
            type = parseType();

        GrVariable[] lvalues;
        do {
            if (get().type == GrLexemeType.comma)
                checkAdvance();
            //Identifier
            if (get().type != GrLexemeType.identifier)
                logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                        .type)), getError(Error.missingIdentifier));

            string identifier = get().svalue;

            //Registering
            GrVariable lvalue = registerGlobalVariable(identifier, type, isAuto, isPublic);
            lvalues ~= lvalue;

            checkAdvance();
        }
        while (get().type == GrLexemeType.comma);

        parseAssignList(lvalues, true);
    }

    //Type Identifier [= EXPRESSION] ;
    private void parseLocalDeclaration() {
        //GrVariable type
        GrType type = GrBaseType.void_;
        bool isAuto;
        if (get().type == GrLexemeType.autoType) {
            isAuto = true;
            checkAdvance();
        }
        else
            type = parseType();

        GrVariable[] lvalues;
        do {
            if (get().type == GrLexemeType.comma)
                checkAdvance();
            //Identifier
            if (get().type != GrLexemeType.identifier)
                logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                        .type)), getError(Error.missingIdentifier));

            string identifier = get().svalue;

            //Registering
            GrVariable lvalue = registerLocalVariable(identifier, type);
            lvalue.isAuto = isAuto;
            lvalues ~= lvalue;

            //A composite type does not need to be initialized.
            if (lvalue.type == GrBaseType.class_)
                lvalue.isInitialized = true;

            checkAdvance();
        }
        while (get().type == GrLexemeType.comma);

        parseAssignList(lvalues, true);
    }

    private GrType parseFunctionReturnType() {
        GrType returnType = GrBaseType.void_;
        if (get().isType) {
            switch (get().type) with (GrLexemeType) {
            case intType:
                returnType = GrType(GrBaseType.int_);
                break;
            case floatType:
                returnType = GrType(GrBaseType.float_);
                break;
            case boolType:
                returnType = GrType(GrBaseType.bool_);
                break;
            case stringType:
                returnType = GrType(GrBaseType.string_);
                break;
            case listType:
                returnType = GrType(GrBaseType.list_);
                break;
            case functionType:
                GrType type = GrBaseType.function_;
                checkAdvance();
                string[] temp;
                type.mangledType = grMangleSignature(parseInSignature(temp, true));
                returnType = type;
                break;
            case taskType:
                GrType type = GrBaseType.task;
                checkAdvance();
                string[] temp;
                type.mangledType = grMangleSignature(parseInSignature(temp, true));
                returnType = type;
                break;
            default:
                logError(format(getError(Error.xNotValidRetType), getPrettyLexemeType(get().type)),
                    format(getError(Error.xNotValidRetType), getPrettyLexemeType(get().type)));
            }
            checkAdvance();
        }

        return returnType;
    }

    /**
    ---
    if(SUBEXPR) BLOCK
    else if(SUBEXPR) BLOCK
    else unless(SUBEXPR) BLOCK
    else(SUBEXPR) BLOCK
    ---
    */
    private void parseIfStatement() {
        bool isNegative = get().type == GrLexemeType.unless;
        advance();
        if (isNegative && get().type == GrLexemeType.if_)
            advance();
        if (get().type != GrLexemeType.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(isNegative ? GrLexemeType
                    .unless : GrLexemeType.if_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));

        advance();
        GrSubExprResult result = parseSubExpression();
        convertType(result.type, grBool, get().fileId);
        advance();

        uint jumpPosition = cast(uint) currentFunction.instructions.length;
        //Jumps to if(0) for "if", if(!= 0) for "unless".
        addInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual);

        parseBlock(true); //{ .. }

        //If(1){}, jumps out.
        uint[] exitJumps;
        if (get().type == GrLexemeType.else_) {
            exitJumps ~= cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.jump);
        }

        //Jumps to if(0) for "if", if(!= 0) for "unless".
        setInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual, jumpPosition,
            cast(int)(currentFunction.instructions.length - jumpPosition), true);

        bool isElseIf;
        do {
            isElseIf = false;
            if (get().type == GrLexemeType.else_) {
                checkAdvance();
                if (get().type == GrLexemeType.if_ || get().type == GrLexemeType.unless) {
                    isNegative = get().type == GrLexemeType.unless;
                    isElseIf = true;
                    checkAdvance();
                    if (isNegative && get().type == GrLexemeType.if_)
                        checkAdvance();
                    if (get().type != GrLexemeType.leftParenthesis)
                        logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(isNegative ? GrLexemeType.unless
                                : GrLexemeType.if_)),
                            format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                                GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));
                    checkAdvance();

                    parseSubExpression();
                    advance();

                    jumpPosition = cast(uint) currentFunction.instructions.length;
                    //Jumps to if(0) for "if", if(!= 0) for "unless".
                    addInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual);

                    parseBlock(true); //{ .. }

                    //If(1){}, jumps out.
                    exitJumps ~= cast(uint) currentFunction.instructions.length;
                    addInstruction(GrOpcode.jump);

                    //Jumps to if(0) for "if", if(!= 0) for "unless".
                    setInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual, jumpPosition,
                        cast(int)(currentFunction.instructions.length - jumpPosition), true);
                }
                else
                    parseBlock(true);
            }
        }
        while (isElseIf);

        foreach (uint position; exitJumps)
            setInstruction(GrOpcode.jump, position,
                cast(int)(currentFunction.instructions.length - position), true);
    }

    private GrType parseChannelBuilder() {
        GrType chanType = GrBaseType.chan;
        int channelSize = 1;

        checkAdvance();
        if (get().type != GrLexemeType.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexemeType.chanType)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));
        checkAdvance();
        GrType subType = parseType();

        GrLexeme lex = get();
        if (lex.type == GrLexemeType.comma) {
            checkAdvance();
            lex = get();
            if (lex.type != GrLexemeType.integer)
                logError(getError(Error.chanSizeMustBePositive),
                    format(getError(Error.expectedIntFoundX), getPrettyLexemeType(get().type)));
            channelSize = lex.ivalue > int.max ? 1 : cast(int) lex.ivalue;
            if (channelSize < 1)
                logError(getError(Error.chanSizeMustBeOneOrHigher),
                    format(getError(Error.expectedAtLeastSizeOf1FoundX), channelSize));
            checkAdvance();
        }
        else if (lex.type != GrLexemeType.rightParenthesis) {
            logError(getError(Error.missingCommaOrRightParenthesisInsideChanSignature),
                format(getError(Error.expectedCommaOrRightParenthesisFoundX), getPrettyLexemeType(get()
                    .type)));
        }
        lex = get();
        if (lex.type != GrLexemeType.rightParenthesis)
            logError(getError(Error.missingParenthesesAfterChanSignature),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.rightParenthesis), getPrettyLexemeType(get().type)));
        checkAdvance();
        chanType.mangledType = grMangleSignature([subType]);

        final switch (subType.baseType) with (GrBaseType) {
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.channel_int, channelSize);
            break;
        case float_:
            addInstruction(GrOpcode.channel_float, channelSize);
            break;
        case string_:
            addInstruction(GrOpcode.channel_string, channelSize);
            break;
        case class_:
        case list_:
        case foreign:
        case chan:
        case reference:
            addInstruction(GrOpcode.channel_object, channelSize);
            break;
        case void_:
        case null_:
        case internalTuple:
            logError(format(getError(Error.chanCantBeOfTypeX), getPrettyType(grChannel(subType))),
                getError(Error.invalidChanType));
        }
        return chanType;
    }

    /**
    ---
    switch(SUBEXPR)
    case(SUBEXPR) BLOCK
    case(SUBEXPR) BLOCK
    case() BLOCK
    ---
    */
    private void parseSwitchStatement() {
        advance();
        if (get().type != GrLexemeType.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexemeType.switch_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));

        advance();
        const uint fileId = get().fileId;
        GrType switchType = parseSubExpression().type;
        GrVariable switchVar = registerSpecialVariable("switch", switchType);
        addSetInstruction(switchVar, fileId);
        advance();

        /* A switch is breakable. */
        openBreakableSection();
        uint[] exitJumps;
        uint jumpPosition, casePosition, defaultCasePosition, defaultCaseKeywordPosition;
        bool hasCase, hasDefaultCase;

        while (get().type == GrLexemeType.case_) {
            casePosition = current;
            advance();
            if (get().type != GrLexemeType.leftParenthesis)
                logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexemeType.case_)),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));
            advance();
            if (get().type == GrLexemeType.rightParenthesis) {
                if (hasDefaultCase)
                    logError(format(getError(Error.onlyOneDefaultCasePerX), getPrettyLexemeType(GrLexemeType.switch_)),
                        getError(Error.defaultCaseAlreadyDef), "",
                        casePosition - current, getError(Error.prevDefaultCaseDef),
                        defaultCaseKeywordPosition);
                advance();
                hasDefaultCase = true;
                defaultCasePosition = current;
                defaultCaseKeywordPosition = casePosition;
                skipBlock();
            }
            else {
                hasCase = true;
                addGetInstruction(switchVar);
                GrType caseType = parseSubExpression().type;
                addBinaryOperator(GrLexemeType.equal, switchType, caseType, fileId);
                advance();

                jumpPosition = cast(uint) currentFunction.instructions.length;
                //Jumps to if(0).
                addInstruction(GrOpcode.jumpEqual);

                parseBlock(true);

                exitJumps ~= cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.jump);

                //Jumps to if(0).
                setInstruction(GrOpcode.jumpEqual, jumpPosition,
                    cast(int)(currentFunction.instructions.length - jumpPosition), true);
            }
        }

        if (hasDefaultCase) {
            const uint tmp = current;
            current = defaultCasePosition;
            parseBlock(true);
            current = tmp;
        }

        /* A switch is breakable. */
        closeBreakableSection();

        foreach (uint position; exitJumps)
            setInstruction(GrOpcode.jump, position,
                cast(int)(currentFunction.instructions.length - position), true);
    }

    /**
    ---
    select
    case(SUBEXPR) BLOCK
    case(SUBEXPR) BLOCK
    case() BLOCK
    ---
    */
    private void parseSelectStatement() {
        advance();

        /* A select is breakable. */
        openBreakableSection();
        uint[] exitJumps;
        uint jumpPosition, casePosition, defaultCasePosition, defaultCaseKeywordPosition;
        bool hasCase, hasDefaultCase;
        uint startJump = cast(uint) currentFunction.instructions.length;

        addInstruction(GrOpcode.startSelectChannel);
        while (get().type == GrLexemeType.case_) {
            casePosition = current;
            advance();
            if (get().type != GrLexemeType.leftParenthesis)
                logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexemeType.case_)),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));
            advance();

            if (get().type == GrLexemeType.rightParenthesis) {
                if (hasDefaultCase)
                    logError(format(getError(Error.onlyOneDefaultCasePerX), getPrettyLexemeType(GrLexemeType.select)),
                        getError(Error.defaultCaseAlreadyDef), "",
                        casePosition - current, getError(Error.prevDefaultCaseDef),
                        defaultCaseKeywordPosition);
                advance();
                hasDefaultCase = true;
                defaultCasePosition = current;
                defaultCaseKeywordPosition = casePosition;
                skipBlock();
            }
            else {
                hasCase = true;
                jumpPosition = cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.tryChannel);
                parseSubExpression();
                advance();

                addInstruction(GrOpcode.checkChannel);

                parseBlock(true);

                exitJumps ~= cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.jump);

                setInstruction(GrOpcode.tryChannel, jumpPosition,
                    cast(int)(currentFunction.instructions.length - jumpPosition), true);
            }
        }

        if (hasDefaultCase) {
            /* With a default case specified, it is processed if no previous case has been processed in the select statement.
             * The select statement is not blocking here because at least one case is executed. */
            const uint tmp = current;
            current = defaultCasePosition;
            parseBlock(true);
            current = tmp;
        }
        else {
            /* Without default case, the select statement is a blocking operation until one case is processed.
             * So, we add a yield then jump back to the beggining of the statement to evaluate the select statement again. */
            addInstruction(GrOpcode.yield);
            addInstruction(GrOpcode.jump,
                cast(int)(startJump - currentFunction.instructions.length), true);
        }

        /* A switch is breakable. */
        closeBreakableSection();

        foreach (uint position; exitJumps)
            setInstruction(GrOpcode.jump, position,
                cast(int)(currentFunction.instructions.length - position), true);
        addInstruction(GrOpcode.endSelectChannel);
    }

    /**
    ---
    while(SUBEXPR)
        BLOCK
    ---
    */
    private void parseWhileStatement() {
        const bool isNegative = get().type == GrLexemeType.until;
        advance();
        if (get().type != GrLexemeType.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(isNegative ? GrLexemeType
                    .until : GrLexemeType.while_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));

        /* While is breakable and continuable. */
        openBreakableSection();
        openContinuableSection();

        /* Continue jump. */
        setContinuableSectionDestination();

        uint conditionPosition, blockPosition = cast(uint) currentFunction.instructions.length;

        advance();
        parseSubExpression();

        advance();
        conditionPosition = cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.jumpEqual);

        parseBlock(true);

        addInstruction(GrOpcode.jump,
            cast(int)(blockPosition - currentFunction.instructions.length), true);
        setInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual, conditionPosition,
            cast(int)(currentFunction.instructions.length - conditionPosition), true);

        /* While is breakable and continuable. */
        closeBreakableSection();
        closeContinuableSection();
    }

    /**
    ---
    do BLOCK
    while(SUBEXPR)
    ---
    */
    private void parseDoWhileStatement() {
        advance();

        /* While is breakable and continuable. */
        openBreakableSection();
        openContinuableSection();

        uint blockPosition = cast(uint) currentFunction.instructions.length;

        parseBlock(true);

        bool isNegative;
        if (get().type == GrLexemeType.until)
            isNegative = true;
        else if (get().type != GrLexemeType.while_)
            logError(getError(Error.missingWhileOrUntilAfterLoop),
                format(getError(Error.expectedWhileOrUntilFoundX), getPrettyLexemeType(get().type)));
        advance();

        /* Continue jump. */
        setContinuableSectionDestination();

        if (get().type != GrLexemeType.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(isNegative ? GrLexemeType
                    .until : GrLexemeType.while_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));

        advance();
        parseSubExpression();
        advance();

        addInstruction(isNegative ? GrOpcode.jumpEqual : GrOpcode.jumpNotEqual,
            cast(int)(blockPosition - currentFunction.instructions.length), true);

        /* While is breakable and continuable. */
        closeBreakableSection();
        closeContinuableSection();
    }

    private GrVariable parseDeclarableArgument() {
        GrVariable lvalue;
        GrType type = GrBaseType.void_;
        bool isAuto, isTyped = true;
        switch (get().type) with (GrLexemeType) {
        case autoType:
            isAuto = true;
            checkAdvance();
            break;
        case intType: .. case chanType:
            type = parseType();
            break;
        case identifier:
            if (_data.isTypeDeclared(get().svalue, get().fileId, false))
                type = parseType();
            else
                isTyped = false;
            break;
        default:
            logError(getError(Error.varDefOrRefExpected),
                format(getError(Error.varOrRefExpectedFoundX), getPrettyLexemeType(get()
                    .type)));
            break;
        }
        GrLexeme identifier = get();
        if (identifier.type != GrLexemeType.identifier)
            logError(getError(Error.varNameExpected),
                format(getError(Error.varNameExpectedFoundX), getPrettyLexemeType(get().type)));

        lvalue = registerLocalVariable(identifier.svalue, type);
        lvalue.isAuto = isTyped ? isAuto : true;

        //A composite type does not need to be initialized.
        if (lvalue.type == GrBaseType.class_)
            lvalue.isInitialized = true;

        checkAdvance();
        return lvalue;
    }

    /**
    The for statement takes an iterator and a list.
    */
    private void parseForStatement() {
        advance();
        const uint fileId = get().fileId;
        if (get().type != GrLexemeType.leftParenthesis)
            logError(format(getError(Error.missingParenthesesAfterX), getPrettyLexemeType(GrLexemeType.for_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.leftParenthesis), getPrettyLexemeType(get().type)));

        advance();
        currentFunction.openScope();

        GrVariable variable = parseDeclarableArgument();

        if (get().type != GrLexemeType.comma)
            logError(format(getError(Error.missingCommaInX), getPrettyLexemeType(GrLexemeType.for_)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(GrLexemeType.comma), getPrettyLexemeType(
                    get().type)));
        advance();

        //From length to 0
        GrType containerType = parseSubExpression().type;

        switch (containerType.baseType) with (GrBaseType) {
        case list_: {
                /* Init */
                GrType subType = grUnmangle(containerType.mangledType);
                GrVariable iterator = registerSpecialVariable("iterator", grInt);
                GrVariable index = registerSpecialVariable("index", grInt);
                GrVariable list = registerSpecialVariable("list", containerType);

                if (variable.isAuto && subType.baseType != GrBaseType.void_) {
                    variable.isAuto = false;
                    variable.type = subType;
                    setVariableRegister(variable);
                }

                addSetInstruction(list, fileId, containerType, true);
                final switch (subType.baseType) with (GrBaseType) {
                case bool_:
                case int_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.length_int);
                    break;
                case float_:
                    addInstruction(GrOpcode.length_float);
                    break;
                case string_:
                    addInstruction(GrOpcode.length_string);
                    break;
                case list_:
                case class_:
                case foreign:
                case chan:
                case reference:
                    addInstruction(GrOpcode.length_object);
                    break;
                case void_:
                case null_:
                case internalTuple:
                    logError(format(getError(Error.listCantBeOfTypeX), getPrettyType(
                            grList(subType))),
                        getError(Error.invalidListType));
                    break;
                }
                addInstruction(GrOpcode.setupIterator);
                addSetInstruction(iterator, fileId);

                //Set index to -1
                addIntConstant(-1);
                addSetInstruction(index, fileId);

                /* For is breakable and continuable. */
                openBreakableSection();
                openContinuableSection();

                /* Continue jump. */
                setContinuableSectionDestination();

                advance();
                uint blockPosition = cast(uint) currentFunction.instructions.length;

                addGetInstruction(iterator, GrType(GrBaseType.int_));
                addInstruction(GrOpcode.decrement_int);
                addSetInstruction(iterator, fileId);

                addGetInstruction(iterator, GrType(GrBaseType.int_));
                uint jumpPosition = cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.jumpEqual);

                //Set Index
                addGetInstruction(list);
                addGetInstruction(index);
                addInstruction(GrOpcode.increment_int);
                addSetInstruction(index, fileId, grVoid, true);
                final switch (subType.baseType) with (GrBaseType) {
                case bool_:
                case int_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.index2_int);
                    break;
                case float_:
                    addInstruction(GrOpcode.index2_float);
                    break;
                case string_:
                    addInstruction(GrOpcode.index2_string);
                    break;
                case list_:
                case class_:
                case foreign:
                case chan:
                case reference:
                    addInstruction(GrOpcode.index2_object);
                    break;
                case void_:
                case null_:
                case internalTuple:
                    logError(format(getError(Error.listCantBeOfTypeX), getPrettyType(
                            grList(subType))),
                        getError(Error.invalidListType));
                    break;
                }
                convertType(subType, variable.type, fileId);
                addSetInstruction(variable, fileId);

                parseBlock(true);

                addInstruction(GrOpcode.jump,
                    cast(int)(blockPosition - currentFunction.instructions.length), true);
                setInstruction(GrOpcode.jumpEqual, jumpPosition,
                    cast(int)(currentFunction.instructions.length - jumpPosition), true);

                /* For is breakable and continuable. */
                closeBreakableSection();
                closeContinuableSection();
            }
            break;
        case foreign:
        case class_: {
                GrVariable iterator = registerSpecialVariable("iterator", containerType);

                GrType subType;
                GrFunction nextFunc;
                GrPrimitive nextPrim = _data.getPrimitive("next", [
                        containerType
                    ]);
                if (nextPrim) {
                    if (nextPrim.outSignature.length != 2 || (nextPrim.outSignature.length >= 1
                            && nextPrim.outSignature[0].baseType != grBool)) {
                        logError(format(getError(Error.primXMustRetBoolAndVal), getPrettyFunctionCall("next",
                                [containerType])),
                            getError(Error.signatureMismatch));
                    }
                    subType = nextPrim.outSignature[1];
                }
                else {
                    nextFunc = getFunction("next", [containerType], fileId);
                    if (!nextFunc) {
                        logError(format(getError(Error.xNotDef), getPrettyFunctionCall("next",
                                [containerType])), getError(Error.notIterable));
                    }

                    if (nextFunc.outSignature.length != 2 || (nextFunc.outSignature.length >= 1
                            && nextFunc.outSignature[0].baseType != grBool)) {
                        logError(format(getError(Error.funcXMustRetBoolAndVal), getPrettyFunction(
                                nextFunc)),
                            getError(Error.signatureMismatch));
                    }
                    subType = nextFunc.outSignature[1];
                }

                if (variable.isAuto && subType.baseType != GrBaseType.void_) {
                    variable.isAuto = false;
                    variable.type = subType;
                    setVariableRegister(variable);
                }
                addSetInstruction(iterator, fileId, containerType);

                /* For is breakable and continuable. */
                openBreakableSection();
                openContinuableSection();

                /* Continue jump. */
                setContinuableSectionDestination();

                advance();
                uint blockPosition = cast(uint) currentFunction.instructions.length;

                addGetInstruction(iterator, containerType);
                if (nextPrim)
                    addInstruction(GrOpcode.primitiveCall, nextPrim.index);
                else
                    addFunctionCall(nextFunc, fileId);
                addSetInstruction(variable, fileId);

                uint jumpPosition = cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.jumpEqual);

                parseBlock(true);

                addInstruction(GrOpcode.jump,
                    cast(int)(blockPosition - currentFunction.instructions.length), true);
                setInstruction(GrOpcode.jumpEqual, jumpPosition,
                    cast(int)(currentFunction.instructions.length - jumpPosition), true);

                /* For is breakable and continuable. */
                closeBreakableSection();
                closeContinuableSection();
            }
            break;
        default:
            logError(format(getError(Error.forCantIterateOverX), getPrettyType(containerType)),
                getError(Error.notIterable));
            break;
        }
        currentFunction.closeScope();
    }

    /// Skips everything from a `(` to its matching `)`.
    private void skipParenthesis() {
        if (get().type != GrLexemeType.leftParenthesis)
            return;
        advance();

        __loop: while (!isEnd()) {
            switch (get().type) with (GrLexemeType) {
            case rightParenthesis:
                advance();
                return;
            case rightBracket:
            case rightCurlyBrace:
            case semicolon:
                break __loop;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }
    }

    /// Skips everything from a `[` to its matching `]`.
    private void skipBrackets() {
        if (get().type != GrLexemeType.leftBracket)
            return;
        advance();

        __loop: while (!isEnd()) {
            switch (get().type) with (GrLexemeType) {
            case rightBracket:
                advance();
                return;
            case rightParenthesis:
            case rightCurlyBrace:
            case semicolon:
                break __loop;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }
    }

    /// Returns the number of parameters separated by commas inside a pair of (), [] or {}.
    private int checkArity() {
        int arity;
        const int position = current;

        bool useParenthesis, useBrackets, useCurlyBraces;

        switch (get().type) with (GrLexemeType) {
        case leftParenthesis:
            advance();
            useParenthesis = true;
            if (get(1).type != GrLexemeType.rightParenthesis)
                arity++;
            break;
        case leftBracket:
            advance();
            useBrackets = true;
            if (get(1).type != GrLexemeType.rightBracket)
                arity++;
            break;
        case leftCurlyBrace:
            advance();
            useCurlyBraces = true;
            if (get(1).type != GrLexemeType.rightCurlyBrace)
                arity++;
            break;
        default:
            logError(getError(Error.cantEvalArityUnknownCompound), getError(Error.arityEvalError));
            break;
        }

        __loop: while (!isEnd()) {
            switch (get().type) with (GrLexemeType) {
            case comma:
                arity++;
                advance();
                break;
            case rightParenthesis:
                if (!useParenthesis)
                    goto default;
                break __loop;
            case rightBracket:
                if (!useBrackets)
                    goto default;
                break __loop;
            case rightCurlyBrace:
                if (!useCurlyBraces)
                    goto default;
                break __loop;
            case semicolon:
                break __loop;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }

        current = position;
        return arity;
    }

    /**
    There are 3 types of loop.
    - The infinite loop with no parameters:
    ---
    loop printl("I'm infinite !");
    ---
    - The finite loop, with 1 parameter:
    ---
    loop(5) printl("I'm printed 5 times !");
    ---
    - The finite loop with an iterator:
    ---
    loop(i, 5) printl("Iterator = " ~ i as string);
    ---
    */
    private void parseLoopStatement() {
        bool isInfinite, hasCustomIterator;
        GrVariable iterator, customIterator;

        const uint fileId = get().fileId;
        currentFunction.openScope();
        advance();
        if (get().type == GrLexemeType.leftParenthesis) {
            const int arity = checkArity();
            advance();
            if (arity == 2) {
                hasCustomIterator = true;
                customIterator = parseDeclarableArgument();
                if (customIterator.isAuto) {
                    customIterator.isAuto = false;
                    customIterator.type = grInt;
                    setVariableRegister(customIterator);
                }
                else if (customIterator.type != grInt) {
                    logError(format(getError(Error.typeOfIteratorMustBeIntNotX), getPrettyType(
                            customIterator.type)),
                        getError(Error.iteratorMustBeInt));
                }

                addIntConstant(0);
                addSetInstruction(customIterator, fileId);

                if (get().type != GrLexemeType.comma)
                    logError(format(getError(Error.missingCommaInX), getPrettyLexemeType(GrLexemeType.loop)),
                        format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                            GrLexemeType.comma), getPrettyLexemeType(get().type)));
                advance();
            }

            /* Init */
            iterator = registerSpecialVariable("iterator", GrType(GrBaseType.int_));

            //Init counter
            GrType type = parseSubExpression().type;
            advance();

            convertType(type, grInt, fileId);
            addInstruction(GrOpcode.setupIterator);
            addSetInstruction(iterator, fileId);
        }
        else
            isInfinite = true;

        /* For is breakable and continuable. */
        openBreakableSection();
        openContinuableSection();

        /* Continue jump. */
        setContinuableSectionDestination();

        uint blockPosition = cast(uint) currentFunction.instructions.length;
        uint jumpPosition;

        if (!isInfinite) {
            addGetInstruction(iterator, grInt, false);
            addInstruction(GrOpcode.decrement_int);
            addSetInstruction(iterator, fileId);

            addGetInstruction(iterator, grInt);
            jumpPosition = cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.jumpEqual);
        }

        parseBlock(true);

        if (!isInfinite && hasCustomIterator) {
            addGetInstruction(customIterator, grInt, false);
            addInstruction(GrOpcode.increment_int);
            addSetInstruction(customIterator, fileId);
        }

        addInstruction(GrOpcode.jump,
            cast(int)(blockPosition - currentFunction.instructions.length), true);
        if (!isInfinite)
            setInstruction(GrOpcode.jumpEqual, jumpPosition,
                cast(int)(currentFunction.instructions.length - jumpPosition), true);

        /* For is breakable and continuable. */
        closeBreakableSection();
        closeContinuableSection();
        currentFunction.closeScope();
    }

    /**
    The type of the return must be that of the signature of the function.
    ---
    return "Hello"; // Returns a string.
    return; // Returns nothing but still end the function.
    ---
    */
    private void parseReturnStatement() {
        checkDeferStatement();
        checkAdvance();
        if (currentFunction.isTask) {
            if (!currentFunction.instructions.length
                || currentFunction.instructions[$ - 1].opcode != GrOpcode.kill_)
                addKill();
        }
        else {
            auto types = parseExpressionList();

            addReturn();
            if (types.length != currentFunction.outSignature.length) {
                logError(getError(Error.expectedXRetValFoundY),
                    format(getError(currentFunction.outSignature.length > 1 ? Error.expectedXRetValsFoundY
                        : Error.expectedXRetValFoundY),
                        currentFunction.outSignature.length, types.length),
                    format(getError(Error.retSignatureOfTypeX), getPrettyFunctionCall("",
                        currentFunction.outSignature)), -1);
            }
            for (int i; i < types.length; i++) {
                if (types[i] != currentFunction.outSignature[i])
                    logError(format(getError(Error.retTypeXNotMatchSignatureY), getPrettyType(
                            types[i]), getPrettyType(
                            currentFunction.outSignature[i])),
                        format(getError(Error.expectedXVal), getPrettyType(currentFunction.outSignature[i])),
                        format(getError(Error.retSignatureOfTypeX), getPrettyFunctionCall("",
                            currentFunction.outSignature)), -1);
            }
        }
    }

    /// Add a `return` instruction that pop the callstack.
    private void addReturn() {
        if (_options & GrOption.profile) {
            addInstruction(GrOpcode.debugProfileEnd);
        }
        addInstruction(GrOpcode.return_);
    }

    /// Add a `kill` instruction that stops the current task.
    private void addKill() {
        checkDeferStatement();
        if (_options & GrOption.profile) {
            addInstruction(GrOpcode.debugProfileEnd);
        }
        addInstruction(GrOpcode.kill_);
    }

    /// Add a `killall` instruction that stops every tasks.
    private void addKillAll() {
        checkDeferStatement();
        if (_options & GrOption.profile) {
            addInstruction(GrOpcode.debugProfileEnd);
        }
        addInstruction(GrOpcode.killAll_);
    }

    /// The more it is, the less you need parenthesis.
    private uint getLeftOperatorPriority(GrLexemeType type) {
        switch (type) with (GrLexemeType) {
        case assign: .. case powerAssign:
            return 0;
        case arrow:
            return 1;
        case or:
            return 2;
        case and:
            return 3;
        case equal:
        case doubleEqual:
        case threeWayComparison:
        case notEqual:
        case greaterOrEqual:
        case greater:
        case lesserOrEqual:
        case lesser:
            return 4;
        case interval:
            return 5;
        case bitwiseOr:
        case bitwiseAnd:
        case bitwiseXor:
            return 6;
        case leftShift:
        case rightShift:
            return 7;
        case add:
        case substract:
            return 8;
        case multiply:
        case divide:
            return 9;
        case remainder:
            return 10;
        case power:
            return 11;
        case send:
            return 12;
        case not:
        case plus:
        case minus:
        case receive:
            return 13;
        case bitwiseNot:
            return 14;
        case increment:
        case decrement:
            return 15;
        default:
            logError(getError(Error.opNotListedInOpPriorityTable),
                getError(Error.unknownOpPriority));
            return 0;
        }
    }

    /// The more it is, the less you need parenthesis.
    private uint getRightOperatorPriority(GrLexemeType type) {
        switch (type) with (GrLexemeType) {
        case assign: .. case powerAssign:
            return 20;
        case arrow:
            return 1;
        case or:
            return 2;
        case and:
            return 3;
        case equal:
        case doubleEqual:
        case threeWayComparison:
        case notEqual:
        case greaterOrEqual:
        case greater:
        case lesserOrEqual:
        case lesser:
            return 4;
        case interval:
            return 5;
        case bitwiseOr:
        case bitwiseAnd:
        case bitwiseXor:
            return 6;
        case leftShift:
        case rightShift:
            return 7;
        case add:
        case substract:
            return 8;
        case multiply:
        case divide:
            return 9;
        case remainder:
            return 10;
        case power:
            return 11;
        case send:
            return 12;
        case not:
        case plus:
        case minus:
        case receive:
            return 13;
        case bitwiseNot:
            return 14;
        case increment:
        case decrement:
            return 15;
        default:
            logError(getError(Error.opNotListedInOpPriorityTable),
                getError(Error.unknownOpPriority));
            return 0;
        }
    }

    /// Attempt to convert `src` type to the `dst` type.
    private GrType convertType(GrType src, GrType dst, uint fileId = 0,
        bool noFail = false, bool isExplicit = false) {
        if (src.baseType == dst.baseType) {
            final switch (src.baseType) with (GrBaseType) {
            case function_:
                if (src.mangledType == dst.mangledType
                    && src.mangledReturnType == dst.mangledReturnType)
                    return dst;
                break;
            case task:
                if (src.mangledType == dst.mangledType)
                    return dst;
                break;
            case null_:
                break;
            case void_:
            case bool_:
            case int_:
            case float_:
            case string_:
            case enum_:
                return dst;
            case class_:
                string className = src.mangledType;
                for (;;) {
                    if (className == dst.mangledType)
                        return dst;
                    const GrClassDefinition classType = getClass(className, fileId);
                    if (!classType.parent.length)
                        break;
                    className = classType.parent;
                }
                break;
            case list_:
            case chan:
            case reference:
            case internalTuple:
                if (dst.mangledType == src.mangledType)
                    return dst;
                break;
            case foreign:
                string foreignName = src.mangledType;
                for (;;) {
                    if (dst.mangledType == foreignName)
                        return dst;
                    const GrForeignDefinition foreignType = _data.getForeign(foreignName);
                    if (!foreignType.parent.length)
                        break;
                    foreignName = foreignType.parent;
                }
                break;
            }
        }

        if (src.baseType == GrBaseType.null_ && (dst.baseType == GrBaseType.class_
                || dst.baseType == GrBaseType.foreign))
            return dst;

        if (src.baseType == GrBaseType.internalTuple || dst.baseType == GrBaseType.internalTuple)
            logError(format(getError(Error.expectedXFoundY), getPrettyType(dst), getPrettyType(src)),
                getError(Error.mismatchedTypes), "", -1);

        if (dst.baseType == GrBaseType.bool_) {
            final switch (src.baseType) with (GrBaseType) {
            case function_:
            case task:
            case void_:
            case bool_:
            case int_:
            case float_:
            case string_:
            case internalTuple:
            case enum_:
                break;
            case list_:
            case class_:
            case foreign:
            case chan:
            case reference:
            case null_:
                addInstruction(GrOpcode.isNonNull_object);
                return dst;
            }
        }

        //User-defined conversions.
        if (addCustomConversion(src, dst, isExplicit, get().fileId) == dst)
            return dst;

        if (!noFail)
            logError(format(getError(Error.expectedXFoundY), getPrettyType(dst), getPrettyType(src)),
                getError(Error.mismatchedTypes), "", -1);
        return GrType(GrBaseType.void_);
    }

    /// Convert with a primitive or function.
    private GrType addCustomConversion(GrType leftType, GrType rightType,
        bool isExplicit, uint fileId) {
        GrType resultType = GrBaseType.void_;

        //as opposed to other functions, we need the return type (rightType) to be part of the signature.
        string name = "@as";
        GrType[] signature = [leftType, rightType];

        //GrPrimitive check
        const GrPrimitive primitive = _data.getPrimitive(name, signature);
        if (primitive) {
            //Some implicit conversions are disabled.
            //ex: float -> int because we might lose information.
            if (primitive.isExplicit && !isExplicit)
                return resultType;
            addInstruction(GrOpcode.primitiveCall, primitive.index);
            if (primitive.outSignature.length != 1uL) {
                logError(getError(Error.opMustHave1RetVal),
                    format(getError(primitive.outSignature.length > 1 ? Error.expectedXRetValsFoundY
                        : Error.expectedXRetValFoundY), 1, primitive.outSignature.length));
            }
            resultType = rightType;
        }

        //GrFunction check
        if (resultType.baseType == GrBaseType.void_) {
            GrFunction func = getFunction(name, signature, fileId);
            if (func) {
                const GrType[] outSignature = addFunctionCall(func, fileId);
                if (outSignature.length != 1uL) {
                    logError(getError(Error.opMustHave1RetVal),
                        format(getError(primitive.outSignature.length > 1 ? Error.expectedXRetValsFoundY
                            : Error.expectedXRetValFoundY), 1, primitive.outSignature.length));
                }
                resultType = rightType;
            }
        }
        return resultType;
    }

    private GrType parseObjectBuilder() {
        if (get().type != GrLexemeType.new_)
            logError(format(getError(Error.expectedXFoundY), getPrettyLexemeType(GrLexemeType.new_), getPrettyLexemeType(
                    get()
                    .type)), format(getError(Error.missingX), getPrettyLexemeType(
                    GrLexemeType.new_)));
        checkAdvance();
        if (get().type != GrLexemeType.identifier)
            logError(format(getError(Error.expectedXFoundY), getPrettyLexemeType(GrLexemeType.identifier), getPrettyLexemeType(
                    get()
                    .type)), getError(Error.missingIdentifier));
        uint fileId = get().fileId;
        GrType classType = parseType(true);
        if (classType.baseType != GrBaseType.class_)
            logError(format(getError(Error.xNotClassType), getPrettyType(classType)),
                getError(Error.invalidType), "", -1);
        GrClassDefinition class_ = getClass(classType.mangledType, fileId);
        if (!class_)
            logError(format(getError(Error.xNotDecl),
                    getPrettyType(classType)), getError(Error.unknownClass), "", -1);
        addInstruction(GrOpcode.new_, cast(uint) class_.index);

        bool[] initFields;
        uint[] lexPositions;
        initFields.length = class_.fields.length;
        lexPositions.length = class_.fields.length;

        // Init
        if (get().type == GrLexemeType.leftCurlyBrace) {
            checkAdvance();
            while (!isEnd()) {
                if (get().type == GrLexemeType.rightCurlyBrace) {
                    checkAdvance();
                    break;
                }
                else if (get().type == GrLexemeType.identifier) {
                    const string fieldName = get().svalue;
                    checkAdvance();
                    bool hasField = false;
                    for (int i; i < class_.fields.length; ++i) {
                        if (class_.fields[i] == fieldName) {
                            hasField = true;

                            if (initFields[i])
                                logError(format(getError(Error.fieldXInitMultipleTimes), fieldName),
                                    format(getError(Error.xAlreadyInit), fieldName),
                                    "", -1, getError(Error.prevInit), lexPositions[i] - 1);

                            initFields[i] = true;
                            lexPositions[i] = current;

                            GrVariable fieldLValue = new GrVariable;
                            fieldLValue.isInitialized = false;
                            fieldLValue.isField = true;
                            fieldLValue.type = class_.signature[i];
                            fieldLValue.register = i;
                            fieldLValue.fileId = get().fileId;
                            fieldLValue.lexPosition = current;
                            addInstruction(GrOpcode.fieldLoad2, fieldLValue.register);
                            parseAssignList([fieldLValue], true);
                            break;
                        }
                    }
                    if (!hasField)
                        logError(format(getError(Error.fieldXNotExist), fieldName), getError(
                                Error.unknownField));
                }
                else {
                    logError(format(getError(Error.expectedFieldNameFoundX), getPrettyLexemeType(get()
                            .type)), getError(Error.missingField));
                }
            }
        }

        for (int i; i < class_.fields.length; ++i) {
            if (initFields[i])
                continue;
            GrVariable fieldLValue = new GrVariable;
            fieldLValue.isInitialized = false;
            fieldLValue.isField = true;
            fieldLValue.type = class_.signature[i];
            fieldLValue.register = i;
            fieldLValue.fileId = get().fileId;
            fieldLValue.lexPosition = current;
            addInstruction(GrOpcode.fieldLoad2, fieldLValue.register);
            addDefaultValue(fieldLValue.type, fileId);
            addSetInstruction(fieldLValue, fileId, fieldLValue.type);
        }

        return classType;
    }

    /**
    Parse a list creation.
    The type is optional if the list is not empty.
    If no type is specified, the list subtype is set to the type of the first element.
    ---
    list(int)[1, 2, 3]
    ["1", "2", "3"]
    list(string)[]
    ---
    */
    private GrType parseListBuilder() {
        GrType listType = GrType(GrBaseType.list_);
        GrType subType = grVoid;
        const uint fileId = get().fileId;

        //Explicit type like: list(int)[1, 2, 3]
        if (get().type == GrLexemeType.listType) {
            checkAdvance();
            string[] temp;
            auto signature = parseInSignature(temp, true);
            if (signature.length > 1)
                logError(getError(Error.listCanOnlyContainOneTypeOfVal), getError(Error.conflictingListSignature),
                    format(getError(Error.tryUsingXInstead), getPrettyType(grList(signature[0]))), -1);
            subType = signature[0];
            listType.mangledType = grMangleSignature(signature);
            if (subType.baseType == GrBaseType.void_)
                logError(format(getError(Error.listCantBeOfTypeX), getPrettyType(listType)),
                    getError(Error.invalidListType));
        }

        if (get().type != GrLexemeType.leftBracket)
            logError(format(getError(Error.missingBracketsAfterX), getPrettyType(listType)),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(get().type)));
        advance();

        int listSize;
        while (get().type != GrLexemeType.rightBracket) {
            if (subType.baseType == GrBaseType.void_) {
                //Implicit type specified by the type of the first element.
                subType = parseSubExpression(
                    GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA
                        | GR_SUBEXPR_EXPECTING_VALUE).type;
                listType.mangledType = grMangleSignature([subType]);
                if (subType.baseType == GrBaseType.void_)
                    logError(format(getError(Error.listCantBeOfTypeX), getPrettyType(listType)),
                        getError(Error.invalidListType));
            }
            else {
                convertType(parseSubExpression(
                        GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_EXPECTING_VALUE)
                        .type, subType, fileId);
            }
            listSize++;

            if (get().type == GrLexemeType.rightBracket)
                break;
            if (get().type != GrLexemeType.comma)
                logError(getError(Error.indexesShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.comma), getPrettyLexemeType(get().type)));
            checkAdvance();
        }

        final switch (subType.baseType) with (GrBaseType) {
        case bool_:
        case int_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.list_int, listSize);
            break;
        case float_:
            addInstruction(GrOpcode.list_float, listSize);
            break;
        case string_:
            addInstruction(GrOpcode.list_string, listSize);
            break;
        case list_:
        case class_:
        case foreign:
        case chan:
        case reference:
            addInstruction(GrOpcode.list_object, listSize);
            break;
        case void_:
        case null_:
        case internalTuple:
            logError(format(getError(Error.listCantBeOfTypeX), getPrettyType(grList(subType))),
                getError(Error.invalidListType));
            break;
        }
        advance();
        return listType;
    }

    private GrType parseListIndex(GrType listType) {
        const uint fileId = get().fileId;
        advance();

        for (;;) {
            if (get().type == GrLexemeType.comma)
                logError(getError(Error.expectedIndexFoundComma), getError(Error.missingVal));
            auto index = parseSubExpression(
                GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA
                    | GR_SUBEXPR_EXPECTING_VALUE).type;
            if (index.baseType == GrBaseType.void_)
                logError(getError(Error.expectedIntFoundNothing), getError(Error.missingVal));
            convertType(index, grInt, fileId);

            if (get().type == GrLexemeType.rightBracket) {
                switch (listType.baseType) with (GrBaseType) {
                case list_:
                    const GrType subType = grUnmangle(listType.mangledType);
                    final switch (subType.baseType) with (GrBaseType) {
                    case bool_:
                    case int_:
                    case function_:
                    case task:
                    case enum_:
                        addInstruction(GrOpcode.index_int);
                        break;
                    case float_:
                        addInstruction(GrOpcode.index_float);
                        break;
                    case string_:
                        addInstruction(GrOpcode.index_string);
                        break;
                    case list_:
                    case class_:
                    case foreign:
                    case chan:
                    case reference:
                        addInstruction(GrOpcode.index_object);
                        break;
                    case void_:
                    case null_:
                    case internalTuple:
                        logError(format(getError(Error.listCantBeOfTypeX), getPrettyType(
                                grList(subType))),
                            getError(Error.invalidListType));
                        break;
                    }
                    listType = subType;
                    break;
                default:
                    logError(getError(Error.invalidListType),
                        format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                            GrLexemeType.listType),
                            getPrettyType(listType)));
                }
                break;
            }
            if (get().type != GrLexemeType.comma)
                logError(getError(Error.indexesShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.comma), getPrettyLexemeType(get().type)));
            checkAdvance();
            if (get().type == GrLexemeType.rightBracket)
                logError(getError(Error.indexesShouldBeSeparatedByComma),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.comma), getPrettyLexemeType(get().type)));

            switch (listType.baseType) with (GrBaseType) {
            case list_:
                const GrType subType = grUnmangle(listType.mangledType);
                final switch (subType.baseType) with (GrBaseType) {
                case bool_:
                case int_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.index_int);
                    break;
                case float_:
                    addInstruction(GrOpcode.index_float);
                    break;
                case string_:
                    addInstruction(GrOpcode.index_string);
                    break;
                case list_:
                case class_:
                case foreign:
                case chan:
                case reference:
                    addInstruction(GrOpcode.index_object);
                    break;
                case void_:
                case null_:
                case internalTuple:
                    logError(format(getError(Error.listCantBeOfTypeX), getPrettyType(listType)),
                        getError(Error.invalidListType));
                    break;
                }
                listType = subType;
                break;
            default:
                logError(getError(Error.invalidListType),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.listType),
                        getPrettyType(listType)));
            }
        }
        advance();
        return listType;
    }

    /**
    Parse a cast, or `as` operation.
    ---
    1 as float
    ---
    */
    private GrType parseConversionOperator(GrType[] typeStack) {
        const uint fileId = get().fileId;
        if (!typeStack.length)
            logError(getError(Error.noValToConv), getError(Error.missingVal));
        advance();
        auto asType = parseType();
        convertType(typeStack[$ - 1], asType, fileId, false, true);
        typeStack[$ - 1] = asType;
        return asType;
    }

    /// Parse an assignable (named) element.
    private GrVariable parseLValue() {
        const uint fileId = get().fileId;
        if (get().type != GrLexemeType.identifier)
            logError(format(getError(Error.expectedVarFoundX), getPrettyLexemeType(get()
                    .type)), getError(Error.missingVar));

        const string identifierName = get().svalue;

        checkAdvance();

        GrVariable localLValue = currentFunction.getLocal(identifierName);
        if (localLValue !is null)
            return localLValue;

        GrVariable globalLValue = getGlobalVariable(identifierName, fileId);
        if (globalLValue !is null)
            return globalLValue;

        logError(format(getError(Error.expectedVarFoundX), getPrettyLexemeType(get()
                .type)), getError(Error.missingVar));
        return null;
    }

    /// Parse a single expression, not a statement.
    private void parseExpression() {
        bool isAssignmentList;
        const auto tempPos = current;
        __skipLoop: while (!isEnd()) {
            switch (get().type) with (GrLexemeType) {
            case leftBracket:
                skipBrackets();
                break;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            case semicolon:
                isAssignmentList = false;
                break __skipLoop;
            case comma:
                isAssignmentList = true;
                break __skipLoop;
            default:
                checkAdvance();
                break;
            }
        }
        current = tempPos;

        if (isAssignmentList) {
            //Get list of lvalues
            GrVariable[] lvalues;
            do {
                if (lvalues.length)
                    checkAdvance();
                //Identifier
                if (get().type != GrLexemeType.identifier)
                    logError(format(getError(Error.expectedIdentifierFoundX), getPrettyLexemeType(get()
                            .type)), getError(Error.missingIdentifier));
                lvalues ~= parseSubExpression(
                    GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_ASSIGN
                        | GR_SUBEXPR_EXPECTING_LVALUE).lvalue;
            }
            while (get().type == GrLexemeType.comma);

            parseAssignList(lvalues);
        }
        else {
            parseSubExpression(GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_MUST_CLEAN);
            checkAdvance();
        }
    }

    /// Parse the right side of a multiple assignment.
    private GrType[] parseExpressionList() {
        GrType[] expressionTypes;
        for (;;) {
            GrType type = parseSubExpression(
                GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_TERMINATE_COMMA
                    | GR_SUBEXPR_EXPECTING_VALUE).type;
            if (type.baseType == GrBaseType.internalTuple) {
                auto types = grUnpackTuple(type);
                if (!types.length)
                    logError(getError(Error.exprYieldsNoVal), getError(
                            Error.expectedValFoundNothing));
                else {
                    foreach (subType; types)
                        expressionTypes ~= subType;
                }
            }
            else if (type.baseType != GrBaseType.void_)
                expressionTypes ~= type;
            if (get().type != GrLexemeType.comma)
                break;
            checkAdvance();
        }
        if (get().type != GrLexemeType.semicolon)
            logError(getError(Error.missingSemicolonAfterExprList),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.semicolon), getPrettyLexemeType(get().type)));
        checkAdvance();
        return expressionTypes;
    }

    /// Parse the right side of a multiple assignment and associate them with the `lvalues`.
    private void parseAssignList(GrVariable[] lvalues, bool isInitialization = false) {
        const uint fileId = get().fileId;
        switch (get().type) with (GrLexemeType) {
        case assign:
            advance();
            GrType[] expressionTypes = parseExpressionList();

            if (expressionTypes.length > lvalues.length) {
                logError(format(getError(lvalues.length > 1 ? Error.tryingAssignXValsToYVars
                        : Error.tryingAssignXValsToYVar), expressionTypes.length, lvalues.length),
                    getError(Error.moreValThanVarToAssign), "", -1);
            }
            else if (!expressionTypes.length) {
                logError(getError(Error.assignationMissingVal), getError(Error.expressionEmpty), "", -1);
            }

            int variableIndex = to!int(lvalues.length) - 1;
            int expressionIndex = to!int(expressionTypes.length) - 1;
            bool passThrough;
            GrVariable[] skippedLvalues;
            while (variableIndex > expressionIndex) {
                addSetInstruction(lvalues[variableIndex], fileId,
                    expressionTypes[expressionIndex], true);
                variableIndex--;
                passThrough = true;
            }
            if (passThrough) {
                if (expressionTypes[expressionIndex].baseType == GrBaseType.void_) {
                    skippedLvalues ~= lvalues[variableIndex];
                }
                else {
                    addSetInstruction(lvalues[variableIndex], fileId,
                        lvalues[variableIndex + 1].type, false);
                }
                variableIndex--;
                expressionIndex--;
            }
            while (variableIndex >= 0) {
                if (expressionTypes[expressionIndex].baseType == GrBaseType.void_) {
                    skippedLvalues ~= lvalues[variableIndex];
                }
                else {
                    while (skippedLvalues.length) {
                        addSetInstruction(skippedLvalues[$ - 1], fileId,
                            expressionTypes[expressionIndex], true);
                        skippedLvalues.length--;
                    }
                    addSetInstruction(lvalues[variableIndex], fileId,
                        expressionTypes[expressionIndex], false);
                }
                variableIndex--;
                expressionIndex--;
            }
            if (skippedLvalues.length)
                logError(getError(Error.firstValOfAssignmentListCantBeEmpty), getError(
                        Error.missingVal));
            break;
        case semicolon:
            if (isInitialization) {
                foreach (lvalue; lvalues) {
                    if (lvalue.isAuto)
                        logError(getError(Error.cantInferTypeWithoutAssignment),
                            getError(Error.missingTypeInfoOrInitVal), "", -1);
                    addDefaultValue(lvalue.type, fileId);
                    addSetInstruction(lvalue, fileId, lvalue.type);
                }
            }
            advance();
            break;
        default:
            logError(getError(Error.missingSemicolonAfterAssignmentList),
                format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                    GrLexemeType.semicolon), getPrettyLexemeType(get().type)));
        }
    }

    private void addDefaultValue(GrType type, uint fileId) {
        final switch (type.baseType) with (GrBaseType) {
        case int_:
        case bool_:
        case enum_:
            addIntConstant(0);
            break;
        case float_:
            addFloatConstant(0f);
            break;
        case string_:
            addStringConstant("");
            break;
        case function_:
            GrType[] inSignature = grUnmangleSignature(type.mangledType);
            GrType[] outSignature = grUnmangleSignature(type.mangledReturnType);
            string[] inputs;
            for (int i; i < inSignature.length; ++i) {
                inputs ~= to!string(i);
            }
            preBeginFunction("$anon", fileId, inSignature, inputs, false, outSignature, true);
            openDeferrableSection();
            foreach (outType; outSignature) {
                addDefaultValue(outType, fileId);
            }
            addReturn();
            closeDeferrableSection();
            registerDeferBlocks();
            endFunction();
            break;
        case task:
            GrType[] inSignature = grUnmangleSignature(type.mangledType);
            GrType[] outSignature = grUnmangleSignature(type.mangledReturnType);
            string[] inputs;
            for (int i; i < inSignature.length; ++i) {
                inputs ~= to!string(i);
            }
            preBeginFunction("$anon", fileId, inSignature, inputs, true, outSignature, true);
            openDeferrableSection();
            addKill();
            closeDeferrableSection();
            registerDeferBlocks();
            endFunction();
            break;
        case list_:
            GrType[] subTypes = grUnmangleSignature(type.mangledType);
            if (subTypes.length != 1)
                logError(getError(Error.listCanOnlyContainOneTypeOfVal), getError(Error.conflictingListSignature),
                    format(getError(Error.tryUsingXInstead), getPrettyType(grList(subTypes[0]))));
            final switch (subTypes[0].baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(GrOpcode.list_int, 0);
                break;
            case float_:
                addInstruction(GrOpcode.list_float, 0);
                break;
            case string_:
                addInstruction(GrOpcode.list_string, 0);
                break;
            case list_:
            case class_:
            case foreign:
            case chan:
            case reference:
                addInstruction(GrOpcode.list_object, 0);
                break;
            case void_:
            case null_:
            case internalTuple:
                logError(format(getError(Error.listCantBeOfTypeX), getPrettyType(
                        grList(subTypes[0]))),
                    getError(Error.invalidListType));
                break;
            }
            break;
        case class_:
            addInstruction(GrOpcode.const_null);
            break;
        case foreign:
            addInstruction(GrOpcode.const_null);
            break;
        case chan:
            GrType[] subTypes = grUnmangleSignature(type.mangledType);
            if (subTypes.length != 1)
                logError(getError(Error.channelCanOnlyContainOneTypeOfVal), getError(Error.conflictingChannelSignature),
                    format(getError(Error.tryUsingXInstead), getPrettyType(grChannel(subTypes[0]))));
            final switch (subTypes[0].baseType) with (GrBaseType) {
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                addInstruction(GrOpcode.channel_int, 1);
                break;
            case float_:
                addInstruction(GrOpcode.channel_float, 1);
                break;
            case string_:
                addInstruction(GrOpcode.channel_string, 1);
                break;
            case class_:
            case list_:
            case foreign:
            case chan:
            case reference:
                addInstruction(GrOpcode.channel_object, 1);
                break;
            case void_:
            case null_:
            case internalTuple:
                logError(format(getError(Error.chanCantBeOfTypeX), getPrettyType(
                        grChannel(subTypes[0]))),
                    getError(Error.invalidChanType));
            }
            break;
        case reference:
        case void_:
        case null_:
        case internalTuple:
            logError(format(getError(Error.typeXHasNoDefaultVal), getPrettyType(type)),
                getError(Error.cantInitThisType));
        }
    }

    /**
    Count the number of D types used (int, float, string and void*).
    */
    private auto countSubTypes(GrType type) {
        struct TypeCounter {
            int iCount, fCount, sCount, oCount;
        }

        TypeCounter counter;
        void countSubTypes(GrType type, ref TypeCounter counter) {
            final switch (type.baseType) with (GrBaseType) {
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                counter.iCount++;
                break;
            case float_:
                counter.fCount++;
                break;
            case string_:
                counter.sCount++;
                break;
            case class_:
            case list_:
            case foreign:
            case chan:
            case reference:
                counter.oCount++;
                break;
            case void_:
            case null_:
                throw new Exception("the type can't be counted as a subtype");
            case internalTuple:
                auto types = grUnpackTuple(type);
                if (!types.length)
                    logError(getError(Error.exprYieldsNoVal), getError(
                            Error.expectedValFoundNothing));
                else {
                    foreach (subType; types)
                        countSubTypes(subType, counter);
                }
                break;
            }
        }

        countSubTypes(type, counter);
        return counter;
    }

    /// Add an instruction to clean up a value from the stack.
    private void shiftStackPosition(GrType type, short count) {
        const auto counter = countSubTypes(type);
        if (counter.iCount)
            addInstruction(GrOpcode.shiftStack_int, counter.iCount * count, true);
        if (counter.fCount)
            addInstruction(GrOpcode.shiftStack_float, counter.fCount * count, true);
        if (counter.sCount)
            addInstruction(GrOpcode.shiftStack_string, counter.sCount * count, true);
        if (counter.oCount)
            addInstruction(GrOpcode.shiftStack_object, counter.oCount * count, true);
    }

    /// Does this operation require a left-expr ?
    private bool requireLValue(GrLexemeType operatorType) {
        switch (operatorType) with (GrLexemeType) {
        case increment:
        case decrement:
        case assign: .. case powerAssign:
            return true;
        default:
            return false;
        }
    }

    /**
    Parse a function reference expression. \
    Converts a public function/task into an anonymous one.
    */
    private GrType parseFunctionPointer(GrType currentType) {
        const uint fileId = get().fileId;
        checkAdvance();
        if (get().type == GrLexemeType.leftParenthesis) {
            checkAdvance();
            GrType refType = parseType();
            if (get().type != GrLexemeType.rightParenthesis)
                logError(getError(Error.missingParenthesesAfterType),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.rightParenthesis), getPrettyLexemeType(get().type)));
            checkAdvance();
            if (currentType.baseType == GrBaseType.void_)
                currentType = refType;
            else
                currentType = convertType(refType, currentType, fileId);
        }
        if (get().type != GrLexemeType.identifier)
            logError(format(getError(Error.expectedFuncNameFoundX), getPrettyLexemeType(get()
                    .type)), getError(
                    Error.missingFuncName));
        if (currentType.baseType != GrBaseType.function_ && currentType.baseType != GrBaseType.task)
            logError(format(getError(Error.cantInferTypeOfX), get().svalue),
                getError(Error.funcTypeCantBeInferred));

        GrType funcType = addFunctionAddress(get().svalue,
            grUnmangleSignature(currentType.mangledType), get().fileId);
        convertType(funcType, currentType, fileId);
        checkAdvance();
        return currentType;
    }

    private enum {
        GR_SUBEXPR_TERMINATE_SEMICOLON = 0x1,
        GR_SUBEXPR_TERMINATE_BRACKET = 0x2,
        GR_SUBEXPR_TERMINATE_COMMA = 0x4,
        GR_SUBEXPR_TERMINATE_PARENTHESIS = 0x8,
        GR_SUBEXPR_TERMINATE_ASSIGN = 0x10,
        GR_SUBEXPR_MUST_CLEAN = 0x20,
        GR_SUBEXPR_EXPECTING_VALUE = 0x40,
        GR_SUBEXPR_EXPECTING_LVALUE = 0x80,
    }

    private struct GrSubExprResult {
        GrType type;
        GrVariable lvalue;
    }

    /**
    Evaluate a single subexpression.
    */
    private GrSubExprResult parseSubExpression(
        int flags = GR_SUBEXPR_TERMINATE_PARENTHESIS | GR_SUBEXPR_EXPECTING_VALUE) {
        const bool useSemicolon = (flags & GR_SUBEXPR_TERMINATE_SEMICOLON) > 0;
        const bool useBracket = (flags & GR_SUBEXPR_TERMINATE_BRACKET) > 0;
        const bool useComma = (flags & GR_SUBEXPR_TERMINATE_COMMA) > 0;
        const bool useParenthesis = (flags & GR_SUBEXPR_TERMINATE_PARENTHESIS) > 0;
        const bool useAssign = (flags & GR_SUBEXPR_TERMINATE_ASSIGN) > 0;
        const bool mustCleanValue = (flags & GR_SUBEXPR_MUST_CLEAN) > 0;
        const bool isExpectingValue = (flags & GR_SUBEXPR_EXPECTING_VALUE) > 0;
        const bool isExpectingLValue = (flags & GR_SUBEXPR_EXPECTING_LVALUE) > 0;

        GrVariable[] lvalues;
        GrLexemeType[] operatorsStack;
        GrType[] typeStack;
        GrType currentType = grVoid, lastType = grVoid;
        bool hasValue = false, hadValue = false, hasLValue = false, hadLValue = false, hasReference = false,
        hadReference = false, isRightUnaryOperator = true, isEndOfExpression = false;

        GrSubExprResult result;
        uint fileId;

        do {
            if (hasValue && currentType != lastType && lastType != grVoid) {
                lastType = currentType;
                currentType = lastType;
            }
            else
                lastType = currentType;

            isRightUnaryOperator = false;
            hadValue = hasValue;
            hasValue = false;

            hadLValue = hasLValue;
            hasLValue = false;

            hadReference = hasReference;
            hasReference = false;

            GrLexeme lex = get();
            fileId = lex.fileId;
            switch (lex.type) with (GrLexemeType) {
            case semicolon:
                if (useSemicolon)
                    isEndOfExpression = true;
                else
                    logError(format(getError(Error.unexpectedXFoundInExpr), getPrettyLexemeType(lex.type)),
                        format(getError(Error.xCantExistInsideThisExpr), getPrettyLexemeType(
                            lex.type)));
                break;
            case comma:
                if (useComma)
                    isEndOfExpression = true;
                else
                    logError(format(getError(Error.unexpectedXFoundInExpr), getPrettyLexemeType(lex.type)),
                        format(getError(Error.xCantExistInsideThisExpr), getPrettyLexemeType(
                            lex.type)));
                break;
            case rightParenthesis:
                if (useParenthesis)
                    isEndOfExpression = true;
                else
                    logError(format(getError(Error.unexpectedXFoundInExpr), getPrettyLexemeType(lex.type)),
                        format(getError(Error.xCantExistInsideThisExpr), getPrettyLexemeType(
                            lex.type)));
                break;
            case rightBracket:
                if (useBracket)
                    isEndOfExpression = true;
                else
                    logError(format(getError(Error.unexpectedXFoundInExpr), getPrettyLexemeType(lex.type)),
                        format(getError(Error.xCantExistInsideThisExpr), getPrettyLexemeType(
                            lex.type)));
                break;
            case leftParenthesis:
                if (hadValue) {
                    currentType = parseAnonymousCall(typeStack[$ - 1]);
                    //Unpack function value for 1 or less return values
                    //Multiples values are left as a tuple for parseExpressionList()
                    if (currentType.baseType == GrBaseType.internalTuple) {
                        auto types = grUnpackTuple(currentType);
                        if (!types.length)
                            currentType = grVoid;
                        else if (types.length == 1uL)
                            currentType = types[0];
                    }
                    if (currentType.baseType == GrBaseType.void_) {
                        typeStack.length--;
                    }
                    else {
                        hadValue = false;
                        hasValue = true;
                        typeStack[$ - 1] = currentType;
                    }
                }
                else {
                    advance();
                    currentType = parseSubExpression().type;
                    advance();
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            case doubleColon:
                advance();
                if (!hadValue)
                    logError(getError(Error.methodCallMustBePlacedAfterVal), getError(
                            Error.missingVal));
                if (get().type != GrLexemeType.identifier)
                    logError(format(getError(Error.expectedFuncNameFoundX), getPrettyLexemeType(get()
                            .type)), getError(
                            Error.missingFuncName));

                GrType selfType = grVoid;
                selfType = typeStack[$ - 1];
                typeStack.length--;
                hadValue = false;

                GrVariable lvalue;
                currentType = parseIdentifier(lvalue, lastType, selfType, isExpectingLValue);
                //Unpack function value for 1 or less return values
                //Multiples values are left as a tuple for parseExpressionList()
                if (currentType.baseType == GrBaseType.internalTuple) {
                    auto types = grUnpackTuple(currentType);
                    if (!types.length)
                        currentType = grVoid;
                    else if (types.length == 1uL)
                        currentType = types[0];
                }

                const auto nextLexeme = get();
                if (nextLexeme.type == GrLexemeType.leftBracket)
                    hasReference = true;
                if (currentType != GrType(GrBaseType.void_)) {
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            case listType:
                currentType = parseListBuilder();
                typeStack ~= currentType;
                hasValue = true;
                break;
            case leftBracket:
                //Index
                if (hadValue) {
                    hadValue = false;
                    currentType = parseListIndex(lastType);
                    hasReference = true;
                    //Check if there is an assignement or not, discard if it's only a rvalue
                    const auto nextLexeme = get();
                    if (requireLValue(nextLexeme.type) || (isExpectingLValue
                            && nextLexeme.type == GrLexemeType.comma)) {
                        if ((nextLexeme.type > GrLexemeType.assign && nextLexeme.type <= GrLexemeType.powerAssign)
                            || nextLexeme.type == GrLexemeType.increment
                            || nextLexeme.type == GrLexemeType.decrement) {
                            final switch (currentType.baseType) with (GrBaseType) {
                            case bool_:
                            case int_:
                            case function_:
                            case task:
                            case enum_:
                                setInstruction(GrOpcode.index3_int,
                                    cast(int) currentFunction.instructions.length - 1);
                                break;
                            case float_:
                                setInstruction(GrOpcode.index3_float,
                                    cast(int) currentFunction.instructions.length - 1);
                                break;
                            case string_:
                                setInstruction(GrOpcode.index3_string,
                                    cast(int) currentFunction.instructions.length - 1);
                                break;
                            case list_:
                            case class_:
                            case foreign:
                            case chan:
                            case reference:
                                setInstruction(GrOpcode.index3_object,
                                    cast(int) currentFunction.instructions.length - 1);
                                break;
                            case void_:
                            case null_:
                            case internalTuple:
                                logError(format(getError(Error.listCantBeIndexedByX), getPrettyType(
                                        currentType)),
                                    getError(Error.invalidListIndexType));
                                break;
                            }
                        }
                        hasLValue = true;
                        GrVariable refVar = new GrVariable;
                        refVar.type.baseType = GrBaseType.reference;
                        refVar.type.mangledType = grMangleSignature([
                            currentType
                        ]);
                        lvalues ~= refVar;
                    }
                    else {
                        final switch (currentType.baseType) with (GrBaseType) {
                        case bool_:
                        case int_:
                        case function_:
                        case task:
                        case enum_:
                            setInstruction(GrOpcode.index2_int,
                                cast(int) currentFunction.instructions.length - 1);
                            break;
                        case float_:
                            setInstruction(GrOpcode.index2_float,
                                cast(int) currentFunction.instructions.length - 1);
                            break;
                        case string_:
                            setInstruction(GrOpcode.index2_string,
                                cast(int) currentFunction.instructions.length - 1);
                            break;
                        case list_:
                        case class_:
                        case foreign:
                        case chan:
                        case reference:
                            setInstruction(GrOpcode.index2_object,
                                cast(int) currentFunction.instructions.length - 1);
                            break;
                        case void_:
                        case null_:
                        case internalTuple:
                            logError(format(getError(Error.listCantBeIndexedByX), getPrettyType(
                                    currentType)),
                                getError(Error.invalidListIndexType));
                            break;
                        }
                    }
                    lastType = currentType;
                    typeStack[$ - 1] = currentType;
                    hasValue = true;
                }
                else {
                    currentType = parseListBuilder();
                    typeStack ~= currentType;
                    hasValue = true;
                }
                break;
            case integer:
                currentType = GrType(GrBaseType.int_);
                addIntConstant(lex.ivalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case float_:
                currentType = GrType(GrBaseType.float_);
                addFloatConstant(lex.fvalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case boolean:
                currentType = GrType(GrBaseType.bool_);
                addBoolConstant(lex.bvalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case string_:
                currentType = GrType(GrBaseType.string_);
                addStringConstant(lex.svalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case null_:
                currentType = GrType(GrBaseType.null_);
                hasValue = true;
                typeStack ~= currentType;
                addInstruction(GrOpcode.const_null);
                checkAdvance();
                break;
            case new_:
                currentType = parseObjectBuilder();
                hasValue = true;
                typeStack ~= currentType;
                break;
            case chanType:
                currentType = parseChannelBuilder();
                hasValue = true;
                typeStack ~= currentType;
                break;
            case period:
                if (currentType.baseType != GrBaseType.class_)
                    logError(format(getError(Error.cantAccessFieldOnTypeX), getPrettyType(currentType)),
                        format(getError(Error.expectedClassFoundX), getPrettyType(currentType)));
                checkAdvance();
                if (get().type != GrLexemeType.identifier)
                    logError(format(getError(Error.expectedFieldNameFoundX), getPrettyLexemeType(get()
                            .type)), getError(Error.missingField));
                const string identifier = get().svalue;
                checkAdvance();
                GrClassDefinition class_ = getClass(currentType.mangledType, get().fileId);
                if (!class_)
                    logError(format(getError(Error.xNotDecl),
                            getPrettyType(currentType)), getError(Error.unknownType));
                const auto nbFields = class_.signature.length;
                bool hasField;
                for (int i; i < nbFields; i++) {
                    if (identifier == class_.fields[i]) {
                        if ((class_.fieldsInfo[i].fileId != fileId)
                            && !class_.fieldsInfo[i].isPublic)
                            logError(format(getError(Error.xOnTypeYIsPrivate), identifier, getPrettyType(
                                    currentType)),
                                getError(Error.privateField), "", -1);
                        hasField = true;
                        currentType = class_.signature[i];
                        currentType.isField = true;
                        GrVariable fieldLValue = new GrVariable;
                        fieldLValue.isInitialized = true;
                        fieldLValue.isField = true;
                        fieldLValue.type = currentType;
                        fieldLValue.register = i;
                        fieldLValue.fileId = get().fileId;
                        fieldLValue.lexPosition = current;

                        if (requireLValue(get().type)) {
                            if (hadLValue)
                                lvalues[$ - 1] = fieldLValue;
                            else
                                lvalues ~= fieldLValue;
                        }

                        if (hadValue)
                            typeStack[$ - 1] = currentType;
                        else
                            typeStack ~= currentType;

                        hasValue = true;
                        hadValue = false;
                        hasLValue = true;
                        hadLValue = false;

                        switch (get().type) with (GrLexemeType) {
                        case period:
                            addInstruction(GrOpcode.fieldLoad_object, fieldLValue.register);
                            break;
                        case assign:
                            addInstruction(GrOpcode.fieldLoad, fieldLValue.register);
                            break;
                        case increment:
                        case decrement:
                        case bitwiseAndAssign: .. case powerAssign:
                            addLoadFieldInstruction(currentType, fieldLValue.register, true);
                            break;
                        case leftParenthesis:
                            lvalues.length--;
                            addLoadFieldInstruction(currentType, fieldLValue.register, false);
                            currentType = parseAnonymousCall(typeStack[$ - 1]);
                            //Unpack function value for 1 or less return values
                            //Multiples values are left as a tuple for parseExpressionList()
                            if (currentType.baseType == GrBaseType.internalTuple) {
                                auto types = grUnpackTuple(currentType);
                                if (!types.length)
                                    currentType = grVoid;
                                else if (types.length == 1uL)
                                    currentType = types[0];
                            }
                            if (currentType.baseType == GrBaseType.void_) {
                                typeStack.length--;
                            }
                            else {
                                hadValue = false;
                                hasValue = true;
                                typeStack[$ - 1] = currentType;
                            }
                            break;
                        case comma:
                            if (isExpectingLValue)
                                goto case assign;
                            goto default;
                        default:
                            addLoadFieldInstruction(currentType, fieldLValue.register, false);
                            break;
                        }
                        break;
                    }
                }
                if (!hasField) {
                    const string[] nearestValues = findNearestStrings(identifier, class_.fields);
                    string errorNote;
                    if (nearestValues.length) {
                        foreach (size_t i, const string value; nearestValues) {
                            errorNote ~= "`" ~ value ~ "`";
                            if ((i + 1) < nearestValues.length)
                                errorNote ~= ", ";
                        }
                        errorNote ~= ".";
                    }
                    logError(format(getError(Error.noFieldXOnTypeY), identifier, getPrettyType(currentType)),
                        getError(Error.unknownField), format(getError(Error.availableFieldsAreX), errorNote), -1);
                }
                break;
            case colon:
                const size_t methodCallPos = current;
                if (!hadValue)
                    logError(getError(Error.missingParamOnMethodCall),
                        getError(Error.methodCallMustBePlacedAfterVal));
                checkAdvance();
                GrType selfType = currentType;
                if (get().type != GrLexemeType.identifier)
                    logError(format(getError(Error.expectedFuncNameFoundX), getPrettyLexemeType(get()
                            .type)), getError(
                            Error.missingFuncName));
                const string identifier = get().svalue;
                checkAdvance();
                bool hasField;

                if (currentType.baseType == GrBaseType.class_) {
                    GrClassDefinition class_ = getClass(currentType.mangledType, get().fileId);
                    if (!class_)
                        logError(format(getError(Error.xNotDecl),
                                getPrettyType(currentType)), getError(Error.unknownClass), "", -1);
                    const auto nbFields = class_.signature.length;
                    for (int i; i < nbFields; i++) {
                        if (identifier == class_.fields[i]) {
                            if ((class_.fieldsInfo[i].fileId != fileId)
                                && !class_.fieldsInfo[i].isPublic) {
                                logError(format(getError(Error.xOnTypeYIsPrivate), identifier, getPrettyType(
                                        currentType)), getError(Error.privateField), "", -1);
                            }
                            hasField = true;
                            currentType = class_.signature[i];
                            currentType.isField = true;
                            GrVariable fieldLValue = new GrVariable;
                            fieldLValue.isInitialized = true;
                            fieldLValue.isField = true;
                            fieldLValue.type = currentType;
                            fieldLValue.register = i;
                            fieldLValue.fileId = get().fileId;
                            fieldLValue.lexPosition = current;

                            if (hadLValue)
                                lvalues.length--;

                            if (hadValue)
                                typeStack[$ - 1] = currentType;
                            else
                                typeStack ~= currentType;

                            hasValue = true;
                            hadValue = false;
                            hasLValue = true;
                            hadLValue = false;

                            addInstruction(GrOpcode.copy_object);
                            addLoadFieldInstruction(currentType, fieldLValue.register, false);
                            currentType = parseAnonymousCall(typeStack[$ - 1], selfType);
                            //Unpack function value for 1 or less return values
                            //Multiples values are left as a tuple for parseExpressionList()
                            if (currentType.baseType == GrBaseType.internalTuple) {
                                auto types = grUnpackTuple(currentType);
                                if (!types.length)
                                    currentType = grVoid;
                                else if (types.length == 1uL)
                                    currentType = types[0];
                            }
                            if (currentType.baseType == GrBaseType.void_) {
                                typeStack.length--;
                            }
                            else {
                                hadValue = false;
                                hasValue = true;
                                typeStack[$ - 1] = currentType;
                            }
                            break;
                        }
                    }
                }
                if (!hasField) {
                    current = methodCallPos;
                    goto case doubleColon;
                }
                break;
            case pointer:
                currentType = parseFunctionPointer(currentType);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case as:
                if (!hadValue)
                    logError(format(getError(Error.xMustBePlacedAfterVal), getPrettyLexemeType(
                            GrLexemeType.as)), getError(Error.missingVal));
                currentType = parseConversionOperator(typeStack);
                hasValue = true;
                hadValue = false;
                break;
            case self:
                // Parse a function call that refers to its parent. 
                checkAdvance();
                currentType = addFunctionAddress(currentFunction, get().fileId);
                if (currentType.baseType == GrBaseType.void_)
                    logError(format(getError(Error.xMustBeInsideFuncOrTask), getPrettyLexemeType(GrLexemeType.self)),
                        format(getError(Error.xRefNoFuncNorTask), getPrettyLexemeType(
                            GrLexemeType.self)), "", -1);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case functionType:
                currentType = parseAnonymousFunction(false);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case taskType:
                currentType = parseAnonymousFunction(true);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case assign:
                if (useAssign) {
                    isEndOfExpression = true;
                    break;
                }
                goto case bitwiseAndAssign;
            case bitwiseAndAssign: .. case powerAssign:
                if (!hadLValue)
                    logError(getError(Error.valBeforeAssignationNotReferenceable),
                        getError(Error.missingRefBeforeAssignation));
                hadLValue = false;
                goto case multiply;
            case add:
                if (!hadValue)
                    lex.type = GrLexemeType.plus;
                goto case multiply;
            case concatenate:
                if (!hadValue)
                    lex.type = GrLexemeType.bitwiseNot;
                goto case multiply;
            case substract:
                if (!hadValue)
                    lex.type = GrLexemeType.minus;
                goto case multiply;
            case send:
                if (!hadValue)
                    lex.type = GrLexemeType.receive;
                goto case multiply;
            case increment: .. case decrement:
                isRightUnaryOperator = true;
                goto case multiply;
            case multiply:
            case divide:
            case remainder: .. case not:
                if (isExpectingLValue)
                    logError(getError(
                            Error.cantDoThisKindOfOpOnLeftSideOfAssignement), getError(
                            Error.unexpectedOp)
                    );
                if (!hadValue && !isUnaryOperator(lex.type))
                    logError(getError(Error.binOpMustHave2Operands), getError(Error.missingVal));

                while (operatorsStack.length
                    && getLeftOperatorPriority(operatorsStack[$ - 1]) > getRightOperatorPriority(
                        lex.type)) {
                    GrLexemeType operator = operatorsStack[$ - 1];

                    switch (operator) with (GrLexemeType) {
                    case assign:
                        addSetInstruction(lvalues[$ - 1], fileId, currentType, true);
                        lvalues.length--;
                        break;
                    case bitwiseAndAssign: .. case powerAssign:
                        currentType = addOperator(operator - (GrLexemeType.bitwiseAndAssign - GrLexemeType.bitwiseAnd),
                            typeStack, fileId);
                        addSetInstruction(lvalues[$ - 1], fileId, currentType, true);
                        lvalues.length--;
                        break;
                    case increment: .. case decrement:
                        currentType = addOperator(operator, typeStack, fileId);
                        addSetInstruction(lvalues[$ - 1], fileId, currentType, true);
                        lvalues.length--;
                        break;
                    default:
                        currentType = addOperator(operator, typeStack, fileId);
                        break;
                    }

                    operatorsStack.length--;
                }

                operatorsStack ~= lex.type;
                if (hadValue && isRightUnaryOperator) {
                    hasValue = true;
                    hadValue = false;
                }
                else
                    hasValue = false;
                checkAdvance();
                break;
            case identifier:
                GrVariable lvalue;
                currentType = parseIdentifier(lvalue, lastType, grVoid, isExpectingLValue);
                //Unpack function value for 1 or less return values
                //Multiples values are left as a tuple for parseExpressionList()
                if (currentType.baseType == GrBaseType.internalTuple) {
                    auto types = grUnpackTuple(currentType);
                    if (!types.length)
                        currentType = grVoid;
                    else if (types.length == 1uL)
                        currentType = types[0];
                }

                //Check if there is an assignement or not, discard if it's only a rvalue
                const auto nextLexeme = get();
                if (lvalue !is null && (requireLValue(nextLexeme.type)
                        || (isExpectingLValue && nextLexeme.type == GrLexemeType.comma))) {
                    hasLValue = true;
                    lvalues ~= lvalue;

                    if (lvalue.isAuto)
                        hasValue = true;
                }

                if (!hasLValue && nextLexeme.type == GrLexemeType.leftBracket)
                    hasReference = true;

                if (currentType != GrType(GrBaseType.void_)) {
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            default:
                logError(format(getError(Error.unexpectedXSymbolInExpr), getPrettyLexemeType(
                        lex.type)),
                    getError(Error.unexpectedSymbol));
            }

            if (hasValue && hadValue)
                logError(getError(Error.missingSemicolonAtEndOfExpr),
                    format(getError(Error.expectedXFoundY), getPrettyLexemeType(
                        GrLexemeType.semicolon), getPrettyLexemeType(get().type)));
        }
        while (!isEndOfExpression);

        if (operatorsStack.length) {
            if (!hadValue) {
                logError(getError(Error.binOpMustHave2Operands), getError(Error.missingVal));
            }
        }

        while (operatorsStack.length) {
            GrLexemeType operator = operatorsStack[$ - 1];

            switch (operator) with (GrLexemeType) {
            case assign:
                addSetInstruction(lvalues[$ - 1], fileId, currentType,
                    isExpectingValue || operatorsStack.length > 1uL);
                lvalues.length--;

                if (operatorsStack.length <= 1uL)
                    hadValue = false;
                break;
            case bitwiseAndAssign: .. case powerAssign:
                currentType = addOperator(
                    operator - (GrLexemeType.bitwiseAndAssign - GrLexemeType.bitwiseAnd),
                    typeStack, fileId);
                addSetInstruction(lvalues[$ - 1], fileId, currentType,
                    isExpectingValue || operatorsStack.length > 1uL);
                lvalues.length--;

                if (operatorsStack.length <= 1uL)
                    hadValue = false;
                break;
            case increment: .. case decrement:
                currentType = addOperator(operator, typeStack, fileId);
                addSetInstruction(lvalues[$ - 1], fileId, currentType,
                    isExpectingValue || operatorsStack.length > 1uL);
                lvalues.length--;

                if (operatorsStack.length <= 1uL)
                    hadValue = false;
                break;
            default:
                currentType = addOperator(operator, typeStack, fileId);
                break;
            }

            operatorsStack.length--;
        }

        if (isExpectingLValue) {
            if (!hadLValue)
                logError(getError(Error.valBeforeAssignationNotReferenceable),
                    getError(Error.missingRefBeforeAssignation));
            result.lvalue = lvalues[$ - 1];
        }

        if (mustCleanValue && hadValue && currentType.baseType != GrBaseType.void_)
            shiftStackPosition(currentType, -1);

        result.type = currentType;
        return result;
    }

    private void addLoadFieldInstruction(GrType type, uint index, bool asCopy) {
        final switch (type.baseType) with (GrBaseType) {
        case bool_:
        case int_:
        case function_:
        case task:
        case enum_:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_int : GrOpcode.fieldLoad_int, index);
            break;
        case float_:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_float : GrOpcode.fieldLoad_float, index);
            break;
        case string_:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_string : GrOpcode.fieldLoad_string, index);
            break;
        case reference:
        case chan:
        case class_:
        case list_:
        case foreign:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_object : GrOpcode.fieldLoad_object, index);
            break;
        case internalTuple:
        case null_:
        case void_:
            logError(format(getError(Error.cantLoadFieldOfTypeX), getPrettyType(type)),
                getError(Error.fieldTypeIsInvalid));
            break;
        }
    }

    /// Parse a function call from a runtime value.
    private GrType parseAnonymousCall(GrType type, GrType selfType = grVoid) {
        const uint fileId = get().fileId;

        GrVariable functionId;
        if (type.baseType == GrBaseType.function_) {
            functionId = registerSpecialVariable("anon", GrType(GrBaseType.int_));
            addSetInstruction(functionId, fileId, GrType(GrBaseType.int_));
        }
        else if (type.baseType != GrBaseType.task) {
            logError(format(getError(Error.xNotCallable), getPrettyType(type)),
                format(getError(Error.xNotFuncNorTask), getPrettyType(type)));
        }

        //Signature parsing with type conversion
        GrType[] signature;
        GrType[] anonSignature = grUnmangleSignature(type.mangledType);
        int i;
        if (selfType != grVoid) {
            signature ~= convertType(selfType, anonSignature[i], fileId);
            i++;
        }
        if (get().type == GrLexemeType.leftParenthesis) {
            checkAdvance();
            if (get().type != GrLexemeType.rightParenthesis) {
                for (;;) {
                    if (i >= anonSignature.length) {
                        logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButMoreWereSupplied : Error.funcTakesXArgButMoreWereSupplied), anonSignature
                                .length),
                            format(getError(anonSignature.length > 1 ? Error.expectedXArg : Error.expectedXArgs), anonSignature
                                .length),
                            format(getError(Error.funcIsOfTypeX), getPrettyType(type)));
                    }
                    GrType subType = parseSubExpression(
                        GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                            | GR_SUBEXPR_EXPECTING_VALUE).type;
                    if (subType.baseType == GrBaseType.internalTuple) {
                        auto types = grUnpackTuple(subType);
                        if (types.length) {
                            for (int y; y < types.length; y++, i++) {
                                if (i >= anonSignature.length) {
                                    logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButMoreWereSupplied
                                            : Error.funcTakesXArgButMoreWereSupplied), anonSignature
                                            .length),
                                        format(getError(anonSignature.length > 1 ? Error.expectedXArg : Error.expectedXArgs), anonSignature
                                            .length),
                                        format(getError(Error.funcIsOfTypeX), getPrettyType(type)));
                                }
                                signature ~= convertType(types[y], anonSignature[i], fileId);
                            }
                        }
                        else
                            logError(getError(Error.exprYieldsNoVal),
                                getError(Error.expectedValFoundNothing));
                    }
                    else {
                        signature ~= convertType(subType, anonSignature[i], fileId);
                        i++;
                    }
                    if (get().type == GrLexemeType.rightParenthesis) {
                        checkAdvance();
                        break;
                    }
                    advance();
                }
            }
            else {
                checkAdvance();
            }
        }
        if (signature.length != anonSignature.length) {
            logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButYWereSupplied
                    : Error.funcTakesXArgButYWereSupplied), anonSignature.length, signature.length),
                format(getError(anonSignature.length > 1 ? Error.expectedXArgsFoundY
                    : Error.expectedXArgFoundY), anonSignature.length, signature.length),
                format(getError(Error.funcIsOfTypeX), getPrettyType(type)));
        }

        //Push the values on the global stack for task spawning.
        if (type.baseType == GrBaseType.task)
            addGlobalPush(signature);

        //Anonymous call.
        GrType retTypes = grPackTuple(grUnmangleSignature(type.mangledReturnType));

        if (type.baseType == GrBaseType.function_) {
            addGetInstruction(functionId, GrType(GrBaseType.int_));
        }

        if (type.baseType == GrBaseType.function_)
            addInstruction(GrOpcode.anonymousCall, 0u);
        else
            addInstruction(GrOpcode.anonymousTask, 0u);
        return retTypes;
    }

    /// Parse an identifier or function call and return the deduced return type and lvalue.
    private GrType parseIdentifier(ref GrVariable variable, GrType expectedType,
        GrType selfType = grVoid, bool isAssignment = false) {
        GrType returnType = GrBaseType.void_;
        const GrLexeme identifier = get();
        bool isFunctionCall = false, isMethodCall = false, hasParenthesis = false;
        string identifierName = identifier.svalue;
        const uint fileId = identifier.fileId;

        advance();

        if (selfType.baseType != GrBaseType.void_) {
            isMethodCall = true;
            isFunctionCall = true;
        }

        if (get().type == GrLexemeType.leftParenthesis) {
            isFunctionCall = true;
            hasParenthesis = true;
        }

        if (isFunctionCall) {
            GrType[] signature;

            if (hasParenthesis)
                advance();

            GrVariable var = currentFunction.getLocal(identifierName);
            if (!var)
                var = getGlobalVariable(identifierName, fileId);
            if (var) {
                if (var.type.baseType != GrBaseType.function_ && var.type.baseType
                    != GrBaseType.task)
                    logError(format(getError(Error.xNotCallable), identifierName),
                        format(getError(Error.funcOrTaskExpectedFoundX), getPrettyType(var.type)),
                        "", -1);
                //Signature parsing with type conversion
                GrType[] anonSignature = grUnmangleSignature(var.type.mangledType);
                int i;
                if (isMethodCall) {
                    if (!anonSignature.length)
                        logError(getError(Error.missingParamOnMethodCall),
                            getError(Error.methodCallMustBePlacedAfterVal));
                    signature ~= convertType(selfType, anonSignature[i], fileId);
                    i++;
                }
                if (hasParenthesis && get().type != GrLexemeType.rightParenthesis) {
                    for (;;) {
                        if (i >= anonSignature.length) {
                            logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButMoreWereSupplied : Error.funcTakesXArgButMoreWereSupplied), anonSignature
                                    .length),
                                format(getError(anonSignature.length > 1 ? Error.expectedXArgs : Error.expectedXArg), anonSignature
                                    .length),
                                format(getError(Error.funcIsOfTypeX), getPrettyType(var.type)),
                                0, getError(Error.funcDefHere), var.lexPosition);
                        }
                        GrType subType = parseSubExpression(
                            GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                                | GR_SUBEXPR_EXPECTING_VALUE).type;
                        if (subType.baseType == GrBaseType.internalTuple) {
                            auto types = grUnpackTuple(subType);
                            if (types.length) {
                                for (int y; y < types.length; y++, i++) {
                                    if (i >= anonSignature.length) {
                                        logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButMoreWereSupplied
                                                : Error.funcTakesXArgButMoreWereSupplied), anonSignature
                                                .length),
                                            format(getError(anonSignature.length > 1 ? Error.expectedXArgs : Error.expectedXArg), anonSignature
                                                .length),
                                            format(getError(Error.funcIsOfTypeX), getPrettyType(var.type)),
                                            0, getError(Error.funcDefHere), var.lexPosition);
                                    }
                                    signature ~= convertType(types[y], anonSignature[i], fileId);
                                }
                            }
                            else
                                logError(getError(Error.exprYieldsNoVal),
                                    getError(Error.expectedValFoundNothing));
                        }
                        else {
                            signature ~= convertType(subType, anonSignature[i], fileId);
                            i++;
                        }
                        if (get().type == GrLexemeType.rightParenthesis) {
                            if (signature.length != anonSignature.length) {
                                logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButYWereSupplied : Error.funcTakesXArgButYWereSupplied), anonSignature
                                        .length, signature.length),
                                    format(getError(anonSignature.length > 1 ? Error.expectedXArgsFoundY : Error.expectedXArgFoundY), anonSignature
                                        .length, signature.length),
                                    format(getError(Error.funcIsOfTypeX), getPrettyType(var.type)));
                            }
                            break;
                        }
                        advance();
                    }
                    if (hasParenthesis && get().type == GrLexemeType.rightParenthesis)
                        advance();
                }
                else {
                    if (hasParenthesis && get().type == GrLexemeType.rightParenthesis)
                        advance();
                    if (signature.length != anonSignature.length) {
                        logError(format(getError(anonSignature.length > 1 ? Error.funcTakesXArgsButYWereSupplied : Error.funcTakesXArgButYWereSupplied), anonSignature
                                .length, signature.length),
                            format(getError(anonSignature.length > 1 ? Error.expectedXArgsFoundY : Error.expectedXArgFoundY), anonSignature
                                .length, signature.length),
                            format(getError(Error.funcIsOfTypeX), getPrettyType(var.type)));
                    }
                }

                //Push the values on the global stack for task spawning.
                if (var.type.baseType == GrBaseType.task)
                    addGlobalPush(signature);

                //Anonymous call.
                //bool hasAnonFunc = false;
                addGetInstruction(var);

                returnType = grPackTuple(grUnmangleSignature(var.type.mangledReturnType));

                if (var.type.baseType == GrBaseType.function_)
                    addInstruction(GrOpcode.anonymousCall, 0u);
                else if (var.type.baseType == GrBaseType.task)
                    addInstruction(GrOpcode.anonymousTask, 0u);
            }
            else {
                if (isMethodCall) {
                    if (selfType.baseType == GrBaseType.internalTuple)
                        signature ~= grUnpackTuple(selfType);
                    else
                        signature ~= selfType;
                }
                //Signature parsing, no coercion is made
                if (hasParenthesis && get().type != GrLexemeType.rightParenthesis) {
                    for (;;) {
                        auto type = parseSubExpression(
                            GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                                | GR_SUBEXPR_EXPECTING_VALUE).type;
                        if (type.baseType == GrBaseType.internalTuple) {
                            auto types = grUnpackTuple(type);
                            if (types.length)
                                signature ~= types;
                            else
                                logError(getError(Error.exprYieldsNoVal),
                                    getError(Error.expectedValFoundNothing));
                        }
                        else
                            signature ~= type;

                        if (get().type == GrLexemeType.rightParenthesis)
                            break;
                        advance();
                    }
                }
                if (hasParenthesis && get().type == GrLexemeType.rightParenthesis)
                    advance();

                //GrPrimitive call.
                GrPrimitive primitive = _data.getPrimitive(identifierName, signature);
                if (primitive) {
                    addInstruction(GrOpcode.primitiveCall, primitive.index);
                    returnType = grPackTuple(primitive.outSignature);
                }
                else //GrFunction/Task call.
                    returnType = grPackTuple(addFunctionCall(identifierName, signature, fileId));
            }
        }
        else if (_data.isEnum(identifier.svalue, fileId, false)) {
            const GrEnumDefinition definition = _data.getEnum(identifier.svalue, fileId);
            if (get().type != GrLexemeType.period)
                logError(getError(Error.expectedDotAfterEnumType), getError(
                        Error.missingEnumConstantName));
            checkAdvance();
            if (get().type != GrLexemeType.identifier)
                logError(getError(Error.expectedConstNameAfterEnumType),
                    getError(Error.missingEnumConstantName));
            const string fieldName = get().svalue;
            if (!definition.hasField(fieldName)) {
                const string[] nearestValues = findNearestStrings(fieldName, definition.fields);
                string errorNote;
                if (nearestValues.length) {
                    foreach (size_t i, const string value; nearestValues) {
                        errorNote ~= "`" ~ value ~ "`";
                        if ((i + 1) < nearestValues.length)
                            errorNote ~= ", ";
                    }
                    errorNote ~= ".";
                }
                logError(format(getError(Error.noFieldXOnTypeY), fieldName, definition.name),
                    getError(Error.unknownField), format(getError(Error.availableFieldsAreX), errorNote));
            }
            checkAdvance();

            returnType = GrType(GrBaseType.enum_);
            returnType.mangledType = definition.name;
            addIntConstant(definition.getField(fieldName));
        }
        else {
            //Declared variable.
            variable = getVariable(identifierName, fileId);
            returnType = variable.type;
            //If it's an assignement, we want the GET instruction to be after the assignement, not there.
            const auto nextLexeme = get();
            if (!(nextLexeme.type == GrLexemeType.assign || (isAssignment
                    && nextLexeme.type == GrLexemeType.comma)))
                addGetInstruction(variable, expectedType);
        }
        return returnType;
    }

    private string getPrettyFunctionCall(string name, GrType[] signature) {
        return grGetPrettyFunctionCall(name, signature, _locale);
    }

    private string getPrettyFunction(GrFunction func) {
        return grGetPrettyFunction(func, _locale);
    }

    private string getPrettyType(GrType type) {
        return grGetPrettyType(type, _locale);
    }

    private string getPrettyLexemeType(GrLexemeType type) {
        return grGetPrettyLexemeType(type, _locale);
    }

    /// Check and raise an error.
    private void assertError(bool assertion, string message, string info,
        string note = "", int offset = 0) {
        if (assertion)
            return;
        logError(message, info, note, offset);
    }

    /// Log an error and throw an exception.
    private void logError(string message, string info, string note = "",
        int offset = 0, string otherInfo = "", uint otherPos = 0) {
        GrError error = new GrError;
        error.type = GrError.Type.parser;
        error.message = message;
        error.info = info;
        error.note = note;

        GrLexeme lex = (isEnd() && offset >= 0) ? get(-1) : get(offset);
        error.filePath = lex.getFile();
        error.lineText = lex.getLine().replace("\t", " ");
        error.line = lex.line + 1u; // By convention, the first line is 1, not 0.
        error.column = lex.column;
        error.textLength = lex.textLength;

        if (otherInfo.length) {
            error.otherInfo = otherInfo;

            set(otherPos);

            GrLexeme otherLex = isEnd() ? get(-1) : get();
            error.otherFilePath = otherLex.getFile();
            error.otherLineText = otherLex.getLine().replace("\t", " ");
            error.otherLine = otherLex.line + 1u; // By convention, the first line is 1, not 0.
            error.otherColumn = otherLex.column;
            error.otherTextLength = otherLex.textLength;
        }

        throw new GrParserException(error);
    }

    private enum Error {
        eofReached,
        eof,
        nameXDefMultipleTimes,
        xRedefHere,
        prevDefOfX,
        prevDefPrim,
        alreadyDef,
        cantDefVarOfTypeX,
        invalidType,
        xNotDef,
        unknownFunc,
        cantUseTypeAsParam,
        invalidParamType,
        xNotDecl,
        unknownVar,
        opMustHave1RetVal,
        expected1RetValFoundX,
        expected1RetValFoundXs,
        cantUseOpOnMultipleVal,
        exprYieldsMultipleVal,
        noXUnaryOpDefForY,
        noXBinaryOpDefForYAndZ,
        unknownOp,
        xIsConstAndCantBeModified,
        cantModifyAConstX,
        cantAssignToAXVar,
        ValNotAssignable,
        cantInferTypeOfVar,
        varNotInit,
        cantGetValueOfX,
        valNotFetchable,
        unknownClass,
        unknownType,
        locVarUsedNotAssigned,
        globalDeclExpected,
        globalDeclExpectedFoundX,
        funcMissingRetAtEnd,
        missingRet,
        expectedTypeAliasNameFoundX,
        expectedEnumNameFoundX,
        expectedXFoundY,
        missingIdentifier,
        missingAssignInType,
        missingSemicolonAfterType,
        enumDefNotHaveBody,
        expectedEnumFieldFoundX,
        missingSemicolonAfterEnumField,
        xAlreadyDecl,
        expectedClassNameFoundX,
        parentClassNameMissing,
        classHaveNoBody,
        missingSemicolonAfterClassFieldDecl,
        xCantInheritFromY,
        xIncludedRecursively,
        recursiveInheritence,
        fieldXDeclMultipleTimes,
        recursiveDecl,
        xNotValidType,
        expectedValidTypeFoundX,
        listCanOnlyContainOneTypeOfVal,
        conflictingListSignature,
        tryUsingXInstead,
        channelCanOnlyContainOneTypeOfVal,
        conflictingChannelSignature,
        missingTemplateVal,
        templateValShouldBeSeparatedByComma,
        templateTypesShouldBeSeparatedByComma,
        missingParentheses,
        paramShouldBeSeparatedByComma,
        expectedIdentifierFoundX,
        typesShouldBeSeparatedByComma,
        addingPubBeforeActionIsRedundant,
        actionAlreadyPublic,
        cantOverrideXOp,
        opCantBeOverriden,
        missingTemplateSignature,
        emptyTemplateSignature,
        templateSignatureCantBeEmpty,
        missingSemicolonAfterTemplateDecl,
        convMustHave1RetVal,
        convMustHave1Param,
        expected1ParamFoundX,
        expected1ParamFoundXs,
        missingCurlyBraces,
        tryMustBeFollowedByCatch,
        deferInsideDefer,
        cantDeferInsideDefer,
        xInsideDefer,
        cantXInsideDefer,
        breakOutsideLoop,
        cantBreakOutsideLoop,
        continueOutsideLoop,
        cantContinueOutsideLoop,
        xNotValidRetType,
        chanSizeMustBePositive,
        missingCommaOrRightParenthesisInsideChanSignature,
        missingParenthesesAfterChanSignature,
        expectedIntFoundX,
        chanSizeMustBeOneOrHigher,
        expectedAtLeastSizeOf1FoundX,
        expectedCommaOrRightParenthesisFoundX,
        chanCantBeOfTypeX,
        invalidChanType,
        missingParenthesesAfterX,
        missingCommaInX,
        onlyOneDefaultCasePerX,
        defaultCaseAlreadyDef,
        prevDefaultCaseDef,
        missingWhileOrUntilAfterLoop,
        expectedWhileOrUntilFoundX,
        varDefOrRefExpected,
        varOrRefExpectedFoundX,
        varNameExpected,
        varNameExpectedFoundX,
        listCantBeOfTypeX,
        invalidListType,
        primXMustRetBoolAndVal,
        signatureMismatch,
        funcXMustRetBoolAndVal,
        notIterable,
        forCantIterateOverX,
        cantEvalArityUnknownCompound,
        arityEvalError,
        typeOfIteratorMustBeIntNotX,
        iteratorMustBeInt,
        mismatchedNumRetVal,
        expectedXRetValFoundY,
        expectedXRetValsFoundY,
        retSignatureOfTypeX,
        retTypeXNotMatchSignatureY,
        expectedXVal,
        opNotListedInOpPriorityTable,
        unknownOpPriority,
        mismatchedTypes,
        missingX,
        xNotClassType,
        fieldXInitMultipleTimes,
        xAlreadyInit,
        prevInit,
        fieldXNotExist,
        unknownField,
        expectedFieldNameFoundX,
        missingField,
        missingBracketsAfterX,
        indexesShouldBeSeparatedByComma,
        missingVal,
        expectedIndexFoundComma,
        expectedIntFoundNothing,
        noValToConv,
        expectedVarFoundX,
        missingVar,
        exprYieldsNoVal,
        expectedValFoundNothing,
        missingSemicolonAfterExprList,
        tryingAssignXValsToYVar,
        tryingAssignXValsToYVars,
        moreValThanVarToAssign,
        assignationMissingVal,
        expressionEmpty,
        firstValOfAssignmentListCantBeEmpty,
        cantInferTypeWithoutAssignment,
        missingTypeInfoOrInitVal,
        missingSemicolonAfterAssignmentList,
        typeXHasNoDefaultVal,
        cantInitThisType,
        missingParenthesesAfterType,
        expectedFuncNameFoundX,
        missingFuncName,
        cantInferTypeOfX,
        funcTypeCantBeInferred,
        unexpectedXFoundInExpr,
        xCantExistInsideThisExpr,
        methodCallMustBePlacedAfterVal,
        listCantBeIndexedByX,
        invalidListIndexType,
        cantAccessFieldOnTypeX,
        expectedClassFoundX,
        xOnTypeYIsPrivate,
        privateField,
        noFieldXOnTypeY,
        availableFieldsAreX,
        missingParamOnMethodCall,
        xMustBePlacedAfterVal,
        xMustBeInsideFuncOrTask,
        xRefNoFuncNorTask,
        valBeforeAssignationNotReferenceable,
        missingRefBeforeAssignation,
        cantDoThisKindOfOpOnLeftSideOfAssignement,
        unexpectedOp,
        binOpMustHave2Operands,
        unexpectedXSymbolInExpr,
        unexpectedSymbol,
        missingSemicolonAtEndOfExpr,
        cantLoadFieldOfTypeX,
        fieldTypeIsInvalid,
        xNotCallable,
        xNotFuncNorTask,
        funcTakesXArgButMoreWereSupplied,
        funcTakesXArgsButMoreWereSupplied,
        funcIsOfTypeX,
        expectedXArg,
        expectedXArgs,
        funcTakesXArgButYWereSupplied,
        funcTakesXArgsButYWereSupplied,
        expectedXArgFoundY,
        expectedXArgsFoundY,
        funcOrTaskExpectedFoundX,
        funcDefHere,
        expectedDotAfterEnumType,
        missingEnumConstantName,
        expectedConstNameAfterEnumType,
    }
    // format(getError(Error.), )
    /*

logError(format(getError(Error.xNotDecl), getPrettyFunctionCall(name,
        signature)), getError(Error.unknownType), "", -1);
    */
    private string getError(Error error) {
        immutable string[Error][GrLocale.max + 1] messages = [
            [ //en_US
                Error.eofReached: "reached the end of the file",
                Error.eof: "unexpected end of file",
                Error.unknownFunc: "unknown function",
                Error.unknownVar: "unknown variable",
                Error.unknownOp: "unknown operator",
                Error.unknownClass: "unknown class",
                Error.unknownType: "unknown type",
                Error.unknownOpPriority: "unknown operator priority",
                Error.unknownField: "unknown field",
                Error.invalidType: "invalid type",
                Error.invalidParamType: "invalid parameter type",
                Error.invalidChanType: "invalid channel type",
                Error.invalidListType: "invalid list type",
                Error.invalidListIndexType: "invalid list index type",
                Error.xNotDef: "`%s` is not defined",
                Error.xNotDecl: "`%s` is not declared",
                Error.nameXDefMultipleTimes: "the name `%s` is defined multiple times",
                Error.xRedefHere: "`%s` is redefined here",
                Error.prevDefOfX: "previous definition of `%s`",
                Error.prevDefPrim: "`%s` is already defined as a primitive",
                Error.alreadyDef: "`%s` is already declared",
                Error.cantDefVarOfTypeX: "can't define a variable of type %s",
                Error.cantUseTypeAsParam: "can't use `%s` as a parameter type",
                Error.opMustHave1RetVal: "an operator must have only one return value",
                Error.expected1RetValFoundX: "expected 1 return value, found %s return value",
                Error.expected1RetValFoundXs: "expected 1 return value, found %s return values",
                Error.cantUseOpOnMultipleVal: "can't use an operator on multiple values",
                Error.exprYieldsMultipleVal: "the expression yields multiple values",
                Error.noXUnaryOpDefForY: "there is no `%s` unary operator defined for `%s`",
                Error.noXBinaryOpDefForYAndZ: "there is no `%s` binary operator defined for `%s` and `%s`",
                Error.xIsConstAndCantBeModified: "`%s` is const and can't be modified",
                Error.cantModifyAConstX: "can't modify a const `%s`",
                Error.cantAssignToAXVar: "can't assign to a `%s` variable",
                Error.ValNotAssignable: "the value is not assignable",
                Error.cantInferTypeOfVar: "can't infer the type of variable",
                Error.varNotInit: "the variable has not been initialized",
                Error.locVarUsedNotAssigned: "the local variable is being used without being assigned",
                Error.cantGetValueOfX: "can't get the value of `%s`",
                Error.valNotFetchable: "the value is not fetchable",
                Error.globalDeclExpected: "a global declaration is expected",
                Error.globalDeclExpectedFoundX: "a global declaration is expected, found `%s`",
                Error.funcMissingRetAtEnd: "the function is missing a return at the end of the scope",
                Error.missingRet: "missing `return`",
                Error.expectedTypeAliasNameFoundX: "expected type alias name, found `%s`",
                Error.expectedEnumNameFoundX: "expected enum name, found `%s`",
                Error.expectedXFoundY: "expected `%s`, found `%s`",
                Error.missingIdentifier: "missing identifier",
                Error.missingAssignInType: "missing assignment in `type`",
                Error.missingSemicolonAfterType: "missing semicolon after `type`",
                Error.enumDefNotHaveBody: "the enum definition does not have a body",
                Error.expectedEnumFieldFoundX: "expected enum field, found `%s`",
                Error.missingSemicolonAfterEnumField: "missing semicolon after type enum field",
                Error.xAlreadyDecl: "`%s` is already declared",
                Error.expectedClassNameFoundX: "expected class name, found `%s`",
                Error.parentClassNameMissing: "the parent class name is missing",
                Error.classHaveNoBody: "the class does not have a body",
                Error.missingSemicolonAfterClassFieldDecl: "missing semicolon after class field declaration",
                Error.xCantInheritFromY: "`%s` can't inherit from `%s`",
                Error.xIncludedRecursively: "`%s` is included recursively",
                Error.recursiveInheritence: "recursive inheritence",
                Error.fieldXDeclMultipleTimes: "the field `%s` is declared multiple times",
                Error.recursiveDecl: "recursive declaration",
                Error.xNotValidType: "`%s` is not a valid type",
                Error.expectedValidTypeFoundX: "expected a valid type, found `%s`",
                Error.listCanOnlyContainOneTypeOfVal: "a list can only contain one type of value",
                Error.conflictingListSignature: "conflicting list signature",
                Error.tryUsingXInstead: "try using `%s` instead",
                Error.channelCanOnlyContainOneTypeOfVal: "a channel can only contain one type of value",
                Error.conflictingChannelSignature: "conflicting channel signature",
                Error.missingTemplateVal: "missing template value",
                Error.templateValShouldBeSeparatedByComma: "template values should be separated by a comma",
                Error.templateTypesShouldBeSeparatedByComma: "template types should be separated by a comma",
                Error.missingParentheses: "missing parentheses",
                Error.paramShouldBeSeparatedByComma: "parameters should be separated by a comma",
                Error.expectedIdentifierFoundX: "expected identifier, found `%s`",
                Error.typesShouldBeSeparatedByComma: "types should be separated by a comma",
                Error.addingPubBeforeActionIsRedundant: "adding `public` before `action` is redundant",
                Error.actionAlreadyPublic: "action is already public",
                Error.cantOverrideXOp: "can't override `%s` operator",
                Error.opCantBeOverriden: "this operator can't be overriden",
                Error.missingTemplateSignature: "missing template signature",
                Error.emptyTemplateSignature: "empty template signature",
                Error.templateSignatureCantBeEmpty: "the template signature can't be empty",
                Error.missingSemicolonAfterTemplateDecl: "missing semicolon after template declaration",
                Error.convMustHave1RetVal: "a conversion must have only one return value",
                Error.convMustHave1Param: "a conversion must have only one parameter",
                Error.expected1ParamFoundX: "expected 1 parameter, found %s parameter",
                Error.expected1ParamFoundXs: "expected 1 parameter, found %s parameters",
                Error.missingCurlyBraces: "missing curly braces",
                Error.tryMustBeFollowedByCatch: "a `try` must always be followed by a `catch`",
                Error.expectedIntFoundX: "expected integer, found `%s`",
                Error.deferInsideDefer: "`defer` inside another `defer`",
                Error.cantDeferInsideDefer: "can't `defer` inside another `defer`",
                Error.xInsideDefer: "`%s` inside a defer",
                Error.cantXInsideDefer: "can't `%s` inside a defer",
                Error.breakOutsideLoop: "`break` outside of a loop",
                Error.cantBreakOutsideLoop: "can't `break` outside of a loop",
                Error.continueOutsideLoop: "`continue` outside of a loop",
                Error.cantContinueOutsideLoop: "can't `continue` outside of a loop",
                Error.xNotValidRetType: "`%s` is not a valid return type",
                Error.chanSizeMustBePositive: "a channel size must be a positive integer value",
                Error.missingCommaOrRightParenthesisInsideChanSignature: "missing `,` or `)` inside channel signature",
                Error.missingParenthesesAfterChanSignature: "missing parentheses after the channel signature",
                Error.chanSizeMustBeOneOrHigher: "the channel size must be one or higher",
                Error.expectedAtLeastSizeOf1FoundX: "expected at least a size of 1, found %s",
                Error.expectedCommaOrRightParenthesisFoundX: "expected `,` or `)`, found `%s`",
                Error.chanCantBeOfTypeX: "a channel can't be of type `%s`",
                Error.missingParenthesesAfterX: "missing parentheses after `%s`",
                Error.missingCommaInX: "missing comma in `%s`",
                Error.onlyOneDefaultCasePerX: "there must be only up to one default case per `%s`",
                Error.defaultCaseAlreadyDef: "default case already defined",
                Error.prevDefaultCaseDef: "previous default case definition",
                Error.missingWhileOrUntilAfterLoop: "missing `while` or `until` after the loop",
                Error.expectedWhileOrUntilFoundX: "expected `while` or `until`, found `%s`",
                Error.varDefOrRefExpected: "a variable definition or reference is expected",
                Error.varOrRefExpectedFoundX: "a variable or reference is expected, found `%s`",
                Error.varNameExpected: "a variable name is expected",
                Error.varNameExpectedFoundX: "a variable name is expected, found `%s`",
                Error.listCantBeOfTypeX: "a list can't be of type `%s`",
                Error.primXMustRetBoolAndVal: "the primitive `%s` must return a bool and a value",
                Error.signatureMismatch: "signature mismatch",
                Error.funcXMustRetBoolAndVal: "the function `%s` must return a bool and a value",
                Error.notIterable: "not iterable",
                Error.forCantIterateOverX: "for can't iterate over a `%s`",
                Error.cantEvalArityUnknownCompound: "can't evaluate the arity of an unknown compound",
                Error.arityEvalError: "arity evaluation error",
                Error.typeOfIteratorMustBeIntNotX: "the type of the iterator must be an integer, not `%s`",
                Error.iteratorMustBeInt: "the iterator must be an integer",
                Error.mismatchedNumRetVal: "mismatched number of return values",
                Error.expectedXRetValFoundY: "expected %s return value, found %s",
                Error.expectedXRetValsFoundY: "expected %s return values, found %s",
                Error.retSignatureOfTypeX: "the return signature is of type `%s`",
                Error.retTypeXNotMatchSignatureY: "the returned type `%s` does not match the signature `%s`",
                Error.expectedXVal: "expected `%s` value",
                Error.opNotListedInOpPriorityTable: "the operator is not listed in the operator priority table",
                Error.mismatchedTypes: "mismatched types",
                Error.missingX: "missing `%s`",
                Error.xNotClassType: "`%s` is not a class type",
                Error.fieldXInitMultipleTimes: "the field `%s` is initialized multiple times",
                Error.xAlreadyInit: "`%s` is already initialized",
                Error.prevInit: "previous initialization",
                Error.fieldXNotExist: "the field `%s` doesn't exist",
                Error.expectedFieldNameFoundX: "expected field name, found `%s`",
                Error.missingField: "missing field",
                Error.missingBracketsAfterX: "missing brackets after `%s`",
                Error.indexesShouldBeSeparatedByComma: "indexes should be separated by a comma",
                Error.missingVal: "missing value",
                Error.expectedIndexFoundComma: "an index is expected, found `,`",
                Error.expectedIntFoundNothing: "expected integer, found nothing",
                Error.noValToConv: "no value to convert",
                Error.expectedVarFoundX: "expected variable, found `%s`",
                Error.missingVar: "missing variable",
                Error.exprYieldsNoVal: "the expression yields no value",
                Error.expectedValFoundNothing: "expected value, found nothing",
                Error.missingSemicolonAfterExprList: "missing semicolon after expression list",
                Error.tryingAssignXValsToYVar: "trying to assign `%s` values to %s variable",
                Error.tryingAssignXValsToYVars: "trying to assign `%s` values to %s variables",
                Error.moreValThanVarToAssign: "there are more values than variable to assign to",
                Error.assignationMissingVal: "the assignation is missing a value",
                Error.expressionEmpty: "the expression is empty",
                Error.firstValOfAssignmentListCantBeEmpty: "first value of an assignment list can't be empty",
                Error.cantInferTypeWithoutAssignment: "can't infer the type without assignment",
                Error.missingTypeInfoOrInitVal: "missing type information or initial value",
                Error.missingSemicolonAfterAssignmentList: "missing semicolon after assignment list",
                Error.typeXHasNoDefaultVal: "the type `%s` has no default value",
                Error.cantInitThisType: "can't initialize this type",
                Error.missingParenthesesAfterType: "missing parentheses after the type",
                Error.expectedFuncNameFoundX: "expected function name, found `%s`",
                Error.missingFuncName: "missing function name",
                Error.cantInferTypeOfX: "can't infer the type of `%s`",
                Error.funcTypeCantBeInferred: "the function type can't be inferred",
                Error.unexpectedXFoundInExpr: "unexpected `%s` found in expression",
                Error.xCantExistInsideThisExpr: "a `%s` can't exist inside this expression",
                Error.methodCallMustBePlacedAfterVal: "a method call must be placed after a value",
                Error.listCantBeIndexedByX: "a list can't be indexed by a `%s`",
                Error.cantAccessFieldOnTypeX: "can't access a field on type `%s`",
                Error.expectedClassFoundX: "expected a class, found `%s`",
                Error.xOnTypeYIsPrivate: "`%s` on type `%s` is private",
                Error.privateField: "private field",
                Error.noFieldXOnTypeY: "no field `%s` on type `%s`",
                Error.availableFieldsAreX: "available fields are: %s",
                Error.missingParamOnMethodCall: "missing parameter on method call",
                Error.xMustBePlacedAfterVal: "`%s` must be placed after a value",
                Error.xMustBeInsideFuncOrTask: "`%s` must be inside a function or a task",
                Error.xRefNoFuncNorTask: "`%s` references no function nor task",
                Error.valBeforeAssignationNotReferenceable: "the value before assignation is not referenceable",
                Error.missingRefBeforeAssignation: "missing reference before assignation",
                Error.cantDoThisKindOfOpOnLeftSideOfAssignement: "can't do this kind of operation on the left side of an assignment",
                Error.unexpectedOp: "unexpected operation",
                Error.binOpMustHave2Operands: "a binary operation must have 2 operands",
                Error.unexpectedXSymbolInExpr: "unexpected `%s` symbol in the expression",
                Error.unexpectedSymbol: "unexpected symbol",
                Error.missingSemicolonAtEndOfExpr: "missing semicolon at the end of the expression",
                Error.cantLoadFieldOfTypeX: "can't load a field of type `%s`",
                Error.fieldTypeIsInvalid: "the field type is invalid",
                Error.xNotCallable: "`%s` is not callable",
                Error.xNotFuncNorTask: "`%s` is not a function nor a task",
                Error.funcTakesXArgButMoreWereSupplied: "the function takes %s argument but more were supplied",
                Error.funcTakesXArgsButMoreWereSupplied: "the function takes %s arguments but more were supplied",
                Error.funcIsOfTypeX: "the function is of type `%s`",
                Error.expectedXArg: "expected %s argument",
                Error.expectedXArgs: "expected %s arguments",
                Error.funcTakesXArgButYWereSupplied: "the function takes %s argument but %s were supplied",
                Error.funcTakesXArgsButYWereSupplied: "the function takes %s arguments but %s were supplied",
                Error.expectedXArgFoundY: "expected %s argument, found %s",
                Error.expectedXArgsFoundY: "expected %s arguments, found %s",
                Error.funcOrTaskExpectedFoundX: "function or task expected, found `%s`",
                Error.funcDefHere: "function defined here",
                Error.expectedDotAfterEnumType: "expected a `.` after the enum type",
                Error.missingEnumConstantName: "missing the enum constant name",
                Error.expectedConstNameAfterEnumType: "expected a constant name after the enum type"
            ],
            [ // fr_FR
                Error.eofReached: "fin de fichier atteinte",
                Error.eof: "fin de fichier inattendue",
                Error.unknownFunc: "fonction inconnue",
                Error.unknownVar: "variable inconnue",
                Error.unknownOp: "oprateur inconnu",
                Error.unknownClass: "classe inconnue",
                Error.unknownType: "type inconnu",
                Error.unknownOpPriority: "priorit doprateur inconnue",
                Error.unknownField: "champ inconnu",
                Error.invalidType: "type invalide",
                Error.invalidParamType: "type de paramtre invalide",
                Error.invalidChanType: "type de canal invalide",
                Error.invalidListType: "type de liste invalide",
                Error.invalidListIndexType: "type dindex de liste invalide",
                Error.xNotDef: "`%s` nest pas dfini",
                Error.xNotDecl: "`%s` nest pas dclar",
                Error.nameXDefMultipleTimes: "le nom `%s` est dfini plusieurs fois",
                Error.xRedefHere: "`%s` est redfini ici",
                Error.prevDefOfX: "prcdente dfinition de `%s`",
                Error.prevDefPrim: "`%s` est dj dfini en tant que primitive",
                Error.alreadyDef: "`%s` est dj dfini",
                Error.cantDefVarOfTypeX: "impossible dfinir une variable du type %s",
                Error.cantUseTypeAsParam: "impossible d'utiliser `%s` comme type de paramtre",
                Error.opMustHave1RetVal: "un operateur ne doit avoir qu'une valeur de retour",
                Error.expected1RetValFoundX: "1 valeur de retour attendue, %s valeur trouve",
                Error.expected1RetValFoundXs: "1 valeur de retour attendue, %s valeurs trouves",
                Error.cantUseOpOnMultipleVal: "impossible d'utiliser un oprateur sur plusieurs valeurs",
                Error.exprYieldsMultipleVal: "lexpression dlivre plusieurs valeurs",
                Error.noXUnaryOpDefForY: "il ny a pas doprateur unaire `%s` dfini pour `%s`",
                Error.noXBinaryOpDefForYAndZ: "il ny pas doprateur binaire `%s` dfini pour `%s` et `%s`",
                Error.xIsConstAndCantBeModified: "`%s` est constant et ne peut tre altr",
                Error.cantModifyAConstX: "impossible de modifier un `%s` constant",
                Error.cantAssignToAXVar: "impossible dassigner  une variable `%s`",
                Error.ValNotAssignable: "la valeur est non-assignable",
                Error.cantInferTypeOfVar: "impossible dinfrer le type de la variable",
                Error.varNotInit: "la variable na pas t initialise",
                Error.locVarUsedNotAssigned: "la variable locale est utilise sans avoir t assigne",
                Error.cantGetValueOfX: "impossible de rcuprer la valeure de `%s`",
                Error.valNotFetchable: "la valeur nest pas rcuprable",
                Error.globalDeclExpected: "une dclaration globale est attendue",
                Error.globalDeclExpectedFoundX: "une dclaration globale est attendue, `%s` trouv",
                Error.funcMissingRetAtEnd: "il manque un retour en fin de fonction",
                Error.missingRet: "`retourne` manquant",
                Error.expectedTypeAliasNameFoundX: "nom dalias de type attendu, `%s` trouv",
                Error.expectedEnumNameFoundX: "nom d'numration attendu, `%s` trouv",
                Error.expectedXFoundY: "`%s` attendu, `%s` trouv",
                Error.missingIdentifier: "identificateur attendu",
                Error.missingAssignInType: "assignation manquante dans `type`",
                Error.missingSemicolonAfterType: "point-virgule manquand dans `type`",
                Error.enumDefNotHaveBody: "la dfinition de lnumration na pas de corps",
                Error.expectedEnumFieldFoundX: "champ attendu dans lnumration, `%s` trouv",
                Error.missingSemicolonAfterEnumField: "point-virgule manquant aprs le champ de lnumration",
                Error.xAlreadyDecl: "`%s` est dj dclar",
                Error.expectedClassNameFoundX: "nom de classe attendu, `%s` trouv",
                Error.parentClassNameMissing: "le nom de la classe parente est manquante",
                Error.classHaveNoBody: "la classe na pas de corps",
                Error.missingSemicolonAfterClassFieldDecl: "point-virgule manquant aprs le champ de la classe",
                Error.xCantInheritFromY: "`%s` ne peut pas hriter de `%s`",
                Error.xIncludedRecursively: "`%s` est inclus rcursivement",
                Error.recursiveInheritence: "hritage rcursif",
                Error.fieldXDeclMultipleTimes: "le champ `%s` est dclar plusieurs fois",
                Error.recursiveDecl: "dclaration rcursive",
                Error.xNotValidType: "`%s` nest pas un type valide",
                Error.expectedValidTypeFoundX: "type valide attendu, `%s` trouv",
                Error.listCanOnlyContainOneTypeOfVal: "une liste ne peut contenir quun type de valeur",
                Error.conflictingListSignature: "signature de liste conflictuelle",
                Error.tryUsingXInstead: "utilisez plutt `%s`",
                Error.channelCanOnlyContainOneTypeOfVal: "un canal ne peut contenir quun type de valeur",
                Error.conflictingChannelSignature: "signature de canal conflictuelle",
                Error.missingTemplateVal: "valeur de patron manquante",
                Error.templateValShouldBeSeparatedByComma: "les valeurs de patron doivent tre spares par des virgules",
                Error.templateTypesShouldBeSeparatedByComma: "les types de patron doivent tre spars par des virgules",
                Error.missingParentheses: "parenthses manquantes",
                Error.paramShouldBeSeparatedByComma: "les paramtres doivent tre spares par des virgules",
                Error.expectedIdentifierFoundX: "identificateur attendu, `%s` trouv",
                Error.typesShouldBeSeparatedByComma: "les types doivent tre spars par des virgules",
                Error.addingPubBeforeActionIsRedundant: "ajouter `public` devant `action` est redondant",
                Error.actionAlreadyPublic: "les actions sont dj publiques",
                Error.cantOverrideXOp: "impossible de surcharger loprateur `%s`",
                Error.opCantBeOverriden: "cet oprateur ne peut tre surcharg",
                Error.missingTemplateSignature: "signature de patron manquante",
                Error.emptyTemplateSignature: "signature de patron vide",
                Error.templateSignatureCantBeEmpty: "la signature du patron ne peut tre vide",
                Error.missingSemicolonAfterTemplateDecl: "point-virgule manquant aprs la dclaration du patron",
                Error.convMustHave1RetVal: "une conversion ne peut avoir quune seule valeur de retour",
                Error.convMustHave1Param: "une conversion ne peut avoir quun seul paramtre",
                Error.expected1ParamFoundX: "1 paramtre attendu, %s paramtre trouv",
                Error.expected1ParamFoundXs: "1 paramtre attendu, %s paramtres trouvs",
                Error.missingCurlyBraces: "accolades manquantes",
                Error.tryMustBeFollowedByCatch: "un `essaie` doit toujours saccompagner dun `rcup`",
                Error.expectedIntFoundX: "entier attendu, `%s` trouv",
                Error.deferInsideDefer: "`dcale`  lintrieur dun autre `dcale`",
                Error.cantDeferInsideDefer: "impossible de faire un `dcale` dans un autre `defer`",
                Error.xInsideDefer: "`%s`  lintrieur dun dcale",
                Error.cantXInsideDefer: "impossible de faire un `%s` dans un dcale",
                Error.breakOutsideLoop: "`casse` en dehors dune boucle",
                Error.cantBreakOutsideLoop: "impossible de `casse` en dehors dune boucle",
                Error.continueOutsideLoop: "`continue` en dehors dune boucle",
                Error.cantContinueOutsideLoop: "impossible de `continue` en dehors dune boucle",
                Error.xNotValidRetType: "`%s` nest pas un type de retour valide",
                Error.chanSizeMustBePositive: "la taille dun canal doit tre un entier positif",
                Error.missingCommaOrRightParenthesisInsideChanSignature: "`,` ou `)` manquant dans la signature du canal",
                Error.missingParenthesesAfterChanSignature: "parenthses manquantes aprs la signature du canal",
                Error.chanSizeMustBeOneOrHigher: "la taille du canal doit tre de un ou plus",
                Error.expectedAtLeastSizeOf1FoundX: "une taille de 1 minimum attendue, %s trouv",
                Error.expectedCommaOrRightParenthesisFoundX: "`,` ou `)` attendu, `%s` trouv",
                Error.chanCantBeOfTypeX: "un canal ne peut tre de type `%s`",
                Error.missingParenthesesAfterX: "parenthses manquantes aprs `%s`",
                Error.missingCommaInX: "virgule manquante dans `%s`",
                Error.onlyOneDefaultCasePerX: "il ne peut y avoir un maximum dun cas par dfaut dans un `%s`",
                Error.defaultCaseAlreadyDef: "le cas par dfaut a dj t dfini",
                Error.prevDefaultCaseDef: "prcdente dfinition du cas par dfaut",
                Error.missingWhileOrUntilAfterLoop: "`tant` ou `jusque` manquant aprs la boucle",
                Error.expectedWhileOrUntilFoundX: "`tant` ou `jusque` attendu, `%s` trouv",
                Error.varDefOrRefExpected: "une dfinition de variable ou une rfrence est attendue",
                Error.varOrRefExpectedFoundX: "une variable ou rfrence est attendue, `%s` trouv",
                Error.varNameExpected: "un nom de variable est attendu",
                Error.varNameExpectedFoundX: "un nom de variable est attendu, `%s` trouv",
                Error.listCantBeOfTypeX: "une liste ne peut pas tre de type `%s`",
                Error.primXMustRetBoolAndVal: "la primitive `%s` doit retourner un boolen et une valeur",
                Error.signatureMismatch: "la signature ne correspond pas",
                Error.funcXMustRetBoolAndVal: "la function `%s` doit retourner un boolen et une valeur",
                Error.notIterable: "non-itrable",
                Error.forCantIterateOverX: "pour ne peut itrer sur `%s`",
                Error.cantEvalArityUnknownCompound: "impossible de calculer larit dun compos inconnu",
                Error.arityEvalError: "erreur de calcul darit",
                Error.typeOfIteratorMustBeIntNotX: "le type dun itrateur doit tre un entier, pas `%s`",
                Error.iteratorMustBeInt: "litrateur doit tre un entier",
                Error.mismatchedNumRetVal: "le nombre de valeur de retour ne correspond pas",
                Error.expectedXRetValFoundY: "%s valeur de retour attendue, %s trouv",
                Error.expectedXRetValsFoundY: "%s valeurs de retour attendues, %s trouv",
                Error.retSignatureOfTypeX: "la signature de retour est `%s`",
                Error.retTypeXNotMatchSignatureY: "le type retourn `%s` ne correspond pas avec la signature `%s`",
                Error.expectedXVal: "type `%s` attendu",
                Error.opNotListedInOpPriorityTable: "loprateur nest pas list dans la liste de priorit doprateurs",
                Error.mismatchedTypes: "types diffrents",
                Error.missingX: "`%s` manquant",
                Error.xNotClassType: "`%s` nest pas un type de classe",
                Error.fieldXInitMultipleTimes: "le champ `%s` est initialis plusieurs fois",
                Error.xAlreadyInit: "`%s` est dj initialis",
                Error.prevInit: "initialisation prcdente",
                Error.fieldXNotExist: "le champ `%s` nexiste pas",
                Error.expectedFieldNameFoundX: "nom de champ attendu, `%s` trouv",
                Error.missingField: "champ manquant",
                Error.missingBracketsAfterX: "il manque les crochets aprs `%s`",
                Error.indexesShouldBeSeparatedByComma: "les index doivent tre spars par une virgule",
                Error.missingVal: "valeur manquante",
                Error.expectedIndexFoundComma: "un index est attendu, `,` trouv",
                Error.expectedIntFoundNothing: "entier attendu, rien de trouv",
                Error.noValToConv: "aucune valeur  convertir",
                Error.expectedVarFoundX: "variable attendu, `%s` trouv",
                Error.missingVar: "variable manquante",
                Error.exprYieldsNoVal: "lexpression ne rend aucune valeur",
                Error.expectedValFoundNothing: "valeur attendue, rien de trouv",
                Error.missingSemicolonAfterExprList: "point-virgule manquant aprs la liste dexpressions",
                Error.tryingAssignXValsToYVar: "tentative dassigner `%s` valeurs  %s variable",
                Error.tryingAssignXValsToYVars: "tentative dassigner `%s` valeurs  %s variables",
                Error.moreValThanVarToAssign: "il y a plus de valeurs que de variables auquels affecter",
                Error.assignationMissingVal: "il manque une valeur  lassignation",
                Error.expressionEmpty: "lexpression est vide",
                Error.firstValOfAssignmentListCantBeEmpty: "la premire valeur dune liste dassignation ne peut tre vide",
                Error.cantInferTypeWithoutAssignment: "impossible dinfrer le type sans assignation",
                Error.missingTypeInfoOrInitVal: "information de type ou valeur initiale manquante",
                Error.missingSemicolonAfterAssignmentList: "point-virgule manquant aprs la liste dassignation",
                Error.typeXHasNoDefaultVal: "le type `%s` na pas de valeur par dfaut",
                Error.cantInitThisType: "impossible dinitialiser ce type",
                Error.missingParenthesesAfterType: "parenthses manquantes aprs le type",
                Error.expectedFuncNameFoundX: "nom de fonction attendu, `%s` trouv",
                Error.missingFuncName: "nom de fonction manquant",
                Error.cantInferTypeOfX: "impossible dinfrer le type de `%s`",
                Error.funcTypeCantBeInferred: "le type de la fonction ne peut pas tre infr",
                Error.unexpectedXFoundInExpr: "`%s` inattendu dans lexpression",
                Error.xCantExistInsideThisExpr: "un `%s` ne peut exister dans lexpression",
                Error.methodCallMustBePlacedAfterVal: "un appel de mthode doit se placer aprs une valeur",
                Error.listCantBeIndexedByX: "une liste ne peut pas tre index par un `%s`",
                Error.cantAccessFieldOnTypeX: "impossible daccder  un champ sur `%s`",
                Error.expectedClassFoundX: "classe attendue, `%s` trouv",
                Error.xOnTypeYIsPrivate: "`%s` du type `%s` est priv",
                Error.privateField: "champ priv",
                Error.noFieldXOnTypeY: "aucun champ `%s` dans `%s`",
                Error.availableFieldsAreX: "les champs disponibles sont: %s",
                Error.missingParamOnMethodCall: "paramtre manquant dans lappel de mthode",
                Error.xMustBePlacedAfterVal: "`%s` doit tre plac aprs une valeur",
                Error.xMustBeInsideFuncOrTask: "`%s` doit tre  lintrieur dune fonction ou dune tche",
                Error.xRefNoFuncNorTask: "`%s` ne rfrence aucune fonction ou tche",
                Error.valBeforeAssignationNotReferenceable: "la valeur devant lassignation nest pas rfrenable",
                Error.missingRefBeforeAssignation: "rfrence manquante avant lassignation",
                Error.cantDoThisKindOfOpOnLeftSideOfAssignement: "ce genre dopration est impossible  gauche dune assignation",
                Error.unexpectedOp: "opration inattendue",
                Error.binOpMustHave2Operands: "une opration binaire doit avoir 2 oprandes",
                Error.unexpectedXSymbolInExpr: "symbole `%s` inattendu dans lexpression",
                Error.unexpectedSymbol: "symbole inattendu",
                Error.missingSemicolonAtEndOfExpr: "point-virgule manquant en fin dexpression",
                Error.cantLoadFieldOfTypeX: "impossible de charger un champ de type `%s`",
                Error.fieldTypeIsInvalid: "le type de champ est invalide",
                Error.xNotCallable: "`%s` nest pas appelable",
                Error.xNotFuncNorTask: "`%s` nest ni une fonction ni une tche",
                Error.funcTakesXArgButMoreWereSupplied: "cette fonction prend %s argument mais plus ont t fournis",
                Error.funcTakesXArgsButMoreWereSupplied: "cette fonction prend %s arguments mais plus ont t fournis",
                Error.funcIsOfTypeX: "cette fonction est de type `%s`",
                Error.expectedXArg: "%s argument attendu",
                Error.expectedXArgs: "%s arguments attendus",
                Error.funcTakesXArgButYWereSupplied: "cette fonction prend %s argument mais %s ont t fournis",
                Error.funcTakesXArgsButYWereSupplied: "cette fonction prend %s arguments mais %s ont t fournis",
                Error.expectedXArgFoundY: "%s argument attendu, %s trouv",
                Error.expectedXArgsFoundY: "%s arguments attendus, %s trouv",
                Error.funcOrTaskExpectedFoundX: "fonction ou tche attendu, `%s` trouv",
                Error.funcDefHere: "fonction dfinie l",
                Error.expectedDotAfterEnumType: "`.` attendu aprs le type dnumration",
                Error.missingEnumConstantName: "nom de la constante dnumration attendu",
                Error.expectedConstNameAfterEnumType: "nom de la constante attendue aprs le type dnumration"
            ]
        ];
        return messages[_locale][error];
    }
}

/**
Syntatic error during parsing
*/
package final class GrParserException : Exception {
    GrError error;

    /// Ctor
    this(GrError error_, string file = __FILE__, size_t line = __LINE__) {
        super(error_.message, file, line);
        error = error_;
    }
}
