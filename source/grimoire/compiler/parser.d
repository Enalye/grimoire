/** 
 * Copyright: Enalye
 * License: Zlib
 * Authors: Enalye
 */
module grimoire.compiler.parser;

import std.stdio;
import std.string;
import std.array;
import std.conv;
import std.math;
import std.file;
import std.meta;

import grimoire.runtime;
import grimoire.assembly;
import grimoire.compiler.util;
import grimoire.compiler.lexer;
import grimoire.compiler.mangle;
import grimoire.compiler.type;
import grimoire.compiler.primitive;
import grimoire.compiler.data;
import grimoire.compiler.pretty;
import grimoire.compiler.error;

/**
Analyses the syntax and produce the data for the VM
The parser analyses the lexemes generated by the lexer and produce machine code.
*/
final class GrParser {
    package {
        int[] iconsts;
        float[] fconsts;
        string[] sconsts;

        uint scopeLevel;

        GrVariable[] globalVariables;
        GrFunction[] instanciatedFunctions, functionsQueue, functions, events;
        GrFunction[] anonymousFunctions;
        GrTemplateFunction[] templatedFunctions;

        uint current;
        GrFunction currentFunction;
        GrFunction[] functionStack;
        GrFunctionCall[] functionCalls;

        uint[][] breaksJumps;
        uint[][] continuesJumps;
        uint[] continuesDestinations;

        GrLexeme[] lexemes;

        bool isTypeChecking;

        /// Number of int based global variables declared.
        uint iglobalsCount, /// Number of float based global variables declared.
            fglobalsCount, /// Number of string based global variables declared.
            sglobalsCount, /// Number of ptr based global variables declared.
            oglobalsCount;
    }

    private {
        GrData _data;
        bool _isAssignationOptimizable;
        int _options;
    }

    /// Reset to the start of the sequence.
    private void reset() {
        current = 0u;
    }

    /// Advance to the next lexeme.
    private void advance() {
        if (current < lexemes.length)
            current++;
    }

    /// Return to the last lexeme.
    private void goBack() {
        if (current > 0u)
            current--;
    }

    /// Check for the end the sequence, then advance to the next lexeme.
    private bool checkAdvance() {
        if (isEnd())
            return false;

        advance();
        return true;
    }

    /// Start of a block with `{`
    private void openBlock() {
        scopeLevel++;
    }

    /// End of a block with '}'
    private void closeBlock() {
        scopeLevel--;
    }

    /// Check for the end of the sequence.
    private bool isEnd(int offset = 0) {
        return (current + offset) >= cast(uint) lexemes.length;
    }

    private void set(uint position_) {
        current = position_;
        if (current < 0 || current >= cast(uint) lexemes.length) {
            current = 0;
        }
    }

    /// Return the lexeme at the current position.
    private GrLexeme get(int offset = 0) {
        const uint position = current + offset;
        if (position < 0 || position >= cast(uint) lexemes.length) {
            logError("reached the end of the file", "unexpected end of file");
        }
        return lexemes[position];
    }

    /// Register an integral value and returns its id.
    private uint registerIntConstant(int value) {
        foreach (size_t index, int iconst; iconsts) {
            if (iconst == value)
                return cast(uint) index;
        }
        iconsts ~= value;
        return cast(uint) iconsts.length - 1;
    }

    /// Register an floating point value and returns its id.
    private uint registerFloatConstant(float value) {
        foreach (size_t index, float fconst; fconsts) {
            if (fconst == value)
                return cast(uint) index;
        }
        fconsts ~= value;
        return cast(uint) fconsts.length - 1;
    }

    /// Register an string value and returns its id.
    private uint registerStringConstant(string value) {
        foreach (size_t index, string sconst; sconsts) {
            if (sconst == value)
                return cast(uint) index;
        }
        sconsts ~= value;
        return cast(uint) sconsts.length - 1;
    }

    /// Register a special local variable, used for iterators, etc.
    private GrVariable registerSpecialVariable(string name, GrType type) {
        name = "~" ~ name;
        GrVariable specialVariable;
        auto previousVariable = (name in currentFunction.localVariables);
        if (previousVariable is null)
            specialVariable = registerLocalVariable(name, type);
        else
            specialVariable = *previousVariable;
        specialVariable.isAuto = false;
        specialVariable.isInitialized = true; //We shortcut this check
        return specialVariable;
    }

    /// Register a global variable
    private GrVariable registerGlobalVariable(string name, GrType type, bool isAuto, bool isPublic) {
        //Check if declared globally.
        assertNoGlobalDeclaration(name, get().fileId, isPublic);

        GrVariable variable = new GrVariable;
        variable.isAuto = isAuto;
        variable.isGlobal = true;
        variable.isInitialized = false;
        variable.type = type;
        variable.name = name;
        variable.isPublic = isPublic;
        variable.fileId = get().fileId;
        variable.lexPosition = current;
        if (!isAuto)
            setVariableRegister(variable);
        globalVariables ~= variable;

        return variable;
    }

    private GrVariable getGlobalVariable(string name, uint fileId, bool isPublic = false) {
        foreach (GrVariable var; globalVariables) {
            if (var.name == name && (var.fileId == fileId || var.isPublic || isPublic))
                return var;
        }
        return null;
    }

    private void assertNoGlobalDeclaration(string name, uint fileId, bool isPublic) {
        GrVariable var;
        GrFunction func;
        if ((var = getGlobalVariable(name, fileId, isPublic)) !is null)
            logError("the name `" ~ name ~ "` is defined multiple times", "`" ~ name ~ "` is redefined here",
                    "", 0, "previous definition of `" ~ name ~ "`", var.lexPosition);
        if (_data.isPrimitiveDeclared(name))
            logError("the name `" ~ name ~ "` is defined multiple times",
                    "`" ~ name ~ "` is already defined as a primitive");
        if ((func = getFunction(name, fileId, isPublic)) !is null)
            logError("the name `" ~ name ~ "` is defined multiple times", "`" ~ name ~ "` is redefined here",
                    "", 0, "previous definition of `" ~ name ~ "`", func.lexPosition);
        if ((func = getEvent(name)) !is null)
            logError("the name `" ~ name ~ "` is defined multiple times", "`" ~ name ~ "` is redefined here",
                    "", 0, "previous definition of `" ~ name ~ "`", func.lexPosition);
    }

    private void setVariableRegister(GrVariable variable) {
        final switch (variable.type.baseType) with (GrBaseType) {
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            if (variable.isGlobal) {
                variable.register = iglobalsCount;
                iglobalsCount++;
            }
            else {
                variable.register = currentFunction.ilocalsCount;
                currentFunction.ilocalsCount++;
            }
            break;
        case float_:
            if (variable.isGlobal) {
                variable.register = fglobalsCount;
                fglobalsCount++;
            }
            else {
                variable.register = currentFunction.flocalsCount;
                currentFunction.flocalsCount++;
            }
            break;
        case string_:
            if (variable.isGlobal) {
                variable.register = sglobalsCount;
                sglobalsCount++;
            }
            else {
                variable.register = currentFunction.slocalsCount;
                currentFunction.slocalsCount++;
            }
            break;
        case array_:
        case class_:
        case foreign:
        case chan:
            if (variable.isGlobal) {
                variable.register = oglobalsCount;
                oglobalsCount++;
            }
            else {
                variable.register = currentFunction.olocalsCount;
                currentFunction.olocalsCount++;
            }
            break;
        case internalTuple:
        case reference:
        case null_:
        case void_:
            logError("can't define a variable of type " ~ grGetPrettyType(variable.type),
                    "invalid type");
            break;
        }
    }

    /// Register a local variable
    private GrVariable registerLocalVariable(string name, GrType type) {
        //Check if declared globally
        assertNoGlobalDeclaration(name, get().fileId, false);

        //Check if declared locally.
        const auto previousVariable = (name in currentFunction.localVariables);
        if (previousVariable !is null)
            logError("the name `" ~ name ~ "` is defined multiple times", "`" ~ name ~ "` is redefined here", "", 0,
                    "previous definition of `" ~ name ~ "`", previousVariable.lexPosition);

        GrVariable variable = new GrVariable;
        variable.isGlobal = false;
        variable.type = type;
        variable.name = name;
        variable.fileId = get().fileId;
        variable.lexPosition = current;
        if (variable.type.baseType != GrBaseType.void_)
            setVariableRegister(variable);
        currentFunction.localVariables[name] = variable;

        return variable;
    }

    private void beginGlobalScope() {
        GrFunction globalScope = getFunction("@global", 0);
        if (globalScope) {
            functionStack ~= currentFunction;
            currentFunction = globalScope;
        }
        else {
            GrFunction func = new GrFunction;
            func.name = "@global";
            func.mangledName = func.name;
            func.isTask = false;
            func.inSignature = [];
            func.outSignature = [];
            func.isPublic = true;
            func.fileId = 0;
            func.lexPosition = 0;
            functions ~= func;
            functionStack ~= currentFunction;
            currentFunction = func;
        }
    }

    private void endGlobalScope() {
        if (!functionStack.length)
            throw new Exception("global scope mismatch");

        currentFunction = functionStack[$ - 1];
        functionStack.length--;
    }

    private void beginFunction(string name, uint fileId, GrType[] signature, bool isEvent = false) {
        const string mangledName = grMangleComposite(name, signature);

        GrFunction func;
        if (isEvent)
            func = getEvent(mangledName);
        else
            func = getFunction(mangledName, fileId);

        if (func is null)
            logError("`" ~ name ~ "` is not defined", "unknown function");

        functionStack ~= currentFunction;
        currentFunction = func;
    }

    private void preBeginFunction(string name, uint fileId, GrType[] signature,
            string[] inputVariables, bool isTask, GrType[] outSignature = [],
            bool isAnonymous = false, bool isEvent = false, bool isPublic = false) {
        GrFunction func = new GrFunction;
        func.isTask = isTask;
        func.inputVariables = inputVariables;
        func.inSignature = signature;
        func.outSignature = outSignature;
        func.fileId = fileId;

        if (isAnonymous) {
            //func.index = cast(uint) anonymousFunctions.length;
            func.anonParent = currentFunction;
            func.anonReference = cast(uint) currentFunction.instructions.length;
            func.name = currentFunction.name ~ "@anon" ~ to!string(func.index);
            func.mangledName = grMangleComposite(func.name, func.inSignature);
            anonymousFunctions ~= func;
            func.lexPosition = current;

            //Is replaced by the addr of the function later (see solveFunctionCalls).
            addInstruction(GrOpcode.const_int, 0u);
        }
        else {
            //func.index = cast(uint) functions.length;
            func.name = name;
            func.isPublic = isPublic;

            func.mangledName = grMangleComposite(name, signature);
            assertNoGlobalDeclaration(func.mangledName, fileId, isPublic);

            if (name == "main")
                func.isMain = true;

            func.isEvent = isEvent;
            func.lexPosition = current;
            functionsQueue ~= func;
        }

        functionStack ~= currentFunction;
        currentFunction = func;
        generateFunctionInputs();
    }

    private void endFunction() {
        int prependInstructionCount;
        if (_options & GrOption.profile) {
            prependInstructionCount++;
            const uint index = registerStringConstant(grGetPrettyFunction(currentFunction));
            addInstructionInFront(GrOpcode.debugProfileBegin, index);
        }

        if (currentFunction.ilocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_int, currentFunction.ilocalsCount);
            prependInstructionCount++;
        }

        if (currentFunction.flocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_float, currentFunction.flocalsCount);
            prependInstructionCount++;
        }

        if (currentFunction.slocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_string, currentFunction.slocalsCount);
            prependInstructionCount++;
        }

        if (currentFunction.olocalsCount > 0) {
            addInstructionInFront(GrOpcode.localStack_object, currentFunction.olocalsCount);
            prependInstructionCount++;
        }

        foreach (call; currentFunction.functionCalls)
            call.position += prependInstructionCount;

        currentFunction.offset += prependInstructionCount;

        if (!functionStack.length)
            throw new Exception("attempting to close a non-existing function");

        currentFunction = functionStack[$ - 1];
        functionStack.length--;
    }

    private void preEndFunction() {
        if (!functionStack.length)
            throw new Exception("attempting to close a non-existing function");
        currentFunction = functionStack[$ - 1];
        functionStack.length--;
    }

    /// Generate opcodes to fetch the function or the task's parameters
    void generateFunctionInputs() {
        void fetchParameter(string name, GrType type) {
            final switch (type.baseType) with (GrBaseType) {
            case void_:
            case null_:
                logError("can't use `" ~ grGetPrettyType(type) ~ "` as a parameter type",
                        "invalid parameter type");
                break;
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                currentFunction.nbIntegerParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_int, 0u);
                break;
            case float_:
                currentFunction.nbFloatParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_float, 0u);
                break;
            case string_:
                currentFunction.nbStringParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_string, 0u);
                break;
            case class_:
            case array_:
            case foreign:
            case chan:
            case reference:
                currentFunction.nbObjectParameters++;
                if (currentFunction.isTask)
                    addInstruction(GrOpcode.globalPop_object, 0u);
                break;
            case internalTuple:
                throw new Exception("tuples are not allowed here");
            }

            GrVariable newVar = new GrVariable;
            newVar.type = type;
            newVar.isInitialized = true;
            newVar.isGlobal = false;
            newVar.name = name;
            newVar.fileId = get().fileId;
            newVar.lexPosition = current;
            currentFunction.localVariables[name] = newVar;
            setVariableRegister(newVar);
            addSetInstruction(newVar, currentFunction.fileId);
        }

        foreach_reverse (size_t i, inputVariable; currentFunction.inputVariables) {
            fetchParameter(currentFunction.inputVariables[i], currentFunction.inSignature[i]);
        }
    }

    GrFunction getFunction(string mangledName, uint fileId = 0, bool isPublic = false) {
        foreach (GrFunction func; functions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                return func;
            }
        }
        return null;
    }

    GrFunction getFunction(string name, GrType[] signature, uint fileId = 0, bool isPublic = false) {
        const string mangledName = grMangleComposite(name, signature);
        foreach (GrFunction func; functions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                return func;
            }
        }
        foreach (GrFunction func; functions) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic))
                    return func;
            }
        }
        foreach (GrFunction func; functionsQueue) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                return func;
            }
        }
        foreach (GrFunction func; functionsQueue) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic))
                    return func;
            }
        }
        foreach (GrFunction func; instanciatedFunctions) {
            if (func.mangledName == mangledName && (func.fileId == fileId
                    || func.isPublic || isPublic)) {
                functionsQueue ~= func;

                functionStack ~= currentFunction;
                currentFunction = func;
                generateFunctionInputs();
                currentFunction = functionStack[$ - 1];
                functionStack.length--;

                return func;
            }
        }
        foreach (GrFunction func; instanciatedFunctions) {
            if (func.name == name && (func.fileId == fileId || func.isPublic || isPublic)) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId, isPublic)) {
                    functionsQueue ~= func;

                    functionStack ~= currentFunction;
                    currentFunction = func;
                    generateFunctionInputs();
                    currentFunction = functionStack[$ - 1];
                    functionStack.length--;

                    return func;
                }
            }
        }
        return null;
    }

    /// Remove a declared function
    void removeFunction(string name) {
        import std.algorithm : remove;

        for (int i; i < functions.length; ++i) {
            if (functions[i].mangledName == name) {
                functions = remove(functions, i);
                return;
            }
        }
    }

    private GrFunction getEvent(string name) {
        foreach (GrFunction func; events) {
            if (func.mangledName == name)
                return func;
        }
        return null;
    }

    private GrFunction getAnonymousFunction(string name) {
        foreach (GrFunction func; anonymousFunctions) {
            if (func.mangledName == name)
                return func;
        }
        return null;
    }

    GrFunction getAnonymousFunction(string name, GrType[] signature, uint fileId) {
        foreach (GrFunction func; anonymousFunctions) {
            if (func.mangledName == name)
                return func;
        }
        foreach (GrFunction func; anonymousFunctions) {
            if (func.name == name) {
                if (_data.isSignatureCompatible(signature, func.inSignature, fileId))
                    return func;
            }
        }
        return null;
    }

    /// Retrieve a declared variable
    private GrVariable getVariable(string name, uint fileId) {
        GrVariable globalVar = getGlobalVariable(name, fileId);
        if (globalVar !is null)
            return globalVar;

        GrVariable* localVar = (name in currentFunction.localVariables);
        if (localVar is null)
            logError("`" ~ name ~ "` is not declared", "unknown variable", "", -1);
        return *localVar;
    }

    private bool hasVariable(string name, uint fileId) {
        const GrVariable globalVar = getGlobalVariable(name, fileId);
        if (globalVar !is null)
            return true;

        const GrVariable* localVar = (name in currentFunction.localVariables);
        if (localVar !is null)
            return true;
        return false;
    }

    private void addIntConstant(int value) {
        addInstruction(GrOpcode.const_int, registerIntConstant(value));
    }

    private void addFloatConstant(float value) {
        addInstruction(GrOpcode.const_float, registerFloatConstant(value));
    }

    private void addBoolConstant(bool value) {
        addInstruction(GrOpcode.const_bool, value);
    }

    private void addStringConstant(string value) {
        addInstruction(GrOpcode.const_string, registerStringConstant(value));
    }

    private void addMetaConstant(string value) {
        addInstruction(GrOpcode.const_meta, registerStringConstant(value));
    }

    private void addInstruction(GrOpcode opcode, int value = 0, bool isSigned = false) {
        if (currentFunction is null)
            throw new Exception(
                    "the expression is located outside of a function or task, which is forbidden");

        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;
        currentFunction.instructions ~= instruction;

        if (_options & GrOption.symbols) {
            generateInstructionSymbol();
        }
    }

    private void addInstructionInFront(GrOpcode opcode, int value = 0, bool isSigned = false) {
        if (currentFunction is null)
            throw new Exception(
                    "the expression is located outside of a function or task, which is forbidden");

        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;
        currentFunction.instructions = instruction ~ currentFunction.instructions;

        if (_options & GrOption.symbols) {
            generateInstructionSymbol();
        }
    }

    private void generateInstructionSymbol() {
        GrFunction.DebugPositionSymbol symbol;
        int lexPos = (cast(int) current) - 2;
        if (lexPos < 0) {
            lexPos = 0;
        }
        if (lexPos >= cast(uint) lexemes.length) {
            lexPos = cast(uint)((cast(int) lexemes.length) - 1);
        }
        GrLexeme lex = lexemes[lexPos];
        symbol.line = lex.line + 1;
        symbol.column = lex.column;
        currentFunction.debugSymbol ~= symbol;
    }

    private void setInstruction(GrOpcode opcode, uint index, int value = 0u, bool isSigned = false) {
        if (currentFunction is null)
            throw new Exception(
                    "the expression is located outside of a function or task, which is forbidden");

        if (index >= currentFunction.instructions.length)
            throw new Exception("an instruction's index is exeeding the function size");

        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;
        currentFunction.instructions[index] = instruction;
    }

    private bool isBinaryOperator(GrLexemeType lexType) {
        if (lexType >= GrLexemeType.add && lexType <= GrLexemeType.xor)
            return true;
        else if (lexType == GrLexemeType.send)
            return true;
        else
            return false;
    }

    private bool isUnaryOperator(GrLexemeType lexType) {
        if (lexType >= GrLexemeType.plus && lexType <= GrLexemeType.minus)
            return true;
        else if (lexType >= GrLexemeType.increment && lexType <= GrLexemeType.decrement)
            return true;
        else if (lexType == GrLexemeType.not)
            return true;
        else if (lexType == GrLexemeType.receive)
            return true;
        else
            return false;
    }

    private GrType addCustomBinaryOperator(GrLexemeType lexType, GrType leftType,
            GrType rightType, uint fileId) {
        string name = "@op_" ~ grGetPrettyLexemeType(lexType);
        GrType[] signature = [leftType, rightType];

        //GrPrimitive check
        const GrPrimitive primitive = _data.getPrimitive(name, signature);
        if (primitive) {
            addInstruction(GrOpcode.primitiveCall, primitive.index);
            if (primitive.outSignature.length != 1uL) {
                const string argStr = to!string(primitive.outSignature.length) ~ (
                        primitive.outSignature.length > 1 ? " return values" : " return value");
                logError("an operator must have only one return value",
                        "expected 1 return value, found " ~ argStr);
            }
            return primitive.outSignature[0];
        }

        //GrFunction check
        GrFunction func = getFunction(name, signature, fileId);
        if (func) {
            auto outSignature = addFunctionCall(func, fileId);
            if (outSignature.length != 1uL) {
                const string argStr = to!string(outSignature.length) ~ (outSignature.length > 1
                        ? " return values" : " return value");
                logError("an operator must have only one return value",
                        "expected 1 return value, found " ~ argStr);
            }
            return outSignature[0];
        }

        return grVoid;
    }

    private GrType addCustomUnaryOperator(GrLexemeType lexType, const GrType type, uint fileId) {
        string name = "@op_" ~ grGetPrettyLexemeType(lexType);
        GrType[] signature = [type];

        //GrPrimitive check
        const GrPrimitive primitive = _data.getPrimitive(name, signature);
        if (primitive) {
            addInstruction(GrOpcode.primitiveCall, primitive.index);
            if (primitive.outSignature.length != 1uL) {
                const string argStr = to!string(primitive.outSignature.length) ~ (
                        primitive.outSignature.length > 1 ? " return values" : " return value");
                logError("an operator must have only one return value",
                        "expected 1 return value, found " ~ argStr);
            }
            return primitive.outSignature[0];
        }

        //GrFunction check
        GrFunction func = getFunction(name, signature, fileId);
        if (func) {
            auto outSignature = addFunctionCall(func, fileId);
            if (outSignature.length != 1uL) {
                const string argStr = to!string(outSignature.length) ~ (outSignature.length > 1
                        ? " return values" : " return value");
                logError("an operator must have only one return value",
                        "expected 1 return value, found " ~ argStr);
            }
            return outSignature[0];
        }

        return grVoid;
    }

    private GrType addBinaryOperator(GrLexemeType lexType, const GrType leftType,
            const GrType rightType, uint fileId) {
        if (leftType.baseType == GrBaseType.internalTuple
                || rightType.baseType == GrBaseType.internalTuple)
            logError("can't use an operator on multiple values",
                    "the expression yields multiple values");
        GrType resultType = GrBaseType.void_;

        if (leftType.baseType == GrBaseType.enum_ && rightType.baseType == GrBaseType.enum_
                && leftType.mangledType == rightType.mangledType) {
            resultType = addInternalOperator(lexType, leftType);
        }
        else if (leftType.baseType == GrBaseType.chan) {
            GrType chanType = grUnmangle(leftType.mangledType);
            convertType(rightType, chanType, fileId);
            resultType = addInternalOperator(lexType, leftType);
            if (resultType.baseType == GrBaseType.void_) {
                resultType = addCustomBinaryOperator(lexType, leftType, rightType, fileId);
            }
        }
        else if (lexType == GrLexemeType.concatenate
                && leftType.baseType == GrBaseType.array_ && leftType != rightType) {
            const GrType subType = grUnmangle(leftType.mangledType);
            convertType(rightType, subType, fileId);
            final switch (subType.baseType) with (GrBaseType) {
            case int_:
            case bool_:
            case enum_:
            case function_:
            case task:
                addInstruction(GrOpcode.append_int);
                break;
            case float_:
                addInstruction(GrOpcode.append_float);
                break;
            case string_:
                addInstruction(GrOpcode.append_string);
                break;
            case class_:
            case array_:
            case foreign:
            case chan:
                addInstruction(GrOpcode.append_object);
                break;
            case null_:
            case void_:
            case reference:
            case internalTuple:
                break;
            }
            resultType = leftType;
        }
        else if (lexType == GrLexemeType.concatenate
                && rightType.baseType == GrBaseType.array_ && leftType != rightType) {
            const GrType subType = grUnmangle(rightType.mangledType);
            convertType(leftType, subType, fileId);
            final switch (subType.baseType) with (GrBaseType) {
            case int_:
            case bool_:
            case enum_:
            case function_:
            case task:
                addInstruction(GrOpcode.prepend_int);
                break;
            case float_:
                addInstruction(GrOpcode.prepend_float);
                break;
            case string_:
                addInstruction(GrOpcode.prepend_string);
                break;
            case class_:
            case array_:
            case foreign:
            case chan:
                addInstruction(GrOpcode.prepend_object);
                break;
            case null_:
            case void_:
            case reference:
            case internalTuple:
                break;
            }
            resultType = rightType;
        }
        else if (lexType == GrLexemeType.concatenate
                && leftType.baseType == GrBaseType.string_ && leftType != rightType) {
            convertType(rightType, leftType, fileId);
            resultType = addInternalOperator(lexType, leftType);
        }
        else if (lexType == GrLexemeType.concatenate
                && rightType.baseType == GrBaseType.string_ && leftType != rightType) {
            convertType(leftType, rightType, fileId);
            resultType = addInternalOperator(lexType, rightType, true);
        }
        else if (leftType.baseType == GrBaseType.int_ && rightType.baseType == GrBaseType.float_) {
            // Special case, we need to convert int to float, then swap the 2 values when needed.
            convertType(leftType, rightType, fileId);
            resultType = addInternalOperator(lexType, rightType, true);
        }
        else if (leftType != rightType) {
            //Check custom operator
            resultType = addCustomBinaryOperator(lexType, leftType, rightType, fileId);

            //If there is no custom operator defined, we try to convert and then try again
            if (resultType.baseType == GrBaseType.void_) {
                resultType = convertType(rightType, leftType, fileId, true);
                if (resultType.baseType != GrBaseType.void_) {
                    resultType = addBinaryOperator(lexType, resultType, resultType, fileId);
                }
            }
        }
        else {
            resultType = addInternalOperator(lexType, leftType);
            if (resultType.baseType == GrBaseType.void_) {
                resultType = addCustomBinaryOperator(lexType, leftType, rightType, fileId);
            }
        }
        if (resultType.baseType == GrBaseType.void_)
            logError("there is no `" ~ grGetPrettyLexemeType(
                    lexType) ~ "` binary operator defined for `" ~ grGetPrettyType(
                    leftType) ~ "` and `" ~ grGetPrettyType(rightType) ~ "`",
                    "unknown operator", "", -1);
        return resultType;
    }

    private GrType addUnaryOperator(GrLexemeType lexType, const GrType type, uint fileId) {
        if (type.baseType == GrBaseType.internalTuple)
            logError("can't use an operator on multiple values",
                    "the expression yields multiple values");
        GrType resultType = GrBaseType.void_;

        resultType = addInternalOperator(lexType, type);
        if (resultType.baseType == GrBaseType.void_) {
            resultType = addCustomUnaryOperator(lexType, type, fileId);
        }

        if (resultType.baseType == GrBaseType.void_)
            logError("there is no `" ~ grGetPrettyLexemeType(
                    lexType) ~ "` unary operator defined for `" ~ grGetPrettyType(type) ~ "`",
                    "unknown operator");
        return resultType;
    }

    private GrType addOperator(GrLexemeType lexType, ref GrType[] typeStack, uint fileId) {
        if (isBinaryOperator(lexType)) {
            typeStack[$ - 2] = addBinaryOperator(lexType, typeStack[$ - 2],
                    typeStack[$ - 1], fileId);
            typeStack.length--;
            return typeStack[$ - 1];
        }
        else if (isUnaryOperator(lexType)) {
            typeStack[$ - 1] = addUnaryOperator(lexType, typeStack[$ - 1], fileId);
            return typeStack[$ - 1];
        }

        return GrType(GrBaseType.void_);
    }

    private GrType addInternalOperator(GrLexemeType lexType, GrType varType, bool isSwapped = false) {
        switch (varType.baseType) with (GrBaseType) {
        case class_:
        case foreign:
            switch (lexType) with (GrLexemeType) {
            case not:
                addInstruction(GrOpcode.isNonNull_object);
                addInstruction(GrOpcode.not_int);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case enum_:
            switch (lexType) with (GrLexemeType) {
            case equal:
                addInstruction(GrOpcode.equal_int);
                return GrType(GrBaseType.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_int);
                return GrType(GrBaseType.bool_);
            case greater:
                addInstruction(GrOpcode.greater_int);
                return GrType(GrBaseType.bool_);
            case greaterOrEqual:
                addInstruction(GrOpcode.greaterOrEqual_int);
                return GrType(GrBaseType.bool_);
            case lesser:
                addInstruction(GrOpcode.lesser_int);
                return GrType(GrBaseType.bool_);
            case lesserOrEqual:
                addInstruction(GrOpcode.lesserOrEqual_int);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case bool_:
            switch (lexType) with (GrLexemeType) {
            case and:
                addInstruction(GrOpcode.and_int);
                return GrType(GrBaseType.bool_);
            case or:
                addInstruction(GrOpcode.or_int);
                return GrType(GrBaseType.bool_);
            case not:
                addInstruction(GrOpcode.not_int);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case int_:
            switch (lexType) with (GrLexemeType) {
            case add:
                addInstruction(GrOpcode.add_int);
                return GrType(GrBaseType.int_);
            case substract:
                addInstruction(GrOpcode.substract_int);
                return GrType(GrBaseType.int_);
            case multiply:
                addInstruction(GrOpcode.multiply_int);
                return GrType(GrBaseType.int_);
            case divide:
                addInstruction(GrOpcode.divide_int);
                return GrType(GrBaseType.int_);
            case remainder:
                addInstruction(GrOpcode.remainder_int);
                return GrType(GrBaseType.int_);
            case minus:
                addInstruction(GrOpcode.negative_int);
                return GrType(GrBaseType.int_);
            case plus:
                return GrType(GrBaseType.int_);
            case increment:
                addInstruction(GrOpcode.increment_int);
                return GrType(GrBaseType.int_);
            case decrement:
                addInstruction(GrOpcode.decrement_int);
                return GrType(GrBaseType.int_);
            case equal:
                addInstruction(GrOpcode.equal_int);
                return GrType(GrBaseType.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_int);
                return GrType(GrBaseType.bool_);
            case greater:
                addInstruction(GrOpcode.greater_int);
                return GrType(GrBaseType.bool_);
            case greaterOrEqual:
                addInstruction(GrOpcode.greaterOrEqual_int);
                return GrType(GrBaseType.bool_);
            case lesser:
                addInstruction(GrOpcode.lesser_int);
                return GrType(GrBaseType.bool_);
            case lesserOrEqual:
                addInstruction(GrOpcode.lesserOrEqual_int);
                return GrType(GrBaseType.bool_);
            case not:
                addInstruction(GrOpcode.not_int);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case float_:
            switch (lexType) with (GrLexemeType) {
            case add:
                addInstruction(GrOpcode.add_float);
                return GrType(GrBaseType.float_);
            case substract:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_float);
                addInstruction(GrOpcode.substract_float);
                return GrType(GrBaseType.float_);
            case multiply:
                addInstruction(GrOpcode.multiply_float);
                return GrType(GrBaseType.float_);
            case divide:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_float);
                addInstruction(GrOpcode.divide_float);
                return GrType(GrBaseType.float_);
            case remainder:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_float);
                addInstruction(GrOpcode.remainder_float);
                return GrType(GrBaseType.float_);
            case minus:
                addInstruction(GrOpcode.negative_float);
                return GrType(GrBaseType.float_);
            case plus:
                return GrType(GrBaseType.float_);
            case increment:
                addInstruction(GrOpcode.increment_float);
                return GrType(GrBaseType.float_);
            case decrement:
                addInstruction(GrOpcode.decrement_float);
                return GrType(GrBaseType.float_);
            case equal:
                addInstruction(GrOpcode.equal_float);
                return GrType(GrBaseType.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_float);
                return GrType(GrBaseType.bool_);
            case greater:
                if (isSwapped)
                    addInstruction(GrOpcode.lesserOrEqual_float);
                else
                    addInstruction(GrOpcode.greater_float);
                return GrType(GrBaseType.bool_);
            case greaterOrEqual:
                if (isSwapped)
                    addInstruction(GrOpcode.lesser_float);
                else
                    addInstruction(GrOpcode.greaterOrEqual_float);
                return GrType(GrBaseType.bool_);
            case lesser:
                if (isSwapped)
                    addInstruction(GrOpcode.greaterOrEqual_float);
                else
                    addInstruction(GrOpcode.lesser_float);
                return GrType(GrBaseType.bool_);
            case lesserOrEqual:
                if (isSwapped)
                    addInstruction(GrOpcode.greater_float);
                else
                    addInstruction(GrOpcode.lesserOrEqual_float);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case string_:
            switch (lexType) with (GrLexemeType) {
            case concatenate:
                if (isSwapped)
                    addInstruction(GrOpcode.swap_string);
                addInstruction(GrOpcode.concatenate_string);
                return GrType(GrBaseType.string_);
            case equal:
                addInstruction(GrOpcode.equal_string);
                return GrType(GrBaseType.bool_);
            case notEqual:
                addInstruction(GrOpcode.notEqual_string);
                return GrType(GrBaseType.bool_);
            default:
                break;
            }
            break;
        case array_:
            switch (lexType) with (GrLexemeType) {
            case equal:
                const GrType subType = grUnmangle(varType.mangledType);
                final switch (subType.baseType) with (GrBaseType) {
                case int_:
                case bool_:
                case enum_:
                case function_:
                case task:
                    addInstruction(GrOpcode.equal_intArray);
                    return grBool;
                case float_:
                    addInstruction(GrOpcode.equal_floatArray);
                    return grBool;
                case string_:
                    addInstruction(GrOpcode.equal_stringArray);
                    return grBool;
                case null_:
                case void_:
                case reference:
                case internalTuple:
                case array_:
                case class_:
                case foreign:
                case chan:
                    break;
                }
                break;
            case notEqual:
                const GrType subType = grUnmangle(varType.mangledType);
                final switch (subType.baseType) with (GrBaseType) {
                case int_:
                case bool_:
                case enum_:
                case function_:
                case task:
                    addInstruction(GrOpcode.notEqual_intArray);
                    return grBool;
                case float_:
                    addInstruction(GrOpcode.notEqual_floatArray);
                    return grBool;
                case string_:
                    addInstruction(GrOpcode.notEqual_stringArray);
                    return grBool;
                case null_:
                case void_:
                case reference:
                case internalTuple:
                case array_:
                case class_:
                case foreign:
                case chan:
                    break;
                }
                break;
            case concatenate:
                const GrType subType = grUnmangle(varType.mangledType);
                final switch (subType.baseType) with (GrBaseType) {
                case int_:
                case bool_:
                case enum_:
                case function_:
                case task:
                    addInstruction(GrOpcode.concatenate_intArray);
                    return varType;
                case float_:
                    addInstruction(GrOpcode.concatenate_floatArray);
                    return varType;
                case string_:
                    addInstruction(GrOpcode.concatenate_stringArray);
                    return varType;
                case class_:
                case array_:
                case foreign:
                case chan:
                    addInstruction(GrOpcode.concatenate_objectArray);
                    return varType;
                case null_:
                case void_:
                case reference:
                case internalTuple:
                    break;
                }
                break;
            default:
                break;
            }
            break;
        case chan:
            switch (lexType) with (GrLexemeType) {
            case send:
                GrType chanType = grUnmangle(varType.mangledType);
                final switch (chanType.baseType) with (GrBaseType) {
                case int_:
                case bool_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.send_int);
                    return chanType;
                case float_:
                    addInstruction(GrOpcode.send_float);
                    return chanType;
                case string_:
                    addInstruction(GrOpcode.send_string);
                    return chanType;
                case class_:
                case array_:
                case foreign:
                case chan:
                    addInstruction(GrOpcode.send_object);
                    return chanType;
                case void_:
                case null_:
                case internalTuple:
                case reference:
                    break;
                }
                break;
            case receive:
                GrType chanType = grUnmangle(varType.mangledType);
                final switch (chanType.baseType) with (GrBaseType) {
                case int_:
                case bool_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.receive_int);
                    return chanType;
                case float_:
                    addInstruction(GrOpcode.receive_float);
                    return chanType;
                case string_:
                    addInstruction(GrOpcode.receive_string);
                    return chanType;
                case class_:
                case array_:
                case foreign:
                case chan:
                    addInstruction(GrOpcode.receive_object);
                    return chanType;
                case void_:
                case null_:
                case internalTuple:
                case reference:
                    break;
                }
                break;
            default:
                break;
            }
            break;
        default:
            break;
        }
        return GrType(GrBaseType.void_);
    }

    private void addSetInstruction(GrVariable variable, uint fileId,
            GrType valueType = grVoid, bool isExpectingValue = false) {
        _isAssignationOptimizable = true;
        if (variable.isConstant)
            logError("`" ~ variable.name ~ "` is const and can't be modified",
                    "can't modify a const `" ~ grGetPrettyType(variable.type) ~ "`");
        if (variable.type.baseType == GrBaseType.reference) {
            valueType = convertType(valueType, grUnmangle(variable.type.mangledType), fileId);
            final switch (valueType.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case chan:
            case enum_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_int : GrOpcode.refStore_int);
                break;
            case float_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_float : GrOpcode
                        .refStore_float);
                break;
            case string_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_string
                        : GrOpcode.refStore_string);
                break;
            case class_:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_object
                        : GrOpcode.refStore_object);
                break;
            case array_:
            case foreign:
                addInstruction(isExpectingValue ? GrOpcode.refStore2_object
                        : GrOpcode.refStore_object);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError("can't assign to a `" ~ grGetPrettyType(variable.type) ~ "` variable",
                        "the value is not assignable");
            }
            return;
        }

        if (variable.isAuto && !variable.isInitialized) {
            variable.isInitialized = true;
            variable.isAuto = false;
            variable.type = valueType;
            if (valueType.baseType == GrBaseType.void_)
                logError("can't infer the type of variable",
                        "the variable has not been initialized");
            else
                setVariableRegister(variable);
        }

        if (valueType.baseType != GrBaseType.void_)
            convertType(valueType, variable.type, fileId);

        //if(!variable.isInitialized && isExpectingValue)
        //    logError("Uninitialized variable", "The variable is being used without being assigned");
        variable.isInitialized = true;

        if (variable.isField) {
            final switch (variable.type.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(GrOpcode.fieldStore_int, isExpectingValue ? 0 : -1, true);
                break;
            case float_:
                addInstruction(GrOpcode.fieldStore_float, isExpectingValue ? 0 : -1, true);
                break;
            case string_:
                addInstruction(GrOpcode.fieldStore_string, isExpectingValue ? 0 : -1, true);
                break;
            case foreign:
            case reference:
            case chan:
            case array_:
            case class_:
                addInstruction(GrOpcode.fieldStore_object, isExpectingValue ? 0 : -1, true);
                break;
            case void_:
            case null_:
            case internalTuple:
                logError("can't assign to a `" ~ grGetPrettyType(variable.type) ~ "` variable",
                        "the value is not assignable");
            }
        }
        else if (variable.isGlobal) {
            final switch (variable.type.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_int
                        : GrOpcode.globalStore_int, variable.register);
                break;
            case float_:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_float
                        : GrOpcode.globalStore_float, variable.register);
                break;
            case string_:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_string
                        : GrOpcode.globalStore_string, variable.register);
                break;
            case chan:
            case class_:
            case array_:
            case foreign:
                addInstruction(isExpectingValue ? GrOpcode.globalStore2_object
                        : GrOpcode.globalStore_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError("can't assign to a `" ~ grGetPrettyType(variable.type) ~ "` variable",
                        "the value is not assignable");
            }
        }
        else {
            final switch (variable.type.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_int
                        : GrOpcode.localStore_int, variable.register);
                break;
            case float_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_float
                        : GrOpcode.localStore_float, variable.register);
                break;
            case string_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_string
                        : GrOpcode.localStore_string, variable.register);
                break;
            case class_:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_object
                        : GrOpcode.localStore_object, variable.register);
                break;
            case array_:
            case foreign:
            case chan:
                addInstruction(isExpectingValue ? GrOpcode.localStore2_object
                        : GrOpcode.localStore_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError("can't assign to a `" ~ grGetPrettyType(variable.type) ~ "` variable",
                        "the value is not assignable");
            }
        }
    }

    ///Add a load opcode, or optimize a previous store.
    void addGetInstruction(GrVariable variable, GrType expectedType = grVoid,
            bool allowOptimization = true) {
        if (!_isAssignationOptimizable) {
            /+--------------------------
                Optimizing getters should take care of scope levels as jumps will break the VM.
                This shouldn't be optimized as the stack will be empty on the second pass.
                "main {
                    bool a = true;
                    loop {
                        if(a) {}  //a is just after a = true, so will be optimized.
                        yield;
                    } //We jump back to the loop where lstore2 is, crashing the VM.
                }"
                To avoid that, we disallow optimization of different scope levels.
            -------------------------+/
            allowOptimization = false;
        }

        if (variable.isField) {
            throw new Exception("attempt to get field value");
        }
        else if (variable.isGlobal) {
            final switch (variable.type.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                if (allowOptimization && currentFunction.instructions.length
                        && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_int
                        && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_int;
                else
                    addInstruction(GrOpcode.globalLoad_int, variable.register);
                break;
            case float_:
                if (allowOptimization && currentFunction.instructions.length
                        && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_float
                        && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_float;
                else
                    addInstruction(GrOpcode.globalLoad_float, variable.register);
                break;
            case string_:
                if (allowOptimization && currentFunction.instructions.length
                        && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_string
                        && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_string;
                else
                    addInstruction(GrOpcode.globalLoad_string, variable.register);
                break;
            case class_:
                if (allowOptimization && currentFunction.instructions.length
                        && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_object
                        && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_object;
                else
                    addInstruction(GrOpcode.globalLoad_object, variable.register);
                break;
            case array_:
            case foreign:
            case chan:
                if (allowOptimization && currentFunction.instructions.length
                        && currentFunction.instructions[$ - 1].opcode == GrOpcode.globalStore_object
                        && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.globalStore2_object;
                else
                    addInstruction(GrOpcode.globalLoad_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError("can't get the value of `" ~ grGetPrettyType(variable.type) ~ "`",
                        "the value is not fetchable");
            }
        }
        else {
            if (!variable.isInitialized)
                logError("the local variable is being used without being assigned",
                        "uninitialized variable");

            final switch (variable.type.baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                if (allowOptimization && currentFunction.instructions.length
                        && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_int
                        && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_int;
                else
                    addInstruction(GrOpcode.localLoad_int, variable.register);
                break;
            case float_:
                if (allowOptimization && currentFunction.instructions.length
                        && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_float
                        && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_float;
                else
                    addInstruction(GrOpcode.localLoad_float, variable.register);
                break;
            case string_:
                if (allowOptimization && currentFunction.instructions.length
                        && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_string
                        && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_string;
                else
                    addInstruction(GrOpcode.localLoad_string, variable.register);
                break;
            case class_:
                if (allowOptimization && currentFunction.instructions.length
                        && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_object
                        && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_object;
                else
                    addInstruction(GrOpcode.localLoad_object, variable.register);
                break;
            case array_:
            case foreign:
            case chan:
                if (allowOptimization && currentFunction.instructions.length
                        && currentFunction.instructions[$ - 1].opcode == GrOpcode.localStore_object
                        && currentFunction.instructions[$ - 1].value == variable.register)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.localStore2_object;
                else
                    addInstruction(GrOpcode.localLoad_object, variable.register);
                break;
            case void_:
            case null_:
            case internalTuple:
            case reference:
                logError("can't get the value of `" ~ grGetPrettyType(variable.type) ~ "`",
                        "the value is not fetchable");
            }
        }
    }

    private GrType addFunctionAddress(string name, GrType[] signature, uint fileId) {
        if (name == "@global")
            return grVoid;
        GrFunctionCall call = new GrFunctionCall;
        call.name = name;
        call.signature = signature;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = true;
        auto func = getFunction(name, signature, fileId);
        if (func is null)
            func = getAnonymousFunction(name, signature, fileId);
        if (func !is null) {
            call.functionToCall = func;
            call.position = cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.const_int, 0);

            return grGetFunctionAsType(func);
        }
        return grVoid;
    }

    private GrType addFunctionAddress(GrFunction func, uint fileId) {
        if (func.name == "@global")
            return grVoid;
        GrFunctionCall call = new GrFunctionCall;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = true;
        call.functionToCall = func;
        call.position = cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.const_int, 0);
        return grGetFunctionAsType(func);
    }

    private GrType[] addFunctionCall(string name, GrType[] signature, uint fileId) {
        GrFunctionCall call = new GrFunctionCall;
        call.name = name;
        call.signature = signature;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = false;
        call.fileId = fileId;

        GrFunction func = getFunction(name, signature, call.fileId, false);
        if (func) {
            call.functionToCall = func;
            if (func.isTask) {
                if (func.nbIntegerParameters > 0)
                    addInstruction(GrOpcode.globalPush_int, func.nbIntegerParameters);
                if (func.nbFloatParameters > 0)
                    addInstruction(GrOpcode.globalPush_float, func.nbFloatParameters);
                if (func.nbStringParameters > 0)
                    addInstruction(GrOpcode.globalPush_string, func.nbStringParameters);
                if (func.nbObjectParameters > 0)
                    addInstruction(GrOpcode.globalPush_object, func.nbObjectParameters);
            }

            call.position = cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.call, 0);

            return func.outSignature;
        }
        else
            logError("`" ~ grGetPrettyFunctionCall(name,
                    signature) ~ "` is not declared", "unknown function", "", -1);

        return [];
    }

    private GrType[] addFunctionCall(GrFunction func, uint fileId) {
        GrFunctionCall call = new GrFunctionCall;
        call.name = func.name;
        call.signature = func.inSignature;
        call.caller = currentFunction;
        functionCalls ~= call;
        currentFunction.functionCalls ~= call;
        call.isAddress = false;
        call.fileId = fileId;

        call.functionToCall = func;
        if (func.isTask) {
            if (func.nbIntegerParameters > 0)
                addInstruction(GrOpcode.globalPush_int, func.nbIntegerParameters);
            if (func.nbFloatParameters > 0)
                addInstruction(GrOpcode.globalPush_float, func.nbFloatParameters);
            if (func.nbStringParameters > 0)
                addInstruction(GrOpcode.globalPush_string, func.nbStringParameters);
            if (func.nbObjectParameters > 0)
                addInstruction(GrOpcode.globalPush_object, func.nbObjectParameters);
        }

        call.position = cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.call, 0);

        return func.outSignature;
    }

    private void setOpcode(ref uint[] opcodes, uint position, GrOpcode opcode,
            uint value = 0u, bool isSigned = false) {
        GrInstruction instruction;
        instruction.opcode = opcode;
        if (isSigned) {
            if ((value >= 0x800000) || (-value >= 0x800000))
                throw new Exception("an opcode's signed value is exceeding limits");
            instruction.value = value + 0x800000;
        }
        else
            instruction.value = value;

        uint makeOpcode(uint instr, uint value) {
            return ((value << 8u) & 0xffffff00) | (instr & 0xff);
        }

        opcodes[position] = makeOpcode(cast(uint) instruction.opcode, instruction.value);
    }

    package void solveFunctionCalls(ref uint[] opcodes) {
        foreach (GrFunctionCall call; functionCalls) {
            GrFunction func = call.functionToCall;
            if (!func)
                func = getFunction(call.name, call.signature, call.fileId);
            if (!func)
                func = getAnonymousFunction(call.name, call.signature, call.fileId);
            if (func) {
                if (call.isAddress)
                    setOpcode(opcodes, call.position, GrOpcode.const_int,
                            registerIntConstant(func.position));
                else if (func.isTask)
                    setOpcode(opcodes, call.position, GrOpcode.task, func.position);
                else
                    setOpcode(opcodes, call.position, GrOpcode.call, func.position);
            }
            else
                logError("`" ~ grGetPrettyFunctionCall(call.name,
                        call.signature) ~ "` is not declared", "unknown function");
        }

        foreach (func; anonymousFunctions)
            setOpcode(opcodes, func.anonParent.position + func.anonParent.offset + func.anonReference,
                    GrOpcode.const_int, registerIntConstant(func.position));
    }

    package void dump() {
        writeln("Code Generated:\n");
        foreach (size_t i, int ivalue; iconsts)
            writeln(".iconst " ~ to!string(ivalue) ~ "\t;" ~ to!string(i));

        foreach (size_t i, float fvalue; fconsts)
            writeln(".fconst " ~ to!string(fvalue) ~ "\t;" ~ to!string(i));

        foreach (size_t i, string svalue; sconsts)
            writeln(".sconst " ~ to!string(svalue) ~ "\t;" ~ to!string(i));

        foreach (GrFunction func; functions) {
            if (func.isTask)
                writeln("\n.task " ~ func.name);
            else
                writeln("\n.function " ~ func.name);

            foreach (size_t i, GrInstruction instruction; func.instructions) {
                writeln("[" ~ to!string(i) ~ "] " ~ to!string(
                        instruction.opcode) ~ " " ~ to!string(instruction.value));
            }
        }
    }

    package void parseScript(GrData data, GrLexer lexer, int options) {
        _data = data;
        _options = options;

        bool isPublic;
        lexemes = lexer.lexemes;

        beginGlobalScope();
        foreach (GrVariableDefinition variableDef; _data._variableDefinitions) {
            GrVariable variable = registerGlobalVariable(variableDef.name,
                    variableDef.type, false, true);
            variable.isConstant = variableDef.isConstant;
            variableDef.register = variable.register;
        }
        endGlobalScope();

        //Type definitions
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexemeType.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexemeType) {
            case semicolon:
                checkAdvance();
                break;
            case class_:
                registerClassDeclaration(isPublic);
                break;
            case enum_:
                parseEnumDeclaration(isPublic);
                break;
            case main_:
            case event_:
            case taskType:
            case functionType:
                skipDeclaration();
                break;
            case type_:
            case template_:
            default:
                skipExpression();
                break;
            }
        }

        //Type aliases
        reset();
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexemeType.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexemeType) {
            case semicolon:
                checkAdvance();
                break;
            case type_:
                parseTypeAliasDeclaration(isPublic);
                break;
            case main_:
            case event_:
            case taskType:
            case functionType:
            case class_:
            case enum_:
                skipDeclaration();
                break;
            case template_:
            default:
                skipExpression();
                break;
            }
        }

        //Function definitions
        reset();
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexemeType.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexemeType) {
            case semicolon:
                checkAdvance();
                break;
            case enum_:
            case class_:
                skipDeclaration();
                break;
            case main_:
                parseMainDeclaration(isPublic);
                break;
            case event_:
                parseEventDeclaration(isPublic);
                break;
            case taskType:
                if (get(1).type != GrLexemeType.identifier && get(1).type != GrLexemeType.lesser)
                    goto case intType;
                parseTaskDeclaration(isPublic);
                break;
            case functionType:
                if (get(1).type != GrLexemeType.identifier && get(1)
                        .type != GrLexemeType.as && get(1).type != GrLexemeType.lesser)
                    goto case intType;
                parseFunctionDeclaration(isPublic);
                break;
            case intType: .. case chanType:
            case autoType:
            case identifier:
            case type_:
            case template_:
                skipExpression();
                break;
            default:
                logError("a global declaration is expected",
                        "a global declaration is expected, found `" ~ grGetPrettyLexemeType(get()
                            .type) ~ "`");
            }
        }

        //Global variable definitions
        reset();
        beginGlobalScope();
        while (!isEnd()) {
            GrLexeme lex = get();
            isPublic = false;
            if (lex.type == GrLexemeType.public_) {
                isPublic = true;
                checkAdvance();
                lex = get();
            }
            switch (lex.type) with (GrLexemeType) {
            case semicolon:
                checkAdvance();
                break;
            case event_:
            case enum_:
            case class_:
            case main_:
                skipDeclaration();
                break;
            case template_:
                parseTemplateDeclaration(isPublic);
                break;
            case taskType:
                if (get(1).type != GrLexemeType.identifier && get(1).type != GrLexemeType.lesser)
                    goto case intType;
                skipDeclaration();
                break;
            case functionType:
                if (get(1).type != GrLexemeType.identifier && get(1)
                        .type != GrLexemeType.as && get(1).type != GrLexemeType.lesser)
                    goto case intType;
                skipDeclaration();
                break;
            case intType: .. case chanType:
            case autoType:
                parseGlobalDeclaration(isPublic);
                break;
            case identifier:
                if (_data.isTypeDeclared(get().svalue, get().fileId, false)) {
                    parseGlobalDeclaration(isPublic);
                    break;
                }
                goto default;
            case type_:
                skipExpression();
                break;
            default:
                logError("a global declaration is expected",
                        "a global declaration is expected, found `" ~ grGetPrettyLexemeType(get()
                            .type) ~ "`");
            }
        }
        endGlobalScope();

        while (functionsQueue.length) {
            GrFunction func = functionsQueue[$ - 1];
            functionsQueue.length--;
            parseFunction(func);
        }
    }

    /**
    Parse the body of global functions
    */
    void parseFunction(GrFunction func) {
        if (func.isEvent) {
            func.index = cast(uint) events.length;
            events ~= func;
        }
        else {
            func.index = cast(uint) functions.length;
            functions ~= func;
        }

        functionStack ~= currentFunction;
        currentFunction = func;

        for (int i; i < func.templateVariables.length; ++i) {
            _data.addTemplateAlias(func.templateVariables[i],
                    func.templateSignature[i], func.fileId, func.isPublic);
        }

        openDeferrableSection();
        current = func.lexPosition;
        parseBlock();
        if (func.isTask || func.isMain || func.isEvent) {
            if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.kill_)
                addKill();
        }
        else {
            if (!currentFunction.outSignature.length) {
                if (!currentFunction.instructions.length
                        || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    addReturn();
            }
            else {
                if (!currentFunction.instructions.length
                        || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    logError("the function is missing a return at the end of the scope",
                            "missing `return`");
            }
        }
        closeDeferrableSection();
        registerDeferBlocks();

        endFunction();
        _data.clearTemplateAliases();
    }

    /**
    Declare a new alias of a type.
    */
    private void parseTypeAliasDeclaration(bool isPublic) {
        const uint fileId = get().fileId;
        checkAdvance();
        if (get().type != GrLexemeType.identifier)
            logError("expected type alias name, found `" ~ grGetPrettyLexemeType(get()
                    .type) ~ "`", "missing identifier");
        const string typeAliasName = get().svalue;
        checkAdvance();
        if (get().type != GrLexemeType.assign)
            logError("missing assignment in `type`",
                    "expected `=`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        checkAdvance();
        GrType type = parseType(true);
        if (get().type != GrLexemeType.semicolon)
            logError("missing semicolon after `type`",
                    "expected `;`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");

        if (_data.isTypeDeclared(typeAliasName, fileId, isPublic))
            logError("the name `" ~ typeAliasName ~ "` is defined multiple times",
                    "`" ~ typeAliasName ~ "` is already declared");
        _data.addTypeAlias(typeAliasName, type, fileId, isPublic);
    }

    private void parseEnumDeclaration(bool isPublic) {
        const uint fileId = get().fileId;
        checkAdvance();
        if (get().type != GrLexemeType.identifier)
            logError("expected enum name, found `" ~ grGetPrettyLexemeType(get()
                    .type) ~ "`", "missing identifier");
        const string enumName = get().svalue;
        checkAdvance();
        if (get().type != GrLexemeType.leftCurlyBrace)
            logError("the enum definition does not have a body",
                    "expected `{`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        checkAdvance();

        string[] fields;
        while (!isEnd()) {
            if (get().type == GrLexemeType.rightCurlyBrace) {
                checkAdvance();
                break;
            }
            if (get().type != GrLexemeType.identifier)
                logError("expected enum field, found `" ~ grGetPrettyLexemeType(get()
                        .type) ~ "`", "missing identifier");

            auto fieldName = get().svalue;
            checkAdvance();
            fields ~= fieldName;

            if (get().type != GrLexemeType.semicolon)
                logError("missing semicolon after type enum field",
                        "expected `;`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            checkAdvance();
        }
        if (_data.isTypeDeclared(enumName, fileId, isPublic))
            logError("the name `" ~ enumName ~ "` is defined multiple times",
                    "`" ~ enumName ~ "` is already declared");
        _data.addEnum(enumName, fields, fileId, isPublic);
    }

    private void registerClassDeclaration(bool isPublic) {
        checkAdvance();
        string[] templateVariables = parseTemplateVariables();
        const uint fileId = get().fileId;
        const uint declPosition = current;
        if (get().type != GrLexemeType.identifier)
            logError("expected class name, found `" ~ grGetPrettyLexemeType(get()
                    .type) ~ "`", "missing identifier");
        const string className = get().svalue;
        if (_data.isTypeDeclared(className, fileId, isPublic))
            logError("the name `" ~ className ~ "` is defined multiple times",
                    "`" ~ className ~ "` is already declared");
        _data.registerClass(className, fileId, isPublic, templateVariables, declPosition);
        skipDeclaration();
    }

    private GrClassDefinition getClass(string mangledType, uint fileId) {
        GrClassDefinition class_ = _data.getClass(mangledType, fileId);
        if (!class_)
            return null;
        parseClassDeclaration(class_);
        return class_;
    }

    private void parseClassDeclaration(GrClassDefinition class_) {
        if (class_.isParsed)
            return;
        class_.isParsed = true;
        uint tempPos = current;
        current = class_.position;

        for (int i; i < class_.templateVariables.length; ++i) {
            _data.addTemplateAlias(class_.templateVariables[i],
                    class_.templateTypes[i], class_.fileId, class_.isPublic);
        }

        uint[] fieldPositions;
        if (get().type != GrLexemeType.identifier)
            logError("expected class name, found `" ~ grGetPrettyLexemeType(get()
                    .type) ~ "`", "missing identifier");
        const string className = get().svalue;
        string parentClassName;
        checkAdvance();

        //Inheritance
        if (get().type == GrLexemeType.colon) {
            checkAdvance();
            if (get().type != GrLexemeType.identifier)
                logError("the parent class name is missing",
                        "expected class name, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            parentClassName = get().svalue;
            checkAdvance();
            parentClassName = grMangleComposite(parentClassName, parseTemplateSignature());
        }
        if (get().type != GrLexemeType.leftCurlyBrace)
            logError("the class does not have a body",
                    "expected `{`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        checkAdvance();

        string[] fields;
        GrType[] signature;
        bool[] fieldScopes;
        while (!isEnd()) {
            if (get().type == GrLexemeType.rightCurlyBrace) {
                checkAdvance();
                break;
            }

            bool isFieldPublic = false;
            if (get().type == GrLexemeType.public_) {
                isFieldPublic = true;
                checkAdvance();
            }

            GrType fieldType = parseType();
            do {
                if (get().type == GrLexemeType.comma)
                    checkAdvance();

                const string fieldName = get().svalue;
                signature ~= fieldType;
                fields ~= fieldName;
                fieldScopes ~= isFieldPublic;
                fieldPositions ~= current;
                checkAdvance();
            }
            while (get().type == GrLexemeType.comma);

            if (get().type != GrLexemeType.semicolon)
                logError("missing semicolon after class field declaration",
                        "expected `;`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            checkAdvance();

            if (get().type == GrLexemeType.rightCurlyBrace) {
                checkAdvance();
                break;
            }
        }

        class_.parent = parentClassName;
        class_.signature = signature;
        class_.fields = fields;

        class_.fieldsInfo.length = fields.length;
        for (int i; i < class_.fieldsInfo.length; ++i) {
            class_.fieldsInfo[i].fileId = class_.fileId;
            class_.fieldsInfo[i].isPublic = fieldScopes[i];
            class_.fieldsInfo[i].position = fieldPositions[i];
        }
        current = tempPos;
        _data.clearTemplateAliases();
        resolveClassInheritence(class_);
    }

    /// Fetch fields and signature of parent classes
    private void resolveClassInheritence(GrClassDefinition class_) {
        uint fileId = class_.fileId;
        string parent = class_.parent;
        GrClassDefinition lastClass = class_;
        string[] usedClasses = [class_.name];

        while (parent.length) {
            GrClassDefinition parentClass = getClass(parent, fileId);
            if (!parentClass) {
                set(lastClass.position + 2u);
                logError("`" ~ grGetPrettyType(grGetClassType(class_.name)) ~ "` can't inherit from `" ~ parent ~ "`",
                        "unknown class");
            }
            for (int i; i < usedClasses.length; ++i) {
                if (parent == usedClasses[i]) {
                    set(lastClass.position + 2u);
                    logError("`" ~ grGetPrettyType(grGetClassType(parent)) ~ "` is included recursively",
                            "recursive inheritence");
                }
            }
            usedClasses ~= parent;
            class_.fields = parentClass.fields ~ class_.fields;
            class_.signature = parentClass.signature ~ class_.signature;
            class_.fieldsInfo = parentClass.fieldsInfo ~ class_.fieldsInfo;
            fileId = parentClass.fileId;
            parent = parentClass.parent;
            lastClass = parentClass;
        }
        for (int i; i < class_.signature.length; ++i) {
            for (int y; y < class_.fields.length; ++y) {
                if (i != y && class_.fields[i] == class_.fields[y]) {
                    int first;
                    int second;
                    if (class_.fieldsInfo[i].position < class_.fieldsInfo[y].position) {
                        first = i;
                        second = y;
                    }
                    else {
                        first = y;
                        second = i;
                    }
                    set(class_.fieldsInfo[second].position);
                    logError("the field `" ~ class_.fields[second] ~ "` is declared multiple times",
                            "`" ~ class_.fields[second] ~ "` is redefined here",
                            "", 0, "previous definition of `" ~ class_.fields[first] ~ "`",
                            class_.fieldsInfo[first].position);
                }
            }
            if (class_.signature[i].baseType != GrBaseType.class_) {
                for (int y; y < usedClasses.length; ++y) {
                    if (class_.signature[i].mangledType == usedClasses[y]) {
                        set(class_.fieldsInfo[i].position);
                        logError("`" ~ class_.signature[i].mangledType ~ "` is included recursively",
                                "recursive declaration");
                    }
                }
            }
        }
    }

    private void skipDeclaration() {
        checkAdvance();
        while (!isEnd()) {
            if (get().type != GrLexemeType.leftCurlyBrace) {
                checkAdvance();
            }
            else {
                skipBlock();
                return;
            }
        }
    }

    private void skipExpression() {
        checkAdvance();
        while (!isEnd()) {
            switch (get().type) with (GrLexemeType) {
            case semicolon:
                checkAdvance();
                return;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                checkAdvance();
                break;
            }
        }
    }

    private GrType parseType(bool mustBeType = true) {
        GrType currentType = GrBaseType.void_;

        GrLexeme lex = get();
        if (!lex.isType) {
            if (lex.type == GrLexemeType.identifier
                    && _data.isTypeAlias(lex.svalue, lex.fileId, false)) {
                currentType = _data.getTypeAlias(lex.svalue, lex.fileId).type;
                checkAdvance();
                return currentType;
            }
            else if (lex.type == GrLexemeType.identifier
                    && _data.isClass(lex.svalue, lex.fileId, false)) {
                currentType.baseType = GrBaseType.class_;
                checkAdvance();
                currentType.mangledType = grMangleComposite(lex.svalue, parseTemplateSignature());
                if (mustBeType) {
                    GrClassDefinition class_ = getClass(currentType.mangledType, lex.fileId);
                    if (!class_)
                        logError("`" ~ grGetPrettyType(currentType) ~ "` is not declared",
                                "unknown class", "", -1);
                }
                return currentType;
            }
            else if (lex.type == GrLexemeType.identifier
                    && _data.isEnum(lex.svalue, lex.fileId, false)) {
                currentType.baseType = GrBaseType.enum_;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                return currentType;
            }
            else if (lex.type == GrLexemeType.identifier && _data.isForeign(lex.svalue)) {
                currentType.baseType = GrBaseType.foreign;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                currentType.mangledType = grMangleComposite(lex.svalue, parseTemplateSignature());
                return currentType;
            }
            else if (mustBeType) {
                const string typeName = lex.type == GrLexemeType.identifier
                    ? lex.svalue : grGetPrettyLexemeType(lex.type);
                logError("`" ~ typeName ~ "` is not a valid type",
                        "expected a valid type, found `" ~ typeName ~ "`");
            }
            else {
                return currentType;
            }
        }

        switch (lex.type) with (GrLexemeType) {
        case intType:
            currentType.baseType = GrBaseType.int_;
            checkAdvance();
            break;
        case floatType:
            currentType.baseType = GrBaseType.float_;
            checkAdvance();
            break;
        case boolType:
            currentType.baseType = GrBaseType.bool_;
            checkAdvance();
            break;
        case stringType:
            currentType.baseType = GrBaseType.string_;
            checkAdvance();
            break;
        case arrayType:
            currentType.baseType = GrBaseType.array_;
            checkAdvance();
            string[] temp;
            auto signature = parseInSignature(temp, true);
            if (signature.length > 1)
                logError("an array can only contain one type of value", "conflicting array signature",
                        "try using `" ~ grGetPrettyType(grArray(signature[0])) ~ "` instead", -1);
            currentType.mangledType = grMangleSignature(signature);
            break;
        case functionType:
            currentType.baseType = GrBaseType.function_;
            checkAdvance();
            string[] temp;
            currentType.mangledType = grMangleSignature(parseInSignature(temp, true));
            currentType.mangledReturnType = grMangleSignature(parseOutSignature());
            break;
        case taskType:
            currentType.baseType = GrBaseType.task;
            checkAdvance();
            string[] temp;
            currentType.mangledType = grMangleSignature(parseInSignature(temp, true));
            break;
        case chanType:
            currentType.baseType = GrBaseType.chan;
            checkAdvance();
            string[] temp;
            GrType[] signature = parseInSignature(temp, true);
            if (signature.length != 1)
                logError("a channel can only contain one type of value", "conflicting channel signature",
                        "try using `" ~ grGetPrettyType(grChannel(signature[0])) ~ "` instead", -1);
            currentType.mangledType = grMangleSignature(signature);
            break;
        default:
            logError("`" ~ grGetPrettyLexemeType(lex.type) ~ "` is not a valid type",
                    "invalid type");
        }

        return currentType;
    }

    private void addGlobalPop(GrType type) {
        final switch (type.baseType) with (GrBaseType) {
        case internalTuple:
        case null_:
        case void_:
            logError("`" ~ grGetPrettyType(type) ~ "` is not a valid type", "invalid type");
            break;
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.globalPop_int, 0u);
            break;
        case float_:
            addInstruction(GrOpcode.globalPop_float, 0u);
            break;
        case string_:
            addInstruction(GrOpcode.globalPop_string, 0u);
            break;
        case class_:
        case array_:
        case foreign:
        case chan:
        case reference:
            addInstruction(GrOpcode.globalPop_object, 0u);
            break;
        }
    }

    private void addGlobalPush(GrType type, int nbPush = 1u) {
        if (nbPush == 0)
            return;
        final switch (type.baseType) with (GrBaseType) {
        case internalTuple:
        case null_:
        case void_:
            logError("`" ~ grGetPrettyType(type) ~ "` is not a valid type", "invalid type");
            break;
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.globalPush_int, nbPush);
            break;
        case float_:
            addInstruction(GrOpcode.globalPush_float, nbPush);
            break;
        case string_:
            addInstruction(GrOpcode.globalPush_string, nbPush);
            break;
        case class_:
        case array_:
        case foreign:
        case chan:
        case reference:
            addInstruction(GrOpcode.globalPush_object, nbPush);
            break;
        }
    }

    private void addGlobalPush(GrType[] signature) {
        struct TypeCounter {
            uint nbIntParams, nbFloatParams, nbStringParams, nbObjectParams;
        }

        void countParameters(ref TypeCounter typeCounter, GrType type) {
            final switch (type.baseType) with (GrBaseType) {
            case internalTuple:
            case null_:
            case void_:
                logError("`" ~ grGetPrettyType(type) ~ "` is not a valid type", "invalid type");
                break;
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                typeCounter.nbIntParams++;
                break;
            case float_:
                typeCounter.nbFloatParams++;
                break;
            case string_:
                typeCounter.nbStringParams++;
                break;
            case class_:
            case array_:
            case foreign:
            case chan:
            case reference:
                typeCounter.nbObjectParams++;
                break;
            }
        }

        TypeCounter typeCounter;
        foreach (type; signature) {
            countParameters(typeCounter, type);
        }

        if (typeCounter.nbIntParams > 0)
            addInstruction(GrOpcode.globalPush_int, typeCounter.nbIntParams);
        if (typeCounter.nbFloatParams > 0)
            addInstruction(GrOpcode.globalPush_float, typeCounter.nbFloatParams);
        if (typeCounter.nbStringParams > 0)
            addInstruction(GrOpcode.globalPush_string, typeCounter.nbStringParams);
        if (typeCounter.nbObjectParams > 0)
            addInstruction(GrOpcode.globalPush_object, typeCounter.nbObjectParams);
    }

    private string[] parseTemplateVariables() {
        string[] variables;
        if (get().type != GrLexemeType.lesser)
            return variables;
        checkAdvance();
        if (get().type == GrLexemeType.greater) {
            checkAdvance();
            return variables;
        }
        for (;;) {
            if (get().type != GrLexemeType.identifier)
                logError("an identifier is expected", "missing template value");
            variables ~= get().svalue;
            checkAdvance();

            const GrLexeme lex = get();
            if (lex.type == GrLexemeType.greater) {
                checkAdvance();
                break;
            }
            else if (lex.type != GrLexemeType.comma)
                logError("template values should be separated by a comma",
                        "expected `,`, found `" ~ grGetPrettyLexemeType(lex.type) ~ "`");
            checkAdvance();
        }
        return variables;
    }

    private GrType[] parseTemplateSignature() {
        GrType[] signature;
        if (get().type != GrLexemeType.lesser)
            return signature;
        checkAdvance();
        if (get().type == GrLexemeType.greater) {
            checkAdvance();
            return signature;
        }
        for (;;) {
            signature ~= parseType();

            const GrLexeme lex = get();
            if (lex.type == GrLexemeType.greater) {
                checkAdvance();
                break;
            }
            else if (lex.type != GrLexemeType.comma)
                logError("template types should be separated by a comma",
                        "expected `,`, found `" ~ grGetPrettyLexemeType(lex.type) ~ "`");
            checkAdvance();
        }
        return signature;
    }

    private GrType[] parseInSignature(ref string[] inputVariables, bool asType = false) {
        GrType[] inSignature;

        if (get().type != GrLexemeType.leftParenthesis)
            logError("missing parentheses",
                    "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");

        bool startLoop = true;
        for (;;) {
            checkAdvance();
            GrLexeme lex = get();

            if (startLoop && lex.type == GrLexemeType.rightParenthesis)
                break;
            startLoop = false;

            inSignature ~= parseType();

            //If we want to know whether it's a type or an anon, we can't throw exceptions.
            if (isTypeChecking) {
                lex = get();
                if (get().type == GrLexemeType.identifier) {
                    inputVariables ~= lex.svalue;
                    checkAdvance();
                    lex = get();
                }

                if (lex.type == GrLexemeType.rightParenthesis)
                    break;
                else if (lex.type != GrLexemeType.comma)
                    logError("parameters should be separated by a comma",
                            "expected `,`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            }
            else {
                //Is it a function type or a function declaration ?
                if (!asType) {
                    lex = get();
                    if (get().type != GrLexemeType.identifier)
                        logError("expected identifier, found `" ~ grGetPrettyLexemeType(get()
                                .type) ~ "`", "missing identifier");
                    inputVariables ~= lex.svalue;
                    checkAdvance();
                }

                lex = get();
                if (lex.type == GrLexemeType.rightParenthesis)
                    break;
                else if (lex.type != GrLexemeType.comma)
                    logError("parameters should be separated by a comma",
                            "expected `,`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            }
        }
        checkAdvance();

        return inSignature;
    }

    private GrType[] parseOutSignature() {
        GrType[] outSignature;
        if (get().type != GrLexemeType.leftParenthesis)
            return outSignature;
        checkAdvance();
        if (get().type == GrLexemeType.rightParenthesis) {
            checkAdvance();
            return outSignature;
        }
        for (;;) {
            outSignature ~= parseType();

            const GrLexeme lex = get();
            if (lex.type == GrLexemeType.rightParenthesis) {
                checkAdvance();
                break;
            }
            else if (lex.type != GrLexemeType.comma)
                logError("types should be separated by a comma",
                        "expected `,`, found `" ~ grGetPrettyLexemeType(lex.type) ~ "`");
            checkAdvance();
        }
        return outSignature;
    }

    private void parseMainDeclaration(bool isPublic) {
        if (isPublic)
            logError("adding `pub` before `main` is redundant", "main is already public");
        checkAdvance();
        preBeginFunction("main", get().fileId, [], [], false, [], false, false, true);
        skipBlock();
        preEndFunction();
    }

    private void parseEventDeclaration(bool isPublic) {
        if (isPublic)
            logError("adding `pub` before `event` is redundant", "event is already public");
        checkAdvance();
        if (get().type != GrLexemeType.identifier)
            logError("expected identifier, found `" ~ grGetPrettyLexemeType(get()
                    .type) ~ "`", "missing identifier");
        string name = get().svalue;
        string[] inputs;
        checkAdvance();
        GrType[] signature = parseInSignature(inputs);
        preBeginFunction(name, get().fileId, signature, inputs, false, [], false, true, true);
        skipBlock();
        preEndFunction();
    }

    private void parseTaskDeclaration(bool isPublic) {
        checkAdvance();
        string[] templateVariables = parseTemplateVariables();
        if (get().type != GrLexemeType.identifier)
            logError("expected identifier, found `" ~ grGetPrettyLexemeType(get()
                    .type) ~ "`", "missing identifier");

        string name = get().svalue;
        checkAdvance();

        GrTemplateFunction temp = new GrTemplateFunction;
        temp.isTask = true;
        temp.name = name;
        temp.templateVariables = templateVariables;
        temp.fileId = get().fileId;
        temp.isPublic = isPublic;
        temp.lexPosition = current;

        if (templateVariables.length)
            templatedFunctions ~= temp;
        else
            instanciatedFunctions ~= parseTemplatedFunctionDeclaration(temp, []);

        if (get().type == GrLexemeType.leftParenthesis)
            skipParenthesis();
        skipBlock();
    }

    private void parseFunctionDeclaration(bool isPublic) {
        checkAdvance();
        string[] templateVariables = parseTemplateVariables();
        string name;
        bool isConversion;
        if (get().type == GrLexemeType.as) {
            name = "@as";
            isConversion = true;
        }
        else {
            if (get().type != GrLexemeType.identifier)
                logError("expected identifier, found `" ~ grGetPrettyLexemeType(get()
                        .type) ~ "`", "missing identifier");
            name = get().svalue;
            if (name == "operator") {
                checkAdvance();
                if (get().type >= GrLexemeType.add && get().type <= GrLexemeType.not) {
                    name = "@op_" ~ grGetPrettyLexemeType(get().type);
                }
                else
                    logError("can't override `" ~ grGetPrettyLexemeType(get()
                            .type) ~ "` operator", "this operator can't be overriden");
            }
        }
        checkAdvance();

        GrTemplateFunction temp = new GrTemplateFunction;
        temp.isTask = false;
        temp.name = name;
        temp.isConversion = isConversion;
        temp.templateVariables = templateVariables;
        temp.fileId = get().fileId;
        temp.isPublic = isPublic;
        temp.lexPosition = current;

        if (templateVariables.length)
            templatedFunctions ~= temp;
        else
            instanciatedFunctions ~= parseTemplatedFunctionDeclaration(temp, []);

        if (get().type == GrLexemeType.leftParenthesis)
            skipParenthesis();
        if (get().type == GrLexemeType.leftParenthesis)
            skipParenthesis();
        skipBlock();
    }

    private void parseTemplateDeclaration(bool isPublic) {
        checkAdvance();
        if (get().type != GrLexemeType.lesser)
            logError("missing template signature",
                    "expected `<`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");

        GrType[] templateList = parseTemplateSignature();

        if (get().type != GrLexemeType.identifier)
            logError("missing function or task",
                    "expected a function or task name, found `" ~ grGetPrettyLexemeType(get()
                        .type) ~ "`");
        string name = get().svalue;

        if (name == "operator") {
            checkAdvance();
            if (get().type >= GrLexemeType.add && get().type <= GrLexemeType.not) {
                name = "@op_" ~ grGetPrettyLexemeType(get().type);
            }
            else
                logError("can't override `" ~ grGetPrettyLexemeType(get()
                        .type) ~ "` operator", "this operator can't be overriden");
        }

        const uint fileId = get().fileId;
        checkAdvance();

        if (!templateList.length)
            logError("empty template signature", "the template signature can't be empty", "", -1);

        if (get().type != GrLexemeType.semicolon)
            logError("missing semicolon after template declaration",
                    "expected `;`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        checkAdvance();

        foreach (GrTemplateFunction temp; templatedFunctions) {
            if (temp.name == name && (temp.fileId == fileId || temp.isPublic)
                    && temp.templateVariables.length == templateList.length) {
                GrFunction func = parseTemplatedFunctionDeclaration(temp, templateList);
                func.isPublic = isPublic;
                instanciatedFunctions ~= func;
            }
        }
    }

    private GrFunction parseTemplatedFunctionDeclaration(GrTemplateFunction temp,
            GrType[] templateList) {
        const auto lastPosition = current;
        current = temp.lexPosition;

        for (int i; i < temp.templateVariables.length; ++i) {
            _data.addTemplateAlias(temp.templateVariables[i], templateList[i],
                    temp.fileId, temp.isPublic);
        }

        string[] inputs;
        GrType[] inSignature = parseInSignature(inputs);
        GrType[] outSignature;

        if (!temp.isTask) {
            //Return Type.
            if (temp.isConversion) {
                if (inSignature.length != 1uL) {
                    const string argStr = to!string(inSignature.length) ~ (inSignature.length > 1
                            ? " parameters" : " parameter");
                    logError("a conversion must have only one parameter",
                            "expected 1 parameter, found " ~ argStr);
                }
                outSignature = parseOutSignature();
                if (outSignature.length != 1uL) {
                    const string argStr = to!string(outSignature.length) ~ (outSignature.length > 1
                            ? " return values" : " return value");
                    logError("a conversion must have only one return value",
                            "expected 1 return value, found " ~ argStr);
                }

                inSignature ~= outSignature[0];
            }
            else
                outSignature = parseOutSignature();
        }

        GrFunction func = new GrFunction;
        func.isTask = temp.isTask;
        func.name = temp.name;
        func.inputVariables = inputs;
        func.inSignature = inSignature;
        func.outSignature = outSignature;
        func.fileId = temp.fileId;
        func.isPublic = temp.isPublic;
        func.lexPosition = current;
        func.templateVariables = temp.templateVariables;
        func.templateSignature = templateList;

        _data.clearTemplateAliases();
        current = lastPosition;
        return func;
    }

    private GrType parseAnonymousFunction(bool isTask) {
        checkAdvance();
        string[] inputs;
        GrType[] outSignature;
        GrType[] inSignature = parseInSignature(inputs);

        if (!isTask) {
            //Return Type.
            outSignature = parseOutSignature();
        }
        preBeginFunction("$anon", get().fileId, inSignature, inputs, isTask, outSignature, true);
        openDeferrableSection();
        parseBlock();

        if (isTask) {
            if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.kill_)
                addKill();
        }
        else {
            if (!outSignature.length) {
                if (!currentFunction.instructions.length
                        || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    addReturn();
            }
            else {
                if (!currentFunction.instructions.length
                        || currentFunction.instructions[$ - 1].opcode != GrOpcode.return_)
                    logError("the function is missing a return at the end of the scope",
                            "missing `return`");
            }
        }

        closeDeferrableSection();
        registerDeferBlocks();

        endFunction();

        GrType functionType = isTask ? GrBaseType.task : GrBaseType.function_;
        functionType.mangledType = grMangleSignature(inSignature);
        functionType.mangledReturnType = grMangleSignature(outSignature);

        return functionType;
    }

    /**
    Parse either multiple lines between `{` and `}` or a single expression.
    */
    private void parseBlock(bool changeOptimizationBlockLevel = false) {
        if (changeOptimizationBlockLevel)
            _isAssignationOptimizable = false;
        bool isMultiline;
        if (get().type == GrLexemeType.leftCurlyBrace) {
            isMultiline = true;
            if (!checkAdvance())
                logError("unexpected end of file",
                        "expected `}`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        }
        openBlock();

        void parseStatement() {
            switch (get().type) with (GrLexemeType) {
            case semicolon:
            case rightCurlyBrace:
                advance();
                break;
            case defer:
                parseDeferStatement();
                break;
            case if_:
            case unless:
                parseIfStatement();
                break;
            case switch_:
                parseSwitchStatement();
                break;
            case select:
                parseSelectStatement();
                break;
            case until:
            case while_:
                parseWhileStatement();
                break;
            case do_:
                parseDoWhileStatement();
                break;
            case for_:
                parseForStatement();
                break;
            case loop:
                parseLoopStatement();
                break;
            case raise_:
                parseRaiseStatement();
                break;
            case try_:
                parseExceptionHandler();
                break;
            case return_:
                parseReturnStatement();
                break;
            case kill:
                parseKill();
                break;
            case killAll:
                parseKillAll();
                break;
            case yield:
                parseYield();
                break;
            case continue_:
                parseContinue();
                break;
            case break_:
                parseBreak();
                break;
            case intType: .. case autoType:
                if (isDeclaration())
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            case identifier:
                if (_data.isTypeDeclared(get().svalue, get().fileId, false))
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            default:
                parseExpression();
                break;
            }
        }

        if (isMultiline) {
            while (!isEnd()) {
                if (get().type == GrLexemeType.rightCurlyBrace)
                    break;
                parseStatement();
            }
        }
        else {
            if (get().type != GrLexemeType.semicolon)
                parseStatement();
        }

        if (isMultiline) {
            if (get().type != GrLexemeType.rightCurlyBrace)
                logError("missing curly braces",
                        "expected `}`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            checkAdvance();
        }
        closeBlock();
        if (changeOptimizationBlockLevel)
            _isAssignationOptimizable = false;
    }

    private bool isDeclaration() {
        const auto tempPos = current;
        isTypeChecking = true;
        if (get().type == GrLexemeType.autoType)
            checkAdvance();
        else
            parseType(false);
        isTypeChecking = false;
        bool isDecl;
        if (get().type == GrLexemeType.identifier)
            isDecl = true;
        current = tempPos;
        return isDecl;
    }

    private void skipBlock() {
        bool isMultiline;
        if (get().type == GrLexemeType.leftCurlyBrace) {
            isMultiline = true;
            if (!checkAdvance())
                logError("unexpected end of file",
                        "expected `}`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        }
        openBlock();

        void skipStatement() {
            switch (get().type) with (GrLexemeType) {
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            case defer:
                checkAdvance();
                skipBlock();
                break;
            case switch_:
                checkAdvance();
                skipParenthesis();
                while (get().type == GrLexemeType.case_) {
                    checkAdvance();
                    if (get().type == GrLexemeType.leftParenthesis)
                        skipParenthesis();
                    skipBlock();
                }
                break;
            case if_:
            case unless:
                checkAdvance();
                skipParenthesis();
                skipBlock();
                break;
            case select:
                checkAdvance();
                while (get().type == GrLexemeType.case_) {
                    checkAdvance();
                    if (get().type == GrLexemeType.leftParenthesis)
                        skipParenthesis();
                    skipBlock();
                }
                break;
            case until:
            case while_:
                checkAdvance();
                skipBlock();
                break;
            case do_:
                checkAdvance();
                skipBlock();
                checkAdvance();
                skipParenthesis();
                break;
            case for_:
                checkAdvance();
                skipParenthesis();
                skipBlock();
                break;
            case loop:
                checkAdvance();
                if (get().type == GrLexemeType.leftParenthesis)
                    skipParenthesis();
                skipBlock();
                break;
            case raise_:
                checkAdvance();
                skipBlock();
                break;
            case try_:
                checkAdvance();
                skipBlock();
                if (get().type == GrLexemeType.catch_) {
                    checkAdvance();
                    skipParenthesis();
                    skipBlock();
                }
                break;
            case yield:
                checkAdvance();
                break;
            case return_:
                checkAdvance();
                skipBlock();
                break;
            default:
                checkAdvance();
                break;
            }
        }

        if (isMultiline) {
            while (!isEnd()) {
                if (get().type == GrLexemeType.rightCurlyBrace)
                    break;
                switch (get().type) with (GrLexemeType) {
                case leftParenthesis:
                    skipParenthesis();
                    break;
                case leftBracket:
                    skipBrackets();
                    break;
                case leftCurlyBrace:
                    skipBlock();
                    break;
                default:
                    checkAdvance();
                    break;
                }
            }

            if (get().type != GrLexemeType.rightCurlyBrace)
                logError("missing curly braces",
                        "expected `}`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            checkAdvance();
        }
        else {
            if (get().type != GrLexemeType.semicolon)
                skipStatement();
        }
        closeBlock();
    }

    private void parseKill() {
        if (!currentFunction.instructions.length
                || currentFunction.instructions[$ - 1].opcode != GrOpcode.kill_)
            addKill();
        advance();
    }

    private void parseKillAll() {
        if (!currentFunction.instructions.length
                || currentFunction.instructions[$ - 1].opcode != GrOpcode.killAll_)
            addKillAll();
        advance();
    }

    private void parseYield() {
        addInstruction(GrOpcode.yield, 0u);
        advance();
    }

    //Exception handling
    private void parseRaiseStatement() {
        advance();
        GrType type = parseSubExpression(GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_EXPECTING_VALUE)
            .type;
        checkAdvance();
        convertType(type, grString);
        addInstruction(GrOpcode.raise_);
        checkDeferStatement();
    }

    private void parseExceptionHandler() {
        advance();

        const auto tryPosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.try_);

        parseBlock();

        const uint fileId = get().fileId;
        if (get().type != GrLexemeType.catch_)
            logError("a `try` must always be followed by a `catch`",
                    "expected `catch`, fount `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        advance();

        if (get().type != GrLexemeType.leftParenthesis)
            logError("missing parentheses after `catch`",
                    "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        advance();

        if (get().type != GrLexemeType.identifier)
            logError("missing identifier",
                    "expected `identifier`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        GrVariable errVariable = registerLocalVariable(get().svalue, grString);

        advance();
        if (get().type != GrLexemeType.rightParenthesis)
            logError("missing parentheses",
                    "expected `)`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        advance();

        const auto catchPosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.catch_);

        addInstruction(GrOpcode.globalPop_string);
        addSetInstruction(errVariable, fileId, grString);

        parseBlock(true);

        const auto endPosition = currentFunction.instructions.length;

        setInstruction(GrOpcode.try_, cast(uint) tryPosition,
                cast(uint)(catchPosition - tryPosition), true);
        setInstruction(GrOpcode.catch_, cast(uint) catchPosition,
                cast(uint)(endPosition - catchPosition), true);
    }

    //defer
    private void openDeferrableSection() {
        auto deferrableSection = new GrDeferrableSection;
        deferrableSection.deferInitPositions = cast(uint) currentFunction.instructions.length;
        currentFunction.deferrableSections ~= deferrableSection;

        currentFunction.isDeferrableSectionLocked.length++;
    }

    private void closeDeferrableSection() {
        if (!currentFunction.deferrableSections.length)
            throw new Exception("attempting to close a non-existing function");

        foreach (deferBlock; currentFunction.deferrableSections[$ - 1].deferredBlocks) {
            currentFunction.registeredDeferBlocks ~= deferBlock;
        }

        currentFunction.deferrableSections.length--;
        currentFunction.isDeferrableSectionLocked.length--;
    }

    private void parseDeferStatement() {
        if (currentFunction.isDeferrableSectionLocked[$ - 1])
            logError("`defer` inside another `defer`", "can't `defer` inside another `defer`");
        advance();

        //Register the position of the block for a late parsing.
        GrDeferBlock deferBlock = new GrDeferBlock;
        deferBlock.position = cast(uint) currentFunction.instructions.length;
        deferBlock.parsePosition = current;
        deferBlock.scopeLevel = scopeLevel;
        currentFunction.deferrableSections[$ - 1].deferredBlocks ~= deferBlock;

        addInstruction(GrOpcode.defer);

        //Parse the deferred block at the end of the outer block.
        skipBlock();
    }

    private void checkDeferStatement() {
        if (currentFunction.isDeferrableSectionLocked[$ - 1]) {
            GrLexemeType type = get().type;
            logError("`" ~ grGetPrettyLexemeType(type) ~ "` inside a defer",
                    "can't `" ~ grGetPrettyLexemeType(type) ~ "` inside a defer");
        }
    }

    private void registerDeferBlocks() {
        const auto tempParsePosition = current;
        const auto startDeferPos = cast(uint) currentFunction.instructions.length;

        const int tempScopeLevel = scopeLevel;
        while (currentFunction.registeredDeferBlocks.length) {
            GrDeferBlock deferBlock = currentFunction.registeredDeferBlocks[0];
            currentFunction.registeredDeferBlocks = currentFunction.registeredDeferBlocks[1 .. $];

            setInstruction(GrOpcode.defer, deferBlock.position,
                    cast(int)(currentFunction.instructions.length - deferBlock.position), true);
            current = deferBlock.parsePosition;
            scopeLevel = deferBlock.scopeLevel;

            currentFunction.isDeferrableSectionLocked[$ - 1] = true;
            parseBlock(true);
            currentFunction.isDeferrableSectionLocked[$ - 1] = false;

            addInstruction(GrOpcode.unwind);
        }
        currentFunction.registeredDeferBlocks.length = 0;
        current = tempParsePosition;
        scopeLevel = tempScopeLevel;
    }

    //Break
    private void openBreakableSection() {
        breaksJumps ~= [null];
        _isAssignationOptimizable = false;
    }

    private void closeBreakableSection() {
        if (!breaksJumps.length)
            throw new Exception("attempting to close a non-existing function");

        uint[] breaks = breaksJumps[$ - 1];
        breaksJumps.length--;

        foreach (position; breaks)
            setInstruction(GrOpcode.jump, position,
                    cast(int)(currentFunction.instructions.length - position), true);
        _isAssignationOptimizable = false;
    }

    private void parseBreak() {
        if (!breaksJumps.length)
            logError("`break` outside of a loop", "can't `break` outside of a loop");

        breaksJumps[$ - 1] ~= cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.jump);
        advance();
    }

    //Continue
    private void openContinuableSection() {
        continuesJumps.length++;
        _isAssignationOptimizable = false;
    }

    private void closeContinuableSection() {
        if (!continuesJumps.length)
            throw new Exception("attempting to close a non-existing function");

        uint[] continues = continuesJumps[$ - 1];
        const uint destination = continuesDestinations[$ - 1];
        continuesJumps.length--;
        continuesDestinations.length--;

        foreach (position; continues)
            setInstruction(GrOpcode.jump, position, cast(int)(destination - position), true);
        _isAssignationOptimizable = false;
    }

    private void setContinuableSectionDestination() {
        continuesDestinations ~= cast(uint) currentFunction.instructions.length;
    }

    private void parseContinue() {
        if (!continuesJumps.length)
            logError("`continue` outside of a loop", "can't `continue` outside of a loop");

        continuesJumps[$ - 1] ~= cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.jump);
        advance();
    }

    private void parseGlobalDeclaration(bool isPublic) {
        //GrVariable type
        GrType type = GrBaseType.void_;
        bool isAuto;

        if (get().type == GrLexemeType.autoType) {
            isAuto = true;
            checkAdvance();
        }
        else
            type = parseType();

        GrVariable[] lvalues;
        do {
            if (get().type == GrLexemeType.comma)
                checkAdvance();
            //Identifier
            if (get().type != GrLexemeType.identifier)
                logError("expected identifier, found `" ~ grGetPrettyLexemeType(get()
                        .type) ~ "`", "missing identifier");

            string identifier = get().svalue;

            //Registering
            GrVariable lvalue = registerGlobalVariable(identifier, type, isAuto, isPublic);
            lvalues ~= lvalue;

            checkAdvance();
        }
        while (get().type == GrLexemeType.comma);

        parseAssignList(lvalues, true);
    }

    //Type Identifier [= EXPRESSION] ;
    private void parseLocalDeclaration() {
        //GrVariable type
        GrType type = GrBaseType.void_;
        bool isAuto;
        if (get().type == GrLexemeType.autoType) {
            isAuto = true;
            checkAdvance();
        }
        else
            type = parseType();

        GrVariable[] lvalues;
        do {
            if (get().type == GrLexemeType.comma)
                checkAdvance();
            //Identifier
            if (get().type != GrLexemeType.identifier)
                logError("expected identifier, found `" ~ grGetPrettyLexemeType(get()
                        .type) ~ "`", "missing identifier");

            string identifier = get().svalue;

            //Registering
            GrVariable lvalue = registerLocalVariable(identifier, type);
            lvalue.isAuto = isAuto;
            lvalues ~= lvalue;

            //A composite type does not need to be initialized.
            if (lvalue.type == GrBaseType.class_)
                lvalue.isInitialized = true;

            checkAdvance();
        }
        while (get().type == GrLexemeType.comma);

        parseAssignList(lvalues, true);
    }

    private GrType parseFunctionReturnType() {
        GrType returnType = GrBaseType.void_;
        if (get().isType) {
            switch (get().type) with (GrLexemeType) {
            case intType:
                returnType = GrType(GrBaseType.int_);
                break;
            case floatType:
                returnType = GrType(GrBaseType.float_);
                break;
            case boolType:
                returnType = GrType(GrBaseType.bool_);
                break;
            case stringType:
                returnType = GrType(GrBaseType.string_);
                break;
            case arrayType:
                returnType = GrType(GrBaseType.array_);
                break;
            case functionType:
                GrType type = GrBaseType.function_;
                checkAdvance();
                string[] temp;
                type.mangledType = grMangleSignature(parseInSignature(temp, true));
                returnType = type;
                break;
            case taskType:
                GrType type = GrBaseType.task;
                checkAdvance();
                string[] temp;
                type.mangledType = grMangleSignature(parseInSignature(temp, true));
                returnType = type;
                break;
            default:
                logError("`" ~ grGetPrettyLexemeType(get().type) ~ "` is not a valid return type",
                        "`" ~ grGetPrettyLexemeType(get().type) ~ "` is not a valid return type");
            }
            checkAdvance();
        }

        return returnType;
    }

    /**
    ---
    if(SUBEXPR) BLOCK
    else if(SUBEXPR) BLOCK
    else unless(SUBEXPR) BLOCK
    else(SUBEXPR) BLOCK
    ---
    */
    private void parseIfStatement() {
        bool isNegative = get().type == GrLexemeType.unless;
        advance();
        if (get().type != GrLexemeType.leftParenthesis)
            logError("missing parentheses after `if`",
                    "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");

        advance();
        GrSubExprResult result = parseSubExpression();
        convertType(result.type, grBool, get().fileId);
        advance();

        uint jumpPosition = cast(uint) currentFunction.instructions.length;
        //Jumps to if(0) for "if", if(!= 0) for "unless".
        addInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual);

        parseBlock(true); //{ .. }

        //If(1){}, jumps out.
        uint[] exitJumps;
        if (get().type == GrLexemeType.else_) {
            exitJumps ~= cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.jump);
        }

        //Jumps to if(0) for "if", if(!= 0) for "unless".
        setInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual, jumpPosition,
                cast(int)(currentFunction.instructions.length - jumpPosition), true);

        bool isElseIf;
        do {
            isElseIf = false;
            if (get().type == GrLexemeType.else_) {
                checkAdvance();
                if (get().type == GrLexemeType.if_ || get().type == GrLexemeType.unless) {
                    isNegative = get().type == GrLexemeType.unless;
                    isElseIf = true;
                    checkAdvance();
                    if (get().type != GrLexemeType.leftParenthesis)
                        logError("missing parentheses after `if`",
                                "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
                    checkAdvance();

                    parseSubExpression();
                    advance();

                    jumpPosition = cast(uint) currentFunction.instructions.length;
                    //Jumps to if(0) for "if", if(!= 0) for "unless".
                    addInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual);

                    parseBlock(true); //{ .. }

                    //If(1){}, jumps out.
                    exitJumps ~= cast(uint) currentFunction.instructions.length;
                    addInstruction(GrOpcode.jump);

                    //Jumps to if(0) for "if", if(!= 0) for "unless".
                    setInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual, jumpPosition,
                            cast(int)(currentFunction.instructions.length - jumpPosition), true);
                }
                else
                    parseBlock(true);
            }
        }
        while (isElseIf);

        foreach (uint position; exitJumps)
            setInstruction(GrOpcode.jump, position,
                    cast(int)(currentFunction.instructions.length - position), true);
    }

    private GrType parseChannelBuilder() {
        GrType chanType = GrBaseType.chan;
        int channelSize = 1;

        checkAdvance();
        if (get().type != GrLexemeType.leftParenthesis)
            logError("missing parentheses after `chan`",
                    "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        checkAdvance();
        GrType subType = parseType();

        GrLexeme lex = get();
        if (lex.type == GrLexemeType.comma) {
            checkAdvance();
            lex = get();
            if (lex.type != GrLexemeType.integer)
                logError("a channel size must be a positive int value",
                        "expected `int`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            channelSize = lex.ivalue;
            if (channelSize < 1)
                logError("the channel size must be one or higher",
                        "expected at least a size of 1, found " ~ to!string(channelSize));
            checkAdvance();
        }
        else if (lex.type != GrLexemeType.rightParenthesis) {
            logError("missing `,` or `)` inside channel signature",
                    "expected `,` or `)`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        }
        lex = get();
        if (lex.type != GrLexemeType.rightParenthesis)
            logError("missing parentheses after the channel signature",
                    "expected `)`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        checkAdvance();
        chanType.mangledType = grMangleSignature([subType]);

        final switch (subType.baseType) with (GrBaseType) {
        case int_:
        case bool_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.channel_int, channelSize);
            break;
        case float_:
            addInstruction(GrOpcode.channel_float, channelSize);
            break;
        case string_:
            addInstruction(GrOpcode.channel_string, channelSize);
            break;
        case class_:
        case array_:
        case foreign:
        case chan:
        case reference:
            addInstruction(GrOpcode.channel_object, channelSize);
            break;
        case void_:
        case null_:
        case internalTuple:
            logError("a channel can't be of type `" ~ grGetPrettyType(grChannel(subType)) ~ "`",
                    "invalid channel type");
        }
        return chanType;
    }

    /**
    ---
    switch(SUBEXPR)
    case(SUBEXPR) BLOCK
    case(SUBEXPR) BLOCK
    case() BLOCK
    ---
    */
    private void parseSwitchStatement() {
        advance();
        if (get().type != GrLexemeType.leftParenthesis)
            logError("missing parentheses after `switch`",
                    "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");

        advance();
        const uint fileId = get().fileId;
        GrType switchType = parseSubExpression().type;
        GrVariable switchVar = registerSpecialVariable("switch" ~ to!string(scopeLevel), switchType);
        addSetInstruction(switchVar, fileId);
        advance();

        /* A switch is breakable. */
        openBreakableSection();
        uint[] exitJumps;
        uint jumpPosition, casePosition, defaultCasePosition, defaultCaseKeywordPosition;
        bool hasCase, hasDefaultCase;

        while (get().type == GrLexemeType.case_) {
            casePosition = current;
            advance();
            if (get().type != GrLexemeType.leftParenthesis)
                logError("missing parentheses after `case`",
                        "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            advance();
            if (get().type == GrLexemeType.rightParenthesis) {
                if (hasDefaultCase)
                    logError("there must be only up to one default case per `switch`",
                            "default `case` already defined", "",
                            casePosition - current, "previous default `case` definition",
                            defaultCaseKeywordPosition);
                advance();
                hasDefaultCase = true;
                defaultCasePosition = current;
                defaultCaseKeywordPosition = casePosition;
                skipBlock();
            }
            else {
                hasCase = true;
                addGetInstruction(switchVar);
                GrType caseType = parseSubExpression().type;
                addBinaryOperator(GrLexemeType.equal, switchType, caseType, fileId);
                advance();

                jumpPosition = cast(uint) currentFunction.instructions.length;
                //Jumps to if(0).
                addInstruction(GrOpcode.jumpEqual);

                parseBlock(true);

                exitJumps ~= cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.jump);

                //Jumps to if(0).
                setInstruction(GrOpcode.jumpEqual, jumpPosition,
                        cast(int)(currentFunction.instructions.length - jumpPosition), true);
            }
        }

        if (hasDefaultCase) {
            const uint tmp = current;
            current = defaultCasePosition;
            parseBlock(true);
            current = tmp;
        }

        /* A switch is breakable. */
        closeBreakableSection();

        foreach (uint position; exitJumps)
            setInstruction(GrOpcode.jump, position,
                    cast(int)(currentFunction.instructions.length - position), true);
    }

    /**
    ---
    select
    case(SUBEXPR) BLOCK
    case(SUBEXPR) BLOCK
    case() BLOCK
    ---
    */
    private void parseSelectStatement() {
        advance();

        /* A select is breakable. */
        openBreakableSection();
        uint[] exitJumps;
        uint jumpPosition, casePosition, defaultCasePosition, defaultCaseKeywordPosition;
        bool hasCase, hasDefaultCase;
        uint startJump = cast(uint) currentFunction.instructions.length;

        addInstruction(GrOpcode.startSelectChannel);
        while (get().type == GrLexemeType.case_) {
            casePosition = current;
            advance();
            if (get().type != GrLexemeType.leftParenthesis)
                logError("missing parentheses after `case`",
                        "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            advance();

            if (get().type == GrLexemeType.rightParenthesis) {
                if (hasDefaultCase)
                    logError("there must be only up to one default case per `switch`",
                            "default `case` already defined", "",
                            casePosition - current, "previous default `case` definition",
                            defaultCaseKeywordPosition);
                advance();
                hasDefaultCase = true;
                defaultCasePosition = current;
                defaultCaseKeywordPosition = casePosition;
                skipBlock();
            }
            else {
                hasCase = true;
                jumpPosition = cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.tryChannel);
                parseSubExpression();
                advance();

                addInstruction(GrOpcode.checkChannel);

                parseBlock(true);

                exitJumps ~= cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.jump);

                setInstruction(GrOpcode.tryChannel, jumpPosition,
                        cast(int)(currentFunction.instructions.length - jumpPosition), true);
            }
        }

        if (hasDefaultCase) {
            /* With a default case specified, it is processed if no previous case has been processed in the select statement.
             * The select statement is not blocking here because at least one case is executed. */
            const uint tmp = current;
            current = defaultCasePosition;
            parseBlock(true);
            current = tmp;
        }
        else {
            /* Without default case, the select statement is a blocking operation until one case is processed.
             * So, we add a yield then jump back to the beggining of the statement to evaluate the select statement again. */
            addInstruction(GrOpcode.yield);
            addInstruction(GrOpcode.jump,
                    cast(int)(startJump - currentFunction.instructions.length), true);
        }

        /* A switch is breakable. */
        closeBreakableSection();

        foreach (uint position; exitJumps)
            setInstruction(GrOpcode.jump, position,
                    cast(int)(currentFunction.instructions.length - position), true);
        addInstruction(GrOpcode.endSelectChannel);
    }

    /**
    ---
    while(SUBEXPR)
        BLOCK
    ---
    */
    private void parseWhileStatement() {
        const bool isNegative = get().type == GrLexemeType.until;
        advance();
        if (get().type != GrLexemeType.leftParenthesis)
            logError("missing parentheses after `case`",
                    "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");

        /* While is breakable and continuable. */
        openBreakableSection();
        openContinuableSection();

        /* Continue jump. */
        setContinuableSectionDestination();

        uint conditionPosition, blockPosition = cast(uint) currentFunction.instructions.length;

        advance();
        parseSubExpression();

        advance();
        conditionPosition = cast(uint) currentFunction.instructions.length;
        addInstruction(GrOpcode.jumpEqual);

        parseBlock(true);

        addInstruction(GrOpcode.jump,
                cast(int)(blockPosition - currentFunction.instructions.length), true);
        setInstruction(isNegative ? GrOpcode.jumpNotEqual : GrOpcode.jumpEqual, conditionPosition,
                cast(int)(currentFunction.instructions.length - conditionPosition), true);

        /* While is breakable and continuable. */
        closeBreakableSection();
        closeContinuableSection();
    }

    /**
    ---
    do BLOCK
    while(SUBEXPR)
    ---
    */
    private void parseDoWhileStatement() {
        advance();

        /* While is breakable and continuable. */
        openBreakableSection();
        openContinuableSection();

        uint blockPosition = cast(uint) currentFunction.instructions.length;

        parseBlock(true);

        bool isNegative;
        if (get().type == GrLexemeType.until)
            isNegative = true;
        else if (get().type != GrLexemeType.while_)
            logError("missing `while` or `until` after the loop",
                    "expected `while` or `until`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        advance();

        /* Continue jump. */
        setContinuableSectionDestination();

        if (get().type != GrLexemeType.leftParenthesis)
            logError("missing parentheses after " ~ (isNegative ? "`until`" : "`while`"),
                    "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");

        advance();
        parseSubExpression();
        advance();

        addInstruction(isNegative ? GrOpcode.jumpEqual : GrOpcode.jumpNotEqual,
                cast(int)(blockPosition - currentFunction.instructions.length), true);

        /* While is breakable and continuable. */
        closeBreakableSection();
        closeContinuableSection();
    }

    private GrVariable parseDeclarableArgument() {
        GrVariable lvalue;
        GrType type = GrBaseType.void_;
        bool isAuto, isTyped = true;
        switch (get().type) with (GrLexemeType) {
        case autoType:
            isAuto = true;
            checkAdvance();
            break;
        case intType: .. case chanType:
            type = parseType();
            break;
        case identifier:
            if (_data.isTypeDeclared(get().svalue, get().fileId, false))
                type = parseType();
            else
                isTyped = false;
            break;
        default:
            logError("a variable definition or reference is expected",
                    "a variable or reference is expected, found `" ~ grGetPrettyLexemeType(get()
                        .type) ~ "`");
            break;
        }
        GrLexeme identifier = get();
        if (identifier.type != GrLexemeType.identifier)
            logError("a variable name is expected",
                    "a variable name is expected, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");

        if (isTyped) {
            lvalue = registerLocalVariable(identifier.svalue, type);
            lvalue.isAuto = isAuto;
        }
        else if (hasVariable(identifier.svalue, identifier.fileId)) {
            lvalue = getVariable(identifier.svalue, identifier.fileId);
        }
        else {
            /// Automatic, same behaviour with let.
            lvalue = registerLocalVariable(identifier.svalue, type);
            lvalue.isAuto = true;
        }

        //A composite type does not need to be initialized.
        if (lvalue.type == GrBaseType.class_)
            lvalue.isInitialized = true;

        checkAdvance();
        return lvalue;
    }

    /**
    The for statement takes an iterator and an array.
    */
    private void parseForStatement() {
        advance();
        const uint fileId = get().fileId;
        if (get().type != GrLexemeType.leftParenthesis)
            logError("missing parentheses after `for`",
                    "expected `(`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");

        advance();

        GrVariable variable = parseDeclarableArgument();

        if (get().type != GrLexemeType.comma)
            logError("missing comma in `for`",
                    "expected `,`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        advance();

        //From length to 0
        GrType containerType = parseSubExpression().type;

        switch (containerType.baseType) with (GrBaseType) {
        case array_: {
                /* Init */
                GrType subType = grUnmangle(containerType.mangledType);
                GrVariable iterator = registerSpecialVariable("iterator" ~ to!string(scopeLevel),
                        grInt);
                GrVariable index = registerSpecialVariable("index" ~ to!string(scopeLevel), grInt);
                GrVariable array = registerSpecialVariable("array" ~ to!string(scopeLevel),
                        containerType);

                if (variable.isAuto && subType.baseType != GrBaseType.void_) {
                    variable.isAuto = false;
                    variable.type = subType;
                    setVariableRegister(variable);
                }

                addSetInstruction(array, fileId, containerType, true);
                final switch (subType.baseType) with (GrBaseType) {
                case bool_:
                case int_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.length_int);
                    break;
                case float_:
                    addInstruction(GrOpcode.length_float);
                    break;
                case string_:
                    addInstruction(GrOpcode.length_string);
                    break;
                case array_:
                case class_:
                case foreign:
                case chan:
                case reference:
                    addInstruction(GrOpcode.length_object);
                    break;
                case void_:
                case null_:
                case internalTuple:
                    logError("an array can't be of type `" ~ grGetPrettyType(grArray(subType)) ~ "`",
                            "invalid array type");
                    break;
                }
                addInstruction(GrOpcode.setupIterator);
                addSetInstruction(iterator, fileId);

                //Set index to -1
                addIntConstant(-1);
                addSetInstruction(index, fileId);

                /* For is breakable and continuable. */
                openBreakableSection();
                openContinuableSection();

                /* Continue jump. */
                setContinuableSectionDestination();

                advance();
                uint blockPosition = cast(uint) currentFunction.instructions.length;

                addGetInstruction(iterator, GrType(GrBaseType.int_));
                addInstruction(GrOpcode.decrement_int);
                addSetInstruction(iterator, fileId);

                addGetInstruction(iterator, GrType(GrBaseType.int_));
                uint jumpPosition = cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.jumpEqual);

                //Set Index
                addGetInstruction(array);
                addGetInstruction(index);
                addInstruction(GrOpcode.increment_int);
                addSetInstruction(index, fileId, grVoid, true);
                final switch (subType.baseType) with (GrBaseType) {
                case bool_:
                case int_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.index2_int);
                    break;
                case float_:
                    addInstruction(GrOpcode.index2_float);
                    break;
                case string_:
                    addInstruction(GrOpcode.index2_string);
                    break;
                case array_:
                case class_:
                case foreign:
                case chan:
                case reference:
                    addInstruction(GrOpcode.index2_object);
                    break;
                case void_:
                case null_:
                case internalTuple:
                    logError("an array can't be of type `" ~ grGetPrettyType(grArray(subType)) ~ "`",
                            "invalid array type");
                    break;
                }
                convertType(subType, variable.type, fileId);
                addSetInstruction(variable, fileId);

                parseBlock(true);

                addInstruction(GrOpcode.jump,
                        cast(int)(blockPosition - currentFunction.instructions.length), true);
                setInstruction(GrOpcode.jumpEqual, jumpPosition,
                        cast(int)(currentFunction.instructions.length - jumpPosition), true);

                /* For is breakable and continuable. */
                closeBreakableSection();
                closeContinuableSection();
            }
            break;
        case foreign:
        case class_: {
                GrVariable iterator = registerSpecialVariable("iterator" ~ to!string(scopeLevel),
                        containerType);

                GrType subType;
                GrFunction nextFunc;
                GrPrimitive nextPrim = _data.getPrimitive("next", [
                        containerType
                        ]);
                if (nextPrim) {
                    if (nextPrim.outSignature.length != 2 || (nextPrim.outSignature.length >= 1
                            && nextPrim.outSignature[0].baseType != grBool)) {
                        logError("the primitive `" ~ grGetPrettyFunctionCall("next",
                                [containerType]) ~ "` must return a bool and a value",
                                "signature mismatch");
                    }
                    subType = nextPrim.outSignature[1];
                }
                else {
                    nextFunc = getFunction("next", [containerType], fileId);
                    if (!nextFunc) {
                        logError("there is no `" ~ grGetPrettyFunctionCall("next",
                                [containerType]) ~ "` defined", "not iterable");
                    }

                    if (nextFunc.outSignature.length != 2 || (nextFunc.outSignature.length >= 1
                            && nextFunc.outSignature[0].baseType != grBool)) {
                        logError("the function `" ~ grGetPrettyFunction(nextFunc) ~ "` must return a bool and a value",
                                "signature mismatch");
                    }
                    subType = nextFunc.outSignature[1];
                }

                if (variable.isAuto && subType.baseType != GrBaseType.void_) {
                    variable.isAuto = false;
                    variable.type = subType;
                    setVariableRegister(variable);
                }
                addSetInstruction(iterator, fileId, containerType);

                /* For is breakable and continuable. */
                openBreakableSection();
                openContinuableSection();

                /* Continue jump. */
                setContinuableSectionDestination();

                advance();
                uint blockPosition = cast(uint) currentFunction.instructions.length;

                addGetInstruction(iterator, containerType);
                if (nextPrim)
                    addInstruction(GrOpcode.primitiveCall, nextPrim.index);
                else
                    addFunctionCall(nextFunc, fileId);
                addSetInstruction(variable, fileId);

                uint jumpPosition = cast(uint) currentFunction.instructions.length;
                addInstruction(GrOpcode.jumpEqual);

                parseBlock(true);

                addInstruction(GrOpcode.jump,
                        cast(int)(blockPosition - currentFunction.instructions.length), true);
                setInstruction(GrOpcode.jumpEqual, jumpPosition,
                        cast(int)(currentFunction.instructions.length - jumpPosition), true);

                /* For is breakable and continuable. */
                closeBreakableSection();
                closeContinuableSection();
            }
            break;
        default:
            logError("for can't iterate over a `" ~ grGetPrettyType(containerType) ~ "`",
                    "not iterable");
            break;
        }
    }

    /// Skips everything from a `(` to its matching `)`.
    private void skipParenthesis() {
        if (get().type != GrLexemeType.leftParenthesis)
            return;
        advance();

        __loop: while (!isEnd()) {
            switch (get().type) with (GrLexemeType) {
            case rightParenthesis:
                advance();
                return;
            case rightBracket:
            case rightCurlyBrace:
            case semicolon:
                break __loop;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }
    }

    /// Skips everything from a `[` to its matching `]`.
    private void skipBrackets() {
        if (get().type != GrLexemeType.leftBracket)
            return;
        advance();

        __loop: while (!isEnd()) {
            switch (get().type) with (GrLexemeType) {
            case rightBracket:
                advance();
                return;
            case rightParenthesis:
            case rightCurlyBrace:
            case semicolon:
                break __loop;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }
    }

    /// Returns the number of parameters separated by commas inside a pair of (), [] or {}.
    private int checkArity() {
        int arity;
        const int position = current;

        bool useParenthesis, useBrackets, useCurlyBraces;

        switch (get().type) with (GrLexemeType) {
        case leftParenthesis:
            advance();
            useParenthesis = true;
            if (get(1).type != GrLexemeType.rightParenthesis)
                arity++;
            break;
        case leftBracket:
            advance();
            useBrackets = true;
            if (get(1).type != GrLexemeType.rightBracket)
                arity++;
            break;
        case leftCurlyBrace:
            advance();
            useCurlyBraces = true;
            if (get(1).type != GrLexemeType.rightCurlyBrace)
                arity++;
            break;
        default:
            logError("can't evaluate the arity of an unknown compound", "arity evaluation error");
            break;
        }

        __loop: while (!isEnd()) {
            switch (get().type) with (GrLexemeType) {
            case comma:
                arity++;
                advance();
                break;
            case rightParenthesis:
                if (!useParenthesis)
                    goto default;
                break __loop;
            case rightBracket:
                if (!useBrackets)
                    goto default;
                break __loop;
            case rightCurlyBrace:
                if (!useCurlyBraces)
                    goto default;
                break __loop;
            case semicolon:
                break __loop;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftBracket:
                skipBrackets();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            default:
                advance();
                break;
            }
        }

        current = position;
        return arity;
    }

    /**
    There are 3 types of loop.
    - The infinite loop with no parameters:
    ---
    loop printl("I'm infinite !");
    ---
    - The finite loop, with 1 parameter:
    ---
    loop(5) printl("I'm printed 5 times !");
    ---
    - The finite loop with an iterator:
    ---
    loop(i, 5) printl("Iterator = " ~ i as string);
    ---
    */
    private void parseLoopStatement() {
        bool isInfinite, hasCustomIterator;
        GrVariable iterator, customIterator;

        const uint fileId = get().fileId;
        advance();
        if (get().type == GrLexemeType.leftParenthesis) {
            const int arity = checkArity();
            advance();
            if (arity == 2) {
                hasCustomIterator = true;
                customIterator = parseDeclarableArgument();
                if (customIterator.isAuto) {
                    customIterator.isAuto = false;
                    customIterator.type = grInt;
                    setVariableRegister(customIterator);
                }
                else if (customIterator.type != grInt) {
                    logError("the type of the iterator must be `int`, not `" ~ grGetPrettyType(
                            customIterator.type) ~ "`", "the iterator must be `int`");
                }

                addIntConstant(0);
                addSetInstruction(customIterator, fileId);

                if (get().type != GrLexemeType.comma)
                    logError("missing comma in `loop`",
                            "expected `,`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
                advance();
            }

            /* Init */
            iterator = registerSpecialVariable("iterator" ~ to!string(scopeLevel),
                    GrType(GrBaseType.int_));

            //Init counter
            GrType type = parseSubExpression().type;
            advance();

            convertType(type, grInt, fileId);
            addInstruction(GrOpcode.setupIterator);
            addSetInstruction(iterator, fileId);
        }
        else
            isInfinite = true;

        /* For is breakable and continuable. */
        openBreakableSection();
        openContinuableSection();

        /* Continue jump. */
        setContinuableSectionDestination();

        uint blockPosition = cast(uint) currentFunction.instructions.length;
        uint jumpPosition;

        if (!isInfinite) {
            addGetInstruction(iterator, grInt, false);
            addInstruction(GrOpcode.decrement_int);
            addSetInstruction(iterator, fileId);

            addGetInstruction(iterator, grInt);
            jumpPosition = cast(uint) currentFunction.instructions.length;
            addInstruction(GrOpcode.jumpEqual);
        }

        parseBlock(true);

        if (!isInfinite && hasCustomIterator) {
            addGetInstruction(customIterator, grInt, false);
            addInstruction(GrOpcode.increment_int);
            addSetInstruction(customIterator, fileId);
        }

        addInstruction(GrOpcode.jump,
                cast(int)(blockPosition - currentFunction.instructions.length), true);
        if (!isInfinite)
            setInstruction(GrOpcode.jumpEqual, jumpPosition,
                    cast(int)(currentFunction.instructions.length - jumpPosition), true);

        /* For is breakable and continuable. */
        closeBreakableSection();
        closeContinuableSection();
    }

    /**
    The type of the return must be that of the signature of the function.
    ---
    return "Hello"; // Returns a string.
    return; // Returns nothing but still end the function.
    ---
    */
    private void parseReturnStatement() {
        checkDeferStatement();
        checkAdvance();
        if (currentFunction.name == "main" || currentFunction.isTask) {
            if (!currentFunction.instructions.length
                    || currentFunction.instructions[$ - 1].opcode != GrOpcode.kill_)
                addKill();
        }
        else {
            auto types = parseExpressionList();

            addReturn();
            if (types.length != currentFunction.outSignature.length) {
                const string argStr = to!string(currentFunction.outSignature.length) ~ (
                        currentFunction.outSignature.length > 1 ? " return values" : " return value");
                logError("mismatched number of return values",
                        "expected " ~ argStr ~ ", found " ~ to!string(types.length),
                        "the return signature is of type `" ~ grGetPrettyFunctionCall("",
                            currentFunction.outSignature) ~ "`", -1);
            }
            for (int i; i < types.length; i++) {
                if (types[i] != currentFunction.outSignature[i])
                    logError("the returned type `" ~ grGetPrettyType(
                            types[i]) ~ "` does not match the signature `" ~ grGetPrettyType(
                            currentFunction.outSignature[i]) ~ "`",
                            "expected `" ~ grGetPrettyType(currentFunction.outSignature[i]) ~ "` value",
                            "the return signature is of type `" ~ grGetPrettyFunctionCall("",
                                currentFunction.outSignature) ~ "`", -1);
            }
        }
    }

    /// Add a `return` instruction that pop the callstack.
    private void addReturn() {
        if (_options & GrOption.profile) {
            addInstruction(GrOpcode.debugProfileEnd);
        }
        addInstruction(GrOpcode.return_);
    }

    /// Add a `kill` instruction that stops the current task.
    private void addKill() {
        checkDeferStatement();
        if (_options & GrOption.profile) {
            addInstruction(GrOpcode.debugProfileEnd);
        }
        addInstruction(GrOpcode.kill_);
    }

    /// Add a `killall` instruction that stops every tasks.
    private void addKillAll() {
        checkDeferStatement();
        if (_options & GrOption.profile) {
            addInstruction(GrOpcode.debugProfileEnd);
        }
        addInstruction(GrOpcode.killAll_);
    }

    /// The more it is, the less you need parenthesis.
    private uint getLeftOperatorPriority(GrLexemeType type) {
        switch (type) with (GrLexemeType) {
        case assign: .. case powerAssign:
            return 6;
        case or:
            return 1;
        case xor:
            return 2;
        case and:
            return 3;
        case equal: .. case notEqual:
            return 14;
        case greaterOrEqual: .. case lesser:
            return 15;
        case add: .. case substract:
            return 16;
        case multiply: .. case remainder:
            return 17;
        case power:
            return 18;
        case not:
        case plus:
        case minus:
        case increment:
        case decrement:
        case send:
        case receive:
            return 19;
        default:
            logError("the operator is not listed in the operator priority table",
                    "unknown operator priority");
            return 0;
        }
    }

    /// The more it is, the less you need parenthesis.
    private uint getRightOperatorPriority(GrLexemeType type) {
        switch (type) with (GrLexemeType) {
        case assign: .. case powerAssign:
            return 20;
        case or:
            return 1;
        case xor:
            return 2;
        case and:
            return 3;
        case equal: .. case notEqual:
            return 4;
        case greaterOrEqual: .. case lesser:
            return 5;
        case add: .. case substract:
            return 16;
        case multiply: .. case remainder:
            return 17;
        case power:
            return 18;
        case not:
        case plus:
        case minus:
        case increment:
        case decrement:
        case send:
        case receive:
            return 19;
        default:
            logError("the operator is not listed in the operator priority table",
                    "unknown operator priority");
            return 0;
        }
    }

    /// Attempt to convert `src` type to the `dst` type.
    private GrType convertType(GrType src, GrType dst, uint fileId = 0,
            bool noFail = false, bool isExplicit = false) {
        if (src.baseType == dst.baseType) {
            final switch (src.baseType) with (GrBaseType) {
            case function_:
                if (src.mangledType == dst.mangledType
                        && src.mangledReturnType == dst.mangledReturnType)
                    return dst;
                break;
            case task:
                if (src.mangledType == dst.mangledType)
                    return dst;
                break;
            case null_:
                break;
            case void_:
            case bool_:
            case int_:
            case float_:
            case string_:
            case enum_:
                return dst;
            case class_:
                string className = src.mangledType;
                for (;;) {
                    if (className == dst.mangledType)
                        return dst;
                    const GrClassDefinition classType = getClass(className, fileId);
                    if (!classType.parent.length)
                        break;
                    className = classType.parent;
                }
                break;
            case array_:
            case chan:
            case reference:
            case internalTuple:
                if (dst.mangledType == src.mangledType)
                    return dst;
                break;
            case foreign:
                string foreignName = src.mangledType;
                for (;;) {
                    if (dst.mangledType == foreignName)
                        return dst;
                    const GrForeignDefinition foreignType = _data.getForeign(foreignName);
                    if (!foreignType.parent.length)
                        break;
                    foreignName = foreignType.parent;
                }
                break;
            }
        }

        if (src.baseType == GrBaseType.null_ && (dst.baseType == GrBaseType.class_
                || dst.baseType == GrBaseType.foreign))
            return dst;

        if (src.baseType == GrBaseType.internalTuple || dst.baseType == GrBaseType.internalTuple)
            logError("expected `" ~ grGetPrettyType(dst) ~ "`, found `" ~ grGetPrettyType(src) ~ "`",
                    "mismatched types", "", -1);

        if (dst.baseType == GrBaseType.bool_) {
            final switch (src.baseType) with (GrBaseType) {
            case function_:
            case task:
            case void_:
            case bool_:
            case int_:
            case float_:
            case string_:
            case internalTuple:
            case enum_:
                break;
            case array_:
            case class_:
            case foreign:
            case chan:
            case reference:
            case null_:
                addInstruction(GrOpcode.isNonNull_object);
                return dst;
            }
        }

        //User-defined conversions.
        if (addCustomConversion(src, dst, isExplicit, get().fileId) == dst)
            return dst;

        if (!noFail)
            logError("expected `" ~ grGetPrettyType(dst) ~ "`, found `" ~ grGetPrettyType(src) ~ "`",
                    "mismatched types", "", -1);
        return GrType(GrBaseType.void_);
    }

    /// Convert with a primitive or function.
    private GrType addCustomConversion(GrType leftType, GrType rightType,
            bool isExplicit, uint fileId) {
        GrType resultType = GrBaseType.void_;

        //as opposed to other functions, we need the return type (rightType) to be part of the signature.
        string name = "@as";
        GrType[] signature = [leftType, rightType];

        //GrPrimitive check
        const GrPrimitive primitive = _data.getPrimitive(name, signature);
        if (primitive) {
            //Some implicit conversions are disabled.
            //ex: float -> int because we might lose information.
            if (primitive.isExplicit && !isExplicit)
                return resultType;
            addInstruction(GrOpcode.primitiveCall, primitive.index);
            if (primitive.outSignature.length != 1uL) {
                const string argStr = to!string(primitive.outSignature.length) ~ (
                        primitive.outSignature.length > 1 ? " return values" : " return value");
                logError("an operator must have only one return value",
                        "expected 1 return value, found " ~ argStr);
            }
            resultType = rightType;
        }

        //GrFunction check
        if (resultType.baseType == GrBaseType.void_) {
            GrFunction func = getFunction(name, signature, fileId);
            if (func) {
                const GrType[] outSignature = addFunctionCall(func, fileId);
                if (outSignature.length != 1uL) {
                    const string argStr = to!string(primitive.outSignature.length) ~ (primitive.outSignature.length > 1
                            ? " return values" : " return value");
                    logError("an operator must have only one return value",
                            "expected 1 return value, found " ~ argStr);
                }
                resultType = rightType;
            }
        }
        return resultType;
    }

    private GrType parseObjectBuilder() {
        if (get().type != GrLexemeType.new_)
            logError("expected `new`, found `" ~ grGetPrettyLexemeType(get()
                    .type) ~ "`", "missing `new`");
        checkAdvance();
        if (get().type != GrLexemeType.identifier)
            logError("expected class name, found `" ~ grGetPrettyLexemeType(get()
                    .type) ~ "`", "missing identifier");
        uint fileId = get().fileId;
        GrType classType = parseType(true);
        if (classType.baseType != GrBaseType.class_)
            logError("`" ~ grGetPrettyType(classType) ~ "` is not a class type",
                    "invalid type", "", -1);
        GrClassDefinition class_ = getClass(classType.mangledType, fileId);
        if (!class_)
            logError("`" ~ grGetPrettyType(classType) ~ "` is not declared",
                    "unknown class", "", -1);
        addInstruction(GrOpcode.new_, cast(uint) class_.index);

        bool[] initFields;
        uint[] lexPositions;
        initFields.length = class_.fields.length;
        lexPositions.length = class_.fields.length;

        // Init
        if (get().type == GrLexemeType.leftCurlyBrace) {
            checkAdvance();
            while (!isEnd()) {
                if (get().type == GrLexemeType.rightCurlyBrace) {
                    checkAdvance();
                    break;
                }
                else if (get().type == GrLexemeType.identifier) {
                    const string fieldName = get().svalue;
                    checkAdvance();
                    bool hasField = false;
                    for (int i; i < class_.fields.length; ++i) {
                        if (class_.fields[i] == fieldName) {
                            hasField = true;

                            if (initFields[i])
                                logError("the field `" ~ fieldName ~ "` is initialized multiple times",
                                        "`" ~ fieldName ~ "` is already initialized",
                                        "", -1, "previous initialization", lexPositions[i] - 1);

                            initFields[i] = true;
                            lexPositions[i] = current;

                            GrVariable fieldLValue = new GrVariable;
                            fieldLValue.isInitialized = false;
                            fieldLValue.isField = true;
                            fieldLValue.type = class_.signature[i];
                            fieldLValue.register = i;
                            fieldLValue.fileId = get().fileId;
                            fieldLValue.lexPosition = current;
                            addInstruction(GrOpcode.fieldLoad2, fieldLValue.register);
                            parseAssignList([fieldLValue], true);
                            break;
                        }
                    }
                    if (!hasField)
                        logError("the field `" ~ fieldName ~ "` doesn't exist", "unknown field");
                }
                else {
                    logError("expected field name, found `" ~ grGetPrettyLexemeType(get()
                            .type) ~ "`", "missing field");
                }
            }
        }

        for (int i; i < class_.fields.length; ++i) {
            if (initFields[i])
                continue;
            GrVariable fieldLValue = new GrVariable;
            fieldLValue.isInitialized = false;
            fieldLValue.isField = true;
            fieldLValue.type = class_.signature[i];
            fieldLValue.register = i;
            fieldLValue.fileId = get().fileId;
            fieldLValue.lexPosition = current;
            addInstruction(GrOpcode.fieldLoad2, fieldLValue.register);
            addDefaultValue(fieldLValue.type, fileId);
            addSetInstruction(fieldLValue, fileId, fieldLValue.type);
        }

        return classType;
    }

    /**
    Parse an array creation.
    The type is optional if the array is not empty.
    If no type is specified, the array subtype is set to the type of the first element.
    ---
    array(int)[1, 2, 3]
    ["1", "2", "3"]
    array(string)[]
    ---
    */
    private GrType parseArrayBuilder() {
        GrType arrayType = GrType(GrBaseType.array_);
        GrType subType = grVoid;
        const uint fileId = get().fileId;

        //Explicit type like: array(int)[1, 2, 3]
        if (get().type == GrLexemeType.arrayType) {
            checkAdvance();
            string[] temp;
            auto signature = parseInSignature(temp, true);
            if (signature.length > 1)
                logError("an array can only contain one type of value", "conflicting array signature",
                        "try using `" ~ grGetPrettyType(grArray(signature[0])) ~ "` instead", -1);
            subType = signature[0];
            arrayType.mangledType = grMangleSignature(signature);
            if (subType.baseType == GrBaseType.void_)
                logError("an array can't be of type `" ~ grGetPrettyType(arrayType) ~ "`",
                        "invalid array type");
        }

        if (get().type != GrLexemeType.leftBracket)
            logError("missing brackets after `" ~ grGetPrettyType(arrayType) ~ "`",
                    "expected `[`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        advance();

        int arraySize;
        while (get().type != GrLexemeType.rightBracket) {
            if (subType.baseType == GrBaseType.void_) {
                //Implicit type specified by the type of the first element.
                subType = parseSubExpression(
                        GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA
                        | GR_SUBEXPR_EXPECTING_VALUE).type;
                arrayType.mangledType = grMangleSignature([subType]);
                if (subType.baseType == GrBaseType.void_)
                    logError("an array can't be of type `" ~ grGetPrettyType(arrayType) ~ "`",
                            "invalid array type");
            }
            else {
                convertType(parseSubExpression(
                        GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_EXPECTING_VALUE)
                        .type, subType, fileId);
            }
            arraySize++;

            if (get().type == GrLexemeType.rightBracket)
                break;
            if (get().type != GrLexemeType.comma)
                logError("indexes should be separated by a comma",
                        "expected `,`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            checkAdvance();
        }

        final switch (subType.baseType) with (GrBaseType) {
        case bool_:
        case int_:
        case function_:
        case task:
        case enum_:
            addInstruction(GrOpcode.array_int, arraySize);
            break;
        case float_:
            addInstruction(GrOpcode.array_float, arraySize);
            break;
        case string_:
            addInstruction(GrOpcode.array_string, arraySize);
            break;
        case array_:
        case class_:
        case foreign:
        case chan:
        case reference:
            addInstruction(GrOpcode.array_object, arraySize);
            break;
        case void_:
        case null_:
        case internalTuple:
            logError("an array can't be of type `" ~ grGetPrettyType(grArray(subType)) ~ "`",
                    "invalid array type");
            break;
        }
        advance();
        return arrayType;
    }

    private GrType parseArrayIndex(GrType arrayType) {
        const uint fileId = get().fileId;
        advance();

        for (;;) {
            if (get().type == GrLexemeType.comma)
                logError("an index is expected, found `,`", "missing value");
            auto index = parseSubExpression(
                    GR_SUBEXPR_TERMINATE_BRACKET | GR_SUBEXPR_TERMINATE_COMMA
                    | GR_SUBEXPR_EXPECTING_VALUE).type;
            if (index.baseType == GrBaseType.void_)
                logError("expected `int`, found nothing", "missing value");
            convertType(index, grInt, fileId);

            if (get().type == GrLexemeType.rightBracket) {
                switch (arrayType.baseType) with (GrBaseType) {
                case array_:
                    const GrType subType = grUnmangle(arrayType.mangledType);
                    final switch (subType.baseType) with (GrBaseType) {
                    case bool_:
                    case int_:
                    case function_:
                    case task:
                    case enum_:
                        addInstruction(GrOpcode.index_int);
                        break;
                    case float_:
                        addInstruction(GrOpcode.index_float);
                        break;
                    case string_:
                        addInstruction(GrOpcode.index_string);
                        break;
                    case array_:
                    case class_:
                    case foreign:
                    case chan:
                    case reference:
                        addInstruction(GrOpcode.index_object);
                        break;
                    case void_:
                    case null_:
                    case internalTuple:
                        logError("an array can't be of type `" ~ grGetPrettyType(grArray(subType)) ~ "`",
                                "invalid array type");
                        break;
                    }
                    arrayType = subType;
                    break;
                default:
                    logError("invalid array type",
                            "expected `array`, found `" ~ grGetPrettyType(arrayType) ~ "`");
                }
                break;
            }
            if (get().type != GrLexemeType.comma)
                logError("indexes should be separated by a comma",
                        "expected `,`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            checkAdvance();
            if (get().type == GrLexemeType.rightBracket)
                logError("indexes should be separated by a comma",
                        "expected `,`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");

            switch (arrayType.baseType) with (GrBaseType) {
            case array_:
                const GrType subType = grUnmangle(arrayType.mangledType);
                final switch (subType.baseType) with (GrBaseType) {
                case bool_:
                case int_:
                case function_:
                case task:
                case enum_:
                    addInstruction(GrOpcode.index_int);
                    break;
                case float_:
                    addInstruction(GrOpcode.index_float);
                    break;
                case string_:
                    addInstruction(GrOpcode.index_string);
                    break;
                case array_:
                case class_:
                case foreign:
                case chan:
                case reference:
                    addInstruction(GrOpcode.index_object);
                    break;
                case void_:
                case null_:
                case internalTuple:
                    logError("an array can't be of type `" ~ grGetPrettyType(arrayType) ~ "`",
                            "invalid array type");
                    break;
                }
                arrayType = subType;
                break;
            default:
                logError("invalid array type",
                        "expected `array`, found `" ~ grGetPrettyType(arrayType) ~ "`");
            }
        }
        advance();
        return arrayType;
    }

    /**
    Parse a cast, or `as` operation.
    ---
    1 as float
    ---
    */
    private GrType parseConversionOperator(GrType[] typeStack) {
        const uint fileId = get().fileId;
        if (!typeStack.length)
            logError("no value to convert", "missing value");
        advance();
        auto asType = parseType();
        convertType(typeStack[$ - 1], asType, fileId, false, true);
        typeStack[$ - 1] = asType;
        return asType;
    }

    /// Parse an assignable (named) element.
    private GrVariable parseLValue() {
        const uint fileId = get().fileId;
        if (get().type != GrLexemeType.identifier)
            logError("expected variable, found `" ~ grGetPrettyLexemeType(get()
                    .type) ~ "`", "missing variable");

        const string identifierName = get().svalue;

        checkAdvance();

        GrVariable* localLValue = (identifierName in currentFunction.localVariables);
        if (localLValue !is null)
            return *localLValue;

        GrVariable globalLValue = getGlobalVariable(identifierName, fileId);
        if (globalLValue !is null)
            return globalLValue;

        logError("expected variable, found `" ~ grGetPrettyLexemeType(get()
                .type) ~ "`", "missing variable");
        return null;
    }

    /// Parse a single expression, not a statement.
    private void parseExpression() {
        bool isAssignmentList;
        const auto tempPos = current;
        __skipLoop: while (!isEnd()) {
            switch (get().type) with (GrLexemeType) {
            case leftBracket:
                skipBrackets();
                break;
            case leftParenthesis:
                skipParenthesis();
                break;
            case leftCurlyBrace:
                skipBlock();
                break;
            case semicolon:
                isAssignmentList = false;
                break __skipLoop;
            case comma:
                isAssignmentList = true;
                break __skipLoop;
            default:
                checkAdvance();
                break;
            }
        }
        current = tempPos;

        if (isAssignmentList) {
            //Get list of lvalues
            GrVariable[] lvalues;
            do {
                if (lvalues.length)
                    checkAdvance();
                //Identifier
                if (get().type != GrLexemeType.identifier)
                    logError("expected identifier, found `" ~ grGetPrettyLexemeType(get()
                            .type) ~ "`", "missing identifier");
                lvalues ~= parseSubExpression(
                        GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_ASSIGN
                        | GR_SUBEXPR_EXPECTING_LVALUE).lvalue;
            }
            while (get().type == GrLexemeType.comma);

            parseAssignList(lvalues);
        }
        else {
            parseSubExpression(GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_MUST_CLEAN);
            checkAdvance();
        }
    }

    /// Parse the right side of a multiple assignment.
    private GrType[] parseExpressionList() {
        GrType[] expressionTypes;
        for (;;) {
            GrType type = parseSubExpression(
                    GR_SUBEXPR_TERMINATE_SEMICOLON | GR_SUBEXPR_TERMINATE_COMMA
                    | GR_SUBEXPR_EXPECTING_VALUE).type;
            if (type.baseType == GrBaseType.internalTuple) {
                auto types = grUnpackTuple(type);
                if (!types.length)
                    logError("the expression yields no value", "expected value, found nothing");
                else {
                    foreach (subType; types)
                        expressionTypes ~= subType;
                }
            }
            else if (type.baseType != GrBaseType.void_)
                expressionTypes ~= type;
            if (get().type != GrLexemeType.comma)
                break;
            checkAdvance();
        }
        if (get().type != GrLexemeType.semicolon)
            logError("missing semicolon after expression list",
                    "expected `;`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        checkAdvance();
        return expressionTypes;
    }

    /// Parse the right side of a multiple assignment and associate them with the `lvalues`.
    private void parseAssignList(GrVariable[] lvalues, bool isInitialization = false) {
        const uint fileId = get().fileId;
        switch (get().type) with (GrLexemeType) {
        case assign:
            advance();
            GrType[] expressionTypes = parseExpressionList();

            if (expressionTypes.length > lvalues.length) {
                const string argStr = to!string(lvalues.length) ~ (lvalues.length > 1
                        ? " variables" : " variable");
                logError("trying to assign `" ~ to!string(expressionTypes.length) ~ "` values to " ~ argStr,
                        "there are more values than variable to assign to", "", -1);
            }
            else if (!expressionTypes.length) {
                logError("the assignation is missing a value", "the expression is empty", "", -1);
            }

            int variableIndex = to!int(lvalues.length) - 1;
            int expressionIndex = to!int(expressionTypes.length) - 1;
            bool passThrough;
            GrVariable[] skippedLvalues;
            while (variableIndex > expressionIndex) {
                addSetInstruction(lvalues[variableIndex], fileId,
                        expressionTypes[expressionIndex], true);
                variableIndex--;
                passThrough = true;
            }
            if (passThrough) {
                if (expressionTypes[expressionIndex].baseType == GrBaseType.void_) {
                    skippedLvalues ~= lvalues[variableIndex];
                }
                else {
                    addSetInstruction(lvalues[variableIndex], fileId,
                            lvalues[variableIndex + 1].type, false);
                }
                variableIndex--;
                expressionIndex--;
            }
            while (variableIndex >= 0) {
                if (expressionTypes[expressionIndex].baseType == GrBaseType.void_) {
                    skippedLvalues ~= lvalues[variableIndex];
                }
                else {
                    while (skippedLvalues.length) {
                        addSetInstruction(skippedLvalues[$ - 1], fileId,
                                expressionTypes[expressionIndex], true);
                        skippedLvalues.length--;
                    }
                    addSetInstruction(lvalues[variableIndex], fileId,
                            expressionTypes[expressionIndex], false);
                }
                variableIndex--;
                expressionIndex--;
            }
            if (skippedLvalues.length)
                logError("first value of an assignment list can't be empty", "missing value");
            break;
        case semicolon:
            if (isInitialization) {
                foreach (lvalue; lvalues) {
                    if (lvalue.isAuto)
                        logError("can't infer the type without assignment",
                                "missing type information or initial value", "", -1);
                    addDefaultValue(lvalue.type, fileId);
                    addSetInstruction(lvalue, fileId, lvalue.type);
                }
            }
            advance();
            break;
        default:
            logError("missing semicolon after assignment list",
                    "expected `;`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        }
    }

    private void addDefaultValue(GrType type, uint fileId) {
        final switch (type.baseType) with (GrBaseType) {
        case int_:
        case bool_:
        case enum_:
            addIntConstant(0);
            break;
        case float_:
            addFloatConstant(0f);
            break;
        case string_:
            addStringConstant("");
            break;
        case function_:
            GrType[] inSignature = grUnmangleSignature(type.mangledType);
            GrType[] outSignature = grUnmangleSignature(type.mangledReturnType);
            string[] inputs;
            for (int i; i < inSignature.length; ++i) {
                inputs ~= to!string(i);
            }
            preBeginFunction("$anon", fileId, inSignature, inputs, false, outSignature, true);
            openDeferrableSection();
            foreach (outType; outSignature) {
                addDefaultValue(outType, fileId);
            }
            addReturn();
            closeDeferrableSection();
            registerDeferBlocks();
            endFunction();
            break;
        case task:
            GrType[] inSignature = grUnmangleSignature(type.mangledType);
            GrType[] outSignature = grUnmangleSignature(type.mangledReturnType);
            string[] inputs;
            for (int i; i < inSignature.length; ++i) {
                inputs ~= to!string(i);
            }
            preBeginFunction("$anon", fileId, inSignature, inputs, true, outSignature, true);
            openDeferrableSection();
            addKill();
            closeDeferrableSection();
            registerDeferBlocks();
            endFunction();
            break;
        case array_:
            GrType[] subTypes = grUnmangleSignature(type.mangledType);
            if (subTypes.length != 1)
                logError("an array can only contain one type of value", "conflicting array signature",
                        "try using `" ~ grGetPrettyType(grArray(subTypes[0])) ~ "` instead");
            final switch (subTypes[0].baseType) with (GrBaseType) {
            case bool_:
            case int_:
            case function_:
            case task:
            case enum_:
                addInstruction(GrOpcode.array_int, 0);
                break;
            case float_:
                addInstruction(GrOpcode.array_float, 0);
                break;
            case string_:
                addInstruction(GrOpcode.array_string, 0);
                break;
            case array_:
            case class_:
            case foreign:
            case chan:
            case reference:
                addInstruction(GrOpcode.array_object, 0);
                break;
            case void_:
            case null_:
            case internalTuple:
                logError("an array can't be of type `" ~ grGetPrettyType(grArray(subTypes[0])) ~ "`",
                        "invalid array type");
                break;
            }
            break;
        case class_:
            addInstruction(GrOpcode.const_null);
            break;
        case foreign:
            addInstruction(GrOpcode.const_null);
            break;
        case chan:
            GrType[] subTypes = grUnmangleSignature(type.mangledType);
            if (subTypes.length != 1)
                logError("a channel can only contain one type of value", "conflicting channel signature",
                        "try using `" ~ grGetPrettyType(grChannel(subTypes[0])) ~ "` instead");
            final switch (subTypes[0].baseType) with (GrBaseType) {
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                addInstruction(GrOpcode.channel_int, 1);
                break;
            case float_:
                addInstruction(GrOpcode.channel_float, 1);
                break;
            case string_:
                addInstruction(GrOpcode.channel_string, 1);
                break;
            case class_:
            case array_:
            case foreign:
            case chan:
            case reference:
                addInstruction(GrOpcode.channel_object, 1);
                break;
            case void_:
            case null_:
            case internalTuple:
                logError("a channel can't be of type `" ~ grGetPrettyType(grChannel(subTypes[0])) ~ "`",
                        "invalid channel type");
            }
            break;
        case reference:
        case void_:
        case null_:
        case internalTuple:
            logError("the type `" ~ grGetPrettyType(type) ~ "` has no default value",
                    "can't initialize this type");
        }
    }

    /**
    Count the number of D types used (int, float, string and void*).
    */
    private auto countSubTypes(GrType type) {
        struct TypeCounter {
            int iCount, fCount, sCount, oCount;
        }

        TypeCounter counter;
        void countSubTypes(GrType type, ref TypeCounter counter) {
            final switch (type.baseType) with (GrBaseType) {
            case int_:
            case bool_:
            case function_:
            case task:
            case enum_:
                counter.iCount++;
                break;
            case float_:
                counter.fCount++;
                break;
            case string_:
                counter.sCount++;
                break;
            case class_:
            case array_:
            case foreign:
            case chan:
            case reference:
                counter.oCount++;
                break;
            case void_:
            case null_:
                throw new Exception("the type can't be counted as a subtype");
            case internalTuple:
                auto types = grUnpackTuple(type);
                if (!types.length)
                    logError("the expression yields no value", "expected value, found nothing");
                else {
                    foreach (subType; types)
                        countSubTypes(subType, counter);
                }
                break;
            }
        }

        countSubTypes(type, counter);
        return counter;
    }

    /// Add an instruction to clean up a value from the stack.
    private void shiftStackPosition(GrType type, short count) {
        const auto counter = countSubTypes(type);
        if (counter.iCount)
            addInstruction(GrOpcode.shiftStack_int, counter.iCount * count, true);
        if (counter.fCount)
            addInstruction(GrOpcode.shiftStack_float, counter.fCount * count, true);
        if (counter.sCount)
            addInstruction(GrOpcode.shiftStack_string, counter.sCount * count, true);
        if (counter.oCount)
            addInstruction(GrOpcode.shiftStack_object, counter.oCount * count, true);
    }

    /// Does this operation require a left-expr ?
    private bool requireLValue(GrLexemeType operatorType) {
        switch (operatorType) with (GrLexemeType) {
        case increment:
        case decrement:
        case assign: .. case powerAssign:
            return true;
        default:
            return false;
        }
    }

    /**
    Parse a function reference expression. \
    Converts a public function/task into an anonymous one.
    */
    private GrType parseFunctionPointer(GrType currentType) {
        const uint fileId = get().fileId;
        checkAdvance();
        if (get().type == GrLexemeType.leftParenthesis) {
            checkAdvance();
            GrType refType = parseType();
            if (get().type != GrLexemeType.rightParenthesis)
                logError("missing parenthesis after the type",
                        "expected `)`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
            checkAdvance();
            if (currentType.baseType == GrBaseType.void_)
                currentType = refType;
            else
                currentType = convertType(refType, currentType, fileId);
        }
        if (get().type != GrLexemeType.identifier)
            logError("expected function name, found `" ~ grGetPrettyLexemeType(get()
                    .type) ~ "`", "missing function name");
        if (currentType.baseType != GrBaseType.function_ && currentType.baseType != GrBaseType.task)
            logError("can't infer the type of `" ~ get().svalue ~ "`",
                    "the function type can't be inferred");

        GrType funcType = addFunctionAddress(get().svalue,
                grUnmangleSignature(currentType.mangledType), get().fileId);
        convertType(funcType, currentType, fileId);
        checkAdvance();
        return currentType;
    }

    private enum {
        GR_SUBEXPR_TERMINATE_SEMICOLON = 0x1,
        GR_SUBEXPR_TERMINATE_BRACKET = 0x2,
        GR_SUBEXPR_TERMINATE_COMMA = 0x4,
        GR_SUBEXPR_TERMINATE_PARENTHESIS = 0x8,
        GR_SUBEXPR_TERMINATE_ASSIGN = 0x10,
        GR_SUBEXPR_MUST_CLEAN = 0x20,
        GR_SUBEXPR_EXPECTING_VALUE = 0x40,
        GR_SUBEXPR_EXPECTING_LVALUE = 0x80,
    }

    private struct GrSubExprResult {
        GrType type;
        GrVariable lvalue;
    }

    /**
    Evaluate a single subexpression.
    */
    private GrSubExprResult parseSubExpression(
            int flags = GR_SUBEXPR_TERMINATE_PARENTHESIS | GR_SUBEXPR_EXPECTING_VALUE) {
        const bool useSemicolon = (flags & GR_SUBEXPR_TERMINATE_SEMICOLON) > 0;
        const bool useBracket = (flags & GR_SUBEXPR_TERMINATE_BRACKET) > 0;
        const bool useComma = (flags & GR_SUBEXPR_TERMINATE_COMMA) > 0;
        const bool useParenthesis = (flags & GR_SUBEXPR_TERMINATE_PARENTHESIS) > 0;
        const bool useAssign = (flags & GR_SUBEXPR_TERMINATE_ASSIGN) > 0;
        const bool mustCleanValue = (flags & GR_SUBEXPR_MUST_CLEAN) > 0;
        const bool isExpectingValue = (flags & GR_SUBEXPR_EXPECTING_VALUE) > 0;
        const bool isExpectingLValue = (flags & GR_SUBEXPR_EXPECTING_LVALUE) > 0;

        GrVariable[] lvalues;
        GrLexemeType[] operatorsStack;
        GrType[] typeStack;
        GrType currentType = grVoid, lastType = grVoid;
        bool hasValue = false, hadValue = false, hasLValue = false, hadLValue = false, hasReference = false,
            hadReference = false, isRightUnaryOperator = true, isEndOfExpression = false;

        GrSubExprResult result;
        uint fileId;

        do {
            if (hasValue && currentType != lastType && lastType != grVoid) {
                lastType = currentType;
                currentType = lastType;
            }
            else
                lastType = currentType;

            isRightUnaryOperator = false;
            hadValue = hasValue;
            hasValue = false;

            hadLValue = hasLValue;
            hasLValue = false;

            hadReference = hasReference;
            hasReference = false;

            GrLexeme lex = get();
            fileId = lex.fileId;
            switch (lex.type) with (GrLexemeType) {
            case semicolon:
                if (useSemicolon)
                    isEndOfExpression = true;
                else
                    logError("unexpected semicolon found in expression",
                            "a `;` can't exist inside this expression");
                break;
            case comma:
                if (useComma)
                    isEndOfExpression = true;
                else
                    logError("unexpected comma found in expression",
                            "a `,` can't exist inside this expression");
                break;
            case rightParenthesis:
                if (useParenthesis)
                    isEndOfExpression = true;
                else
                    logError("unexpected parenthesis found in expression",
                            "a `)` can't exist inside this expression");
                break;
            case rightBracket:
                if (useBracket)
                    isEndOfExpression = true;
                else
                    logError("unexpected bracket found in expression",
                            "a `]` can't exist inside this expression");
                break;
            case leftParenthesis:
                if (hadValue) {
                    currentType = parseAnonymousCall(typeStack[$ - 1]);
                    //Unpack function value for 1 or less return values
                    //Multiples values are left as a tuple for parseExpressionList()
                    if (currentType.baseType == GrBaseType.internalTuple) {
                        auto types = grUnpackTuple(currentType);
                        if (!types.length)
                            currentType = grVoid;
                        else if (types.length == 1uL)
                            currentType = types[0];
                    }
                    if (currentType.baseType == GrBaseType.void_) {
                        typeStack.length--;
                    }
                    else {
                        hadValue = false;
                        hasValue = true;
                        typeStack[$ - 1] = currentType;
                    }
                }
                else {
                    advance();
                    currentType = parseSubExpression().type;
                    advance();
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            case doubleColon:
                advance();
                if (!hadValue)
                    logError("a method call must be placed after a value", "missing value");
                if (get().type != GrLexemeType.identifier)
                    logError("expected function name, found `" ~ grGetPrettyLexemeType(get()
                            .type) ~ "`", "missing function name");

                GrType selfType = grVoid;
                selfType = typeStack[$ - 1];
                typeStack.length--;
                hadValue = false;

                GrVariable lvalue;
                currentType = parseIdentifier(lvalue, lastType, selfType, isExpectingLValue);
                //Unpack function value for 1 or less return values
                //Multiples values are left as a tuple for parseExpressionList()
                if (currentType.baseType == GrBaseType.internalTuple) {
                    auto types = grUnpackTuple(currentType);
                    if (!types.length)
                        currentType = grVoid;
                    else if (types.length == 1uL)
                        currentType = types[0];
                }

                const auto nextLexeme = get();
                if (nextLexeme.type == GrLexemeType.leftBracket)
                    hasReference = true;
                if (currentType != GrType(GrBaseType.void_)) {
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            case arrayType:
                currentType = parseArrayBuilder();
                typeStack ~= currentType;
                hasValue = true;
                break;
            case leftBracket:
                //Index
                if (hadValue) {
                    hadValue = false;
                    currentType = parseArrayIndex(lastType);
                    hasReference = true;
                    //Check if there is an assignement or not, discard if it's only a rvalue
                    const auto nextLexeme = get();
                    if (requireLValue(nextLexeme.type) || (isExpectingLValue
                            && nextLexeme.type == GrLexemeType.comma)) {
                        if ((nextLexeme.type > GrLexemeType.assign && nextLexeme.type <= GrLexemeType.powerAssign)
                                || nextLexeme.type == GrLexemeType.increment
                                || nextLexeme.type == GrLexemeType.decrement) {
                            final switch (currentType.baseType) with (GrBaseType) {
                            case bool_:
                            case int_:
                            case function_:
                            case task:
                            case enum_:
                                setInstruction(GrOpcode.index3_int,
                                        cast(int) currentFunction.instructions.length - 1);
                                break;
                            case float_:
                                setInstruction(GrOpcode.index3_float,
                                        cast(int) currentFunction.instructions.length - 1);
                                break;
                            case string_:
                                setInstruction(GrOpcode.index3_string,
                                        cast(int) currentFunction.instructions.length - 1);
                                break;
                            case array_:
                            case class_:
                            case foreign:
                            case chan:
                            case reference:
                                setInstruction(GrOpcode.index3_object,
                                        cast(int) currentFunction.instructions.length - 1);
                                break;
                            case void_:
                            case null_:
                            case internalTuple:
                                logError("an array can't be indexed by a `" ~ grGetPrettyType(currentType) ~ "`",
                                        "invalid array index type");
                                break;
                            }
                        }
                        hasLValue = true;
                        GrVariable refVar = new GrVariable;
                        refVar.type.baseType = GrBaseType.reference;
                        refVar.type.mangledType = grMangleSignature([
                                currentType
                                ]);
                        lvalues ~= refVar;
                    }
                    else {
                        final switch (currentType.baseType) with (GrBaseType) {
                        case bool_:
                        case int_:
                        case function_:
                        case task:
                        case enum_:
                            setInstruction(GrOpcode.index2_int,
                                    cast(int) currentFunction.instructions.length - 1);
                            break;
                        case float_:
                            setInstruction(GrOpcode.index2_float,
                                    cast(int) currentFunction.instructions.length - 1);
                            break;
                        case string_:
                            setInstruction(GrOpcode.index2_string,
                                    cast(int) currentFunction.instructions.length - 1);
                            break;
                        case array_:
                        case class_:
                        case foreign:
                        case chan:
                        case reference:
                            setInstruction(GrOpcode.index2_object,
                                    cast(int) currentFunction.instructions.length - 1);
                            break;
                        case void_:
                        case null_:
                        case internalTuple:
                            logError("an array can't be indexed by a `" ~ grGetPrettyType(currentType) ~ "`",
                                    "invalid array index type");
                            break;
                        }
                    }
                    lastType = currentType;
                    typeStack[$ - 1] = currentType;
                    hasValue = true;
                }
                else {
                    currentType = parseArrayBuilder();
                    typeStack ~= currentType;
                    hasValue = true;
                }
                break;
            case integer:
                currentType = GrType(GrBaseType.int_);
                addIntConstant(lex.ivalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case float_:
                currentType = GrType(GrBaseType.float_);
                addFloatConstant(lex.fvalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case boolean:
                currentType = GrType(GrBaseType.bool_);
                addBoolConstant(lex.bvalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case string_:
                currentType = GrType(GrBaseType.string_);
                addStringConstant(lex.svalue);
                hasValue = true;
                typeStack ~= currentType;
                checkAdvance();
                break;
            case null_:
                currentType = GrType(GrBaseType.null_);
                hasValue = true;
                typeStack ~= currentType;
                addInstruction(GrOpcode.const_null);
                checkAdvance();
                break;
            case new_:
                currentType = parseObjectBuilder();
                hasValue = true;
                typeStack ~= currentType;
                break;
            case chanType:
                currentType = parseChannelBuilder();
                hasValue = true;
                typeStack ~= currentType;
                break;
            case period:
                if (currentType.baseType != GrBaseType.class_)
                    logError("can't access a field on type `" ~ grGetPrettyType(currentType) ~ "`",
                            "expected a class, found `" ~ grGetPrettyType(currentType) ~ "`");
                checkAdvance();
                if (get().type != GrLexemeType.identifier)
                    logError("expected field name, found `" ~ grGetPrettyLexemeType(get()
                            .type) ~ "`", "missing field");
                const string identifier = get().svalue;
                checkAdvance();
                GrClassDefinition class_ = getClass(currentType.mangledType, get().fileId);
                if (!class_)
                    logError("the type `" ~ grGetPrettyType(currentType) ~ "` is not declared",
                            "unknown type");
                const auto nbFields = class_.signature.length;
                bool hasField;
                for (int i; i < nbFields; i++) {
                    if (identifier == class_.fields[i]) {
                        if ((class_.fieldsInfo[i].fileId != fileId)
                                && !class_.fieldsInfo[i].isPublic)
                            logError("`" ~ identifier ~ "` on type `" ~ grGetPrettyType(currentType) ~ "` is private",
                                    "private field", "", -1);
                        hasField = true;
                        currentType = class_.signature[i];
                        currentType.isField = true;
                        GrVariable fieldLValue = new GrVariable;
                        fieldLValue.isInitialized = true;
                        fieldLValue.isField = true;
                        fieldLValue.type = currentType;
                        fieldLValue.register = i;
                        fieldLValue.fileId = get().fileId;
                        fieldLValue.lexPosition = current;

                        if (requireLValue(get().type)) {
                            if (hadLValue)
                                lvalues[$ - 1] = fieldLValue;
                            else
                                lvalues ~= fieldLValue;
                        }

                        if (hadValue)
                            typeStack[$ - 1] = currentType;
                        else
                            typeStack ~= currentType;

                        hasValue = true;
                        hadValue = false;
                        hasLValue = true;
                        hadLValue = false;

                        switch (get().type) with (GrLexemeType) {
                        case period:
                            addInstruction(GrOpcode.fieldLoad_object, fieldLValue.register);
                            break;
                        case assign:
                            addInstruction(GrOpcode.fieldLoad, fieldLValue.register);
                            break;
                        case increment:
                        case decrement:
                        case addAssign: .. case powerAssign:
                            addLoadFieldInstruction(currentType, fieldLValue.register, true);
                            break;
                        case leftParenthesis:
                            lvalues.length--;
                            addLoadFieldInstruction(currentType, fieldLValue.register, false);
                            currentType = parseAnonymousCall(typeStack[$ - 1]);
                            //Unpack function value for 1 or less return values
                            //Multiples values are left as a tuple for parseExpressionList()
                            if (currentType.baseType == GrBaseType.internalTuple) {
                                auto types = grUnpackTuple(currentType);
                                if (!types.length)
                                    currentType = grVoid;
                                else if (types.length == 1uL)
                                    currentType = types[0];
                            }
                            if (currentType.baseType == GrBaseType.void_) {
                                typeStack.length--;
                            }
                            else {
                                hadValue = false;
                                hasValue = true;
                                typeStack[$ - 1] = currentType;
                            }
                            break;
                        case comma:
                            if (isExpectingLValue)
                                goto case assign;
                            goto default;
                        default:
                            addLoadFieldInstruction(currentType, fieldLValue.register, false);
                            break;
                        }
                        break;
                    }
                }
                if (!hasField) {
                    const string[] nearestValues = findNearestStrings(identifier, class_.fields);
                    string errorNote;
                    if (nearestValues.length) {
                        errorNote = "available fields are: ";
                        foreach (size_t i, const string value; nearestValues) {
                            errorNote ~= "`" ~ value ~ "`";
                            if ((i + 1) < nearestValues.length)
                                errorNote ~= ", ";
                        }
                        errorNote ~= ".";
                    }
                    logError("no field `" ~ identifier ~ "` on type `" ~ grGetPrettyType(currentType) ~ "`",
                            "unknown field", errorNote, -1);
                }
                break;
            case colon:
                const size_t methodCallPos = current;
                if (!hadValue)
                    logError("missing parameter on method call",
                            "the method call must be done after a value");
                checkAdvance();
                GrType selfType = currentType;
                if (get().type != GrLexemeType.identifier)
                    logError("expected function name, found `" ~ grGetPrettyLexemeType(get()
                            .type) ~ "`", "missing function name");
                const string identifier = get().svalue;
                checkAdvance();
                bool hasField;

                if (currentType.baseType == GrBaseType.class_) {
                    GrClassDefinition class_ = getClass(currentType.mangledType, get().fileId);
                    if (!class_)
                        logError("`" ~ grGetPrettyType(currentType) ~ "` is not declared",
                                "unknown class", "", -1);
                    const auto nbFields = class_.signature.length;
                    for (int i; i < nbFields; i++) {
                        if (identifier == class_.fields[i]) {
                            if ((class_.fieldsInfo[i].fileId != fileId)
                                    && !class_.fieldsInfo[i].isPublic) {
                                const string errMsg = "`" ~ identifier ~ "` of type `" ~ grGetPrettyType(
                                        currentType) ~ "` is private";
                                logError(errMsg, "private field", "", -1);
                            }
                            hasField = true;
                            currentType = class_.signature[i];
                            currentType.isField = true;
                            GrVariable fieldLValue = new GrVariable;
                            fieldLValue.isInitialized = true;
                            fieldLValue.isField = true;
                            fieldLValue.type = currentType;
                            fieldLValue.register = i;
                            fieldLValue.fileId = get().fileId;
                            fieldLValue.lexPosition = current;

                            if (hadLValue)
                                lvalues.length--;

                            if (hadValue)
                                typeStack[$ - 1] = currentType;
                            else
                                typeStack ~= currentType;

                            hasValue = true;
                            hadValue = false;
                            hasLValue = true;
                            hadLValue = false;

                            addInstruction(GrOpcode.copy_object);
                            addLoadFieldInstruction(currentType, fieldLValue.register, false);
                            currentType = parseAnonymousCall(typeStack[$ - 1], selfType);
                            //Unpack function value for 1 or less return values
                            //Multiples values are left as a tuple for parseExpressionList()
                            if (currentType.baseType == GrBaseType.internalTuple) {
                                auto types = grUnpackTuple(currentType);
                                if (!types.length)
                                    currentType = grVoid;
                                else if (types.length == 1uL)
                                    currentType = types[0];
                            }
                            if (currentType.baseType == GrBaseType.void_) {
                                typeStack.length--;
                            }
                            else {
                                hadValue = false;
                                hasValue = true;
                                typeStack[$ - 1] = currentType;
                            }
                            break;
                        }
                    }
                }
                if (!hasField) {
                    current = methodCallPos;
                    goto case doubleColon;
                }
                break;
            case pointer:
                currentType = parseFunctionPointer(currentType);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case as:
                if (!hadValue)
                    logError("`as` must be placed after a value", "missing value");
                currentType = parseConversionOperator(typeStack);
                hasValue = true;
                hadValue = false;
                break;
            case self:
                // Parse a function call that refers to its parent. 
                checkAdvance();
                currentType = addFunctionAddress(currentFunction, get().fileId);
                if (currentType.baseType == GrBaseType.void_)
                    logError("`self` must be inside a function or a task",
                            "`self` references no function nor task", "", -1);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case functionType:
                currentType = parseAnonymousFunction(false);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case taskType:
                currentType = parseAnonymousFunction(true);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case assign:
                if (useAssign) {
                    isEndOfExpression = true;
                    break;
                }
                goto case addAssign;
            case addAssign: .. case powerAssign:
                if (!hadLValue)
                    logError("the value before assignation is not referenceable",
                            "missing reference before assignation");
                hadLValue = false;
                goto case multiply;
            case add:
                if (!hadValue)
                    lex.type = GrLexemeType.plus;
                goto case multiply;
            case substract:
                if (!hadValue)
                    lex.type = GrLexemeType.minus;
                goto case multiply;
            case send:
                if (!hadValue)
                    lex.type = GrLexemeType.receive;
                goto case multiply;
            case increment: .. case decrement:
                isRightUnaryOperator = true;
                goto case multiply;
            case multiply: .. case not:
                if (isExpectingLValue)
                    logError(
                            "can't do this kind of operation on the left side of an assignment",
                            "unexpected operation");
                if (!hadValue && lex.type != GrLexemeType.plus
                        && lex.type != GrLexemeType.minus && lex.type != GrLexemeType.not
                        && lex.type != GrLexemeType.receive)
                    logError("a binary operation must have 2 operands", "missing value");

                while (operatorsStack.length
                        && getLeftOperatorPriority(operatorsStack[$ - 1]) > getRightOperatorPriority(
                            lex.type)) {
                    GrLexemeType operator = operatorsStack[$ - 1];

                    switch (operator) with (GrLexemeType) {
                    case assign:
                        addSetInstruction(lvalues[$ - 1], fileId, currentType, true);
                        lvalues.length--;
                        break;
                    case addAssign: .. case powerAssign:
                        currentType = addOperator(operator - (GrLexemeType.addAssign - GrLexemeType.add),
                                typeStack, fileId);
                        addSetInstruction(lvalues[$ - 1], fileId, currentType, true);
                        lvalues.length--;
                        break;
                    case increment: .. case decrement:
                        currentType = addOperator(operator, typeStack, fileId);
                        addSetInstruction(lvalues[$ - 1], fileId, currentType, true);
                        lvalues.length--;
                        break;
                    default:
                        currentType = addOperator(operator, typeStack, fileId);
                        break;
                    }

                    operatorsStack.length--;
                }

                operatorsStack ~= lex.type;
                if (hadValue && isRightUnaryOperator) {
                    hasValue = true;
                    hadValue = false;
                }
                else
                    hasValue = false;
                checkAdvance();
                break;
            case identifier:
                GrVariable lvalue;
                currentType = parseIdentifier(lvalue, lastType, grVoid, isExpectingLValue);
                //Unpack function value for 1 or less return values
                //Multiples values are left as a tuple for parseExpressionList()
                if (currentType.baseType == GrBaseType.internalTuple) {
                    auto types = grUnpackTuple(currentType);
                    if (!types.length)
                        currentType = grVoid;
                    else if (types.length == 1uL)
                        currentType = types[0];
                }

                //Check if there is an assignement or not, discard if it's only a rvalue
                const auto nextLexeme = get();
                if (lvalue !is null && (requireLValue(nextLexeme.type)
                        || (isExpectingLValue && nextLexeme.type == GrLexemeType.comma))) {
                    hasLValue = true;
                    lvalues ~= lvalue;

                    if (lvalue.isAuto)
                        hasValue = true;
                }

                if (!hasLValue && nextLexeme.type == GrLexemeType.leftBracket)
                    hasReference = true;

                if (currentType != GrType(GrBaseType.void_)) {
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            default:
                logError("unexpected `" ~ grGetPrettyLexemeType(lex.type) ~ "` symbol in the expression",
                        "unexpected symbol");
            }

            if (hasValue && hadValue)
                logError("missing semicolon at the end of the expression",
                        "expected `;`, found `" ~ grGetPrettyLexemeType(get().type) ~ "`");
        }
        while (!isEndOfExpression);

        if (operatorsStack.length) {
            if (!hadValue) {
                /*if(!isRightUnaryOperator)
                    logError("Expected value", "A value is missing");
                else*/
                logError("a binary operation must have 2 operands", "missing value");
            }
        }

        while (operatorsStack.length) {
            GrLexemeType operator = operatorsStack[$ - 1];

            switch (operator) with (GrLexemeType) {
            case assign:
                addSetInstruction(lvalues[$ - 1], fileId, currentType,
                        isExpectingValue || operatorsStack.length > 1uL);
                lvalues.length--;

                if (operatorsStack.length <= 1uL)
                    hadValue = false;
                break;
            case addAssign: .. case powerAssign:
                currentType = addOperator(
                        operator - (GrLexemeType.addAssign - GrLexemeType.add), typeStack, fileId);
                addSetInstruction(lvalues[$ - 1], fileId, currentType,
                        isExpectingValue || operatorsStack.length > 1uL);
                lvalues.length--;

                if (operatorsStack.length <= 1uL)
                    hadValue = false;
                break;
            case increment: .. case decrement:
                currentType = addOperator(operator, typeStack, fileId);
                addSetInstruction(lvalues[$ - 1], fileId, currentType,
                        isExpectingValue || operatorsStack.length > 1uL);
                lvalues.length--;

                if (operatorsStack.length <= 1uL)
                    hadValue = false;
                break;
            default:
                currentType = addOperator(operator, typeStack, fileId);
                break;
            }

            operatorsStack.length--;
        }

        if (isExpectingLValue) {
            if (!hadLValue)
                logError("the value before assignation is not referenceable",
                        "missing reference before assignation");
            result.lvalue = lvalues[$ - 1];
        }

        if (mustCleanValue && hadValue && currentType.baseType != GrBaseType.void_)
            shiftStackPosition(currentType, -1);

        result.type = currentType;
        return result;
    }

    private void addLoadFieldInstruction(GrType type, uint index, bool asCopy) {
        final switch (type.baseType) with (GrBaseType) {
        case bool_:
        case int_:
        case function_:
        case task:
        case enum_:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_int : GrOpcode.fieldLoad_int, index);
            break;
        case float_:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_float : GrOpcode.fieldLoad_float, index);
            break;
        case string_:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_string : GrOpcode.fieldLoad_string, index);
            break;
        case reference:
        case chan:
        case class_:
        case array_:
        case foreign:
            addInstruction(asCopy ? GrOpcode.fieldLoad2_object : GrOpcode.fieldLoad_object, index);
            break;
        case internalTuple:
        case null_:
        case void_:
            logError("can't load a field of type `" ~ grGetPrettyType(type) ~ "`",
                    "the field type is invalid");
            break;
        }
    }

    /// Parse a function call from a runtime value.
    private GrType parseAnonymousCall(GrType type, GrType selfType = grVoid) {
        const uint fileId = get().fileId;

        GrVariable functionId;
        if (type.baseType == GrBaseType.function_) {
            functionId = registerSpecialVariable("anon", GrType(GrBaseType.int_));
            addSetInstruction(functionId, fileId, GrType(GrBaseType.int_));
        }
        else if (type.baseType != GrBaseType.task) {
            logError("can't call a `" ~ grGetPrettyType(type) ~ "`",
                    "`" ~ grGetPrettyType(type) ~ "` is not a function nor a task");
        }

        //Signature parsing with type conversion
        GrType[] signature;
        GrType[] anonSignature = grUnmangleSignature(type.mangledType);
        int i;
        if (selfType != grVoid) {
            signature ~= convertType(selfType, anonSignature[i], fileId);
            i++;
        }
        if (get().type == GrLexemeType.leftParenthesis) {
            checkAdvance();
            if (get().type != GrLexemeType.rightParenthesis) {
                for (;;) {
                    if (i >= anonSignature.length) {
                        const string argStr = to!string(anonSignature.length) ~ (anonSignature.length > 1
                                ? " arguments" : " argument");
                        logError("the function takes " ~ argStr ~ " but more were supplied", "expected " ~ argStr,
                                "the function is of type `" ~ grGetPrettyType(type) ~ "`");
                    }
                    GrType subType = parseSubExpression(
                            GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                            | GR_SUBEXPR_EXPECTING_VALUE).type;
                    signature ~= convertType(subType, anonSignature[i], fileId);
                    if (get().type == GrLexemeType.rightParenthesis) {
                        checkAdvance();
                        break;
                    }
                    advance();
                    i++;
                }
            }
            else {
                checkAdvance();
            }
        }
        if (signature.length != anonSignature.length) {
            const string argStr = to!string(anonSignature.length) ~ (anonSignature.length > 1
                    ? " arguments" : " argument");
            const string argStr2 = to!string(signature.length) ~ (signature.length > 1
                    ? " arguments" : " argument");
            logError("the function takes " ~ argStr ~ " but " ~ argStr2 ~ " were supplied",
                    "expected " ~ argStr ~ ", found " ~ argStr2,
                    "the function is of type `" ~ grGetPrettyType(type) ~ "`");
        }

        //Push the values on the global stack for task spawning.
        if (type.baseType == GrBaseType.task)
            addGlobalPush(signature);

        //Anonymous call.
        GrType retTypes = grPackTuple(grUnmangleSignature(type.mangledReturnType));

        if (type.baseType == GrBaseType.function_) {
            addGetInstruction(functionId, GrType(GrBaseType.int_));
        }

        if (type.baseType == GrBaseType.function_)
            addInstruction(GrOpcode.anonymousCall, 0u);
        else
            addInstruction(GrOpcode.anonymousTask, 0u);
        return retTypes;
    }

    /// Parse an identifier or function call and return the deduced return type and lvalue.
    private GrType parseIdentifier(ref GrVariable variable, GrType expectedType,
            GrType selfType = grVoid, bool isAssignment = false) {
        GrType returnType = GrBaseType.void_;
        const GrLexeme identifier = get();
        bool isFunctionCall = false, isMethodCall = false, hasParenthesis = false;
        string identifierName = identifier.svalue;
        const uint fileId = identifier.fileId;

        advance();

        if (selfType.baseType != GrBaseType.void_) {
            isMethodCall = true;
            isFunctionCall = true;
        }

        if (get().type == GrLexemeType.leftParenthesis) {
            isFunctionCall = true;
            hasParenthesis = true;
        }

        if (isFunctionCall) {
            GrType[] signature;

            if (hasParenthesis)
                advance();

            GrVariable var;
            GrVariable* localVar = (identifierName in currentFunction.localVariables);
            if (localVar !is null)
                var = *localVar;
            else
                var = getGlobalVariable(identifierName, fileId);
            if (var !is null) {
                if (var.type.baseType != GrBaseType.function_ && var.type.baseType
                        != GrBaseType.task)
                    logError("`" ~ identifierName ~ "` is not callable",
                            "function or task expected, found `" ~ grGetPrettyType(var.type) ~ "`",
                            "", -1);
                //Signature parsing with type conversion
                GrType[] anonSignature = grUnmangleSignature(var.type.mangledType);
                int i;
                if (isMethodCall) {
                    if (!anonSignature.length)
                        logError("missing parameter on method call",
                                "the method call must be done after a value");
                    signature ~= convertType(selfType, anonSignature[i], fileId);
                    i++;
                }
                if (hasParenthesis && get().type != GrLexemeType.rightParenthesis) {
                    for (;;) {
                        if (i >= anonSignature.length) {
                            const string argStr = to!string(anonSignature.length) ~ (anonSignature.length > 1
                                    ? " arguments" : " argument");
                            logError("the function takes " ~ argStr ~ " but more were supplied", "expected " ~ argStr,
                                    "the function is of type `" ~ grGetPrettyType(var.type) ~ "`",
                                    0, "function defined here", var.lexPosition);
                        }
                        GrType subType = parseSubExpression(
                                GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                                | GR_SUBEXPR_EXPECTING_VALUE).type;
                        if (subType.baseType == GrBaseType.internalTuple) {
                            auto types = grUnpackTuple(subType);
                            if (types.length) {
                                for (int y; y < types.length; y++, i++) {
                                    signature ~= convertType(types[y], anonSignature[i], fileId);
                                }
                            }
                            else
                                logError("the expression yields no value",
                                        "expected value, found nothing");
                        }
                        else {
                            signature ~= convertType(subType, anonSignature[i], fileId);
                            i++;
                        }
                        if (get().type == GrLexemeType.rightParenthesis) {
                            if (signature.length != anonSignature.length) {
                                const string argStr = to!string(anonSignature.length) ~ (anonSignature.length > 1
                                        ? " arguments" : " argument");
                                const string argStr2 = to!string(signature.length) ~ (signature.length > 1
                                        ? " arguments" : " argument");
                                logError("the function takes " ~ argStr ~ " but " ~ argStr2 ~ " were supplied",
                                        "expected " ~ argStr ~ ", found " ~ argStr2,
                                        "the function is of type `" ~ grGetPrettyType(var.type)
                                        ~ "`");
                            }
                            break;
                        }
                        advance();
                    }
                    if (hasParenthesis && get().type == GrLexemeType.rightParenthesis)
                        advance();
                }
                else {
                    if (hasParenthesis && get().type == GrLexemeType.rightParenthesis)
                        advance();
                    if (signature.length != anonSignature.length) {
                        const string argStr = to!string(anonSignature.length) ~ (anonSignature.length > 1
                                ? " arguments" : " argument");
                        const string argStr2 = to!string(signature.length) ~ (signature.length > 1
                                ? " arguments" : " argument");
                        logError("the function takes " ~ argStr ~ " but " ~ argStr2 ~ " were supplied",
                                "expected " ~ argStr ~ ", found " ~ argStr2,
                                "the function is of type `" ~ grGetPrettyType(var.type) ~ "`");
                    }
                }

                //Push the values on the global stack for task spawning.
                if (var.type.baseType == GrBaseType.task)
                    addGlobalPush(signature);

                //Anonymous call.
                //bool hasAnonFunc = false;
                addGetInstruction(var);

                returnType = grPackTuple(grUnmangleSignature(var.type.mangledReturnType));

                if (var.type.baseType == GrBaseType.function_)
                    addInstruction(GrOpcode.anonymousCall, 0u);
                else if (var.type.baseType == GrBaseType.task)
                    addInstruction(GrOpcode.anonymousTask, 0u);
            }
            else {
                if (isMethodCall) {
                    if (selfType.baseType == GrBaseType.internalTuple)
                        signature ~= grUnpackTuple(selfType);
                    else
                        signature ~= selfType;
                }
                //Signature parsing, no coercion is made
                if (hasParenthesis && get().type != GrLexemeType.rightParenthesis) {
                    for (;;) {
                        auto type = parseSubExpression(
                                GR_SUBEXPR_TERMINATE_COMMA | GR_SUBEXPR_TERMINATE_PARENTHESIS
                                | GR_SUBEXPR_EXPECTING_VALUE).type;
                        if (type.baseType == GrBaseType.internalTuple) {
                            auto types = grUnpackTuple(type);
                            if (types.length)
                                signature ~= types;
                            else
                                logError("the expression yields no value",
                                        "expected value, found nothing");
                        }
                        else
                            signature ~= type;

                        if (get().type == GrLexemeType.rightParenthesis)
                            break;
                        advance();
                    }
                }
                if (hasParenthesis && get().type == GrLexemeType.rightParenthesis)
                    advance();

                //GrPrimitive call.
                GrPrimitive primitive = _data.getPrimitive(identifierName, signature);
                if (primitive) {
                    addInstruction(GrOpcode.primitiveCall, primitive.index);
                    returnType = grPackTuple(primitive.outSignature);
                }
                else //GrFunction/Task call.
                    returnType = grPackTuple(addFunctionCall(identifierName, signature, fileId));
            }
        }
        else if (_data.isEnum(identifier.svalue, fileId, false)) {
            const GrEnumDefinition definition = _data.getEnum(identifier.svalue, fileId);
            if (get().type != GrLexemeType.period)
                logError("expected a `.` after the enum type", "missing the enum constant name");
            checkAdvance();
            if (get().type != GrLexemeType.identifier)
                logError("expected a constant name after the enum type",
                        "missing the enum constant name");
            const string fieldName = get().svalue;
            if (!definition.hasField(fieldName)) {
                const string[] nearestValues = findNearestStrings(fieldName, definition.fields);
                string errorNote;
                if (nearestValues.length) {
                    errorNote = "available fields are: ";
                    foreach (size_t i, const string value; nearestValues) {
                        errorNote ~= "`" ~ value ~ "`";
                        if ((i + 1) < nearestValues.length)
                            errorNote ~= ", ";
                    }
                    errorNote ~= ".";
                }
                logError("no field `" ~ fieldName ~ "` on type `" ~ definition.name ~ "`",
                        "unknown field", errorNote);
            }
            checkAdvance();

            returnType = GrType(GrBaseType.enum_);
            returnType.mangledType = definition.name;
            addIntConstant(definition.getField(fieldName));
        }
        else {
            //Declared variable.
            variable = getVariable(identifierName, fileId);
            returnType = variable.type;
            //If it's an assignement, we want the GET instruction to be after the assignement, not there.
            const auto nextLexeme = get();
            if (!(nextLexeme.type == GrLexemeType.assign || (isAssignment
                    && nextLexeme.type == GrLexemeType.comma)))
                addGetInstruction(variable, expectedType);
        }
        return returnType;
    }

    /// Check an raise_ an error.
    private void assertError(bool assertion, string message, string info,
            string note = "", int offset = 0) {
        if (assertion)
            return;
        logError(message, info, note, offset);
    }

    /// Log an error and throw an exception.
    private void logError(string message, string info, string note = "",
            int offset = 0, string otherInfo = "", uint otherPos = 0) {
        GrError error = new GrError;
        error.type = GrError.Type.parser;
        error.message = message;
        error.info = info;
        error.note = note;

        GrLexeme lex = (isEnd() && offset >= 0) ? get(-1) : get(offset);
        error.filePath = lex.getFile();
        error.lineText = lex.getLine().replace("\t", " ");
        error.line = lex.line + 1u; // By convention, the first line is 1, not 0.
        error.column = lex.column;
        error.textLength = lex.textLength;

        if (otherInfo.length) {
            error.otherInfo = otherInfo;

            set(otherPos);

            GrLexeme otherLex = isEnd() ? get(-1) : get();
            error.otherFilePath = otherLex.getFile();
            error.otherLineText = otherLex.getLine().replace("\t", " ");
            error.otherLine = otherLex.line + 1u; // By convention, the first line is 1, not 0.
            error.otherColumn = otherLex.column;
            error.otherTextLength = otherLex.textLength;
        }

        throw new GrParserException(error);
    }
}

/**
Syntatic error during parsing
*/
package final class GrParserException : Exception {
    GrError error;

    /// Ctor
    this(GrError error_, string file = __FILE__, size_t line = __LINE__) {
        super(error_.message, file, line);
        error = error_;
    }
}
