# Grimoire Language Reference

Grimoire is an embedded language for D applications.

The language features static typing, concurrency and an easy to use API to define your own types, functions and variables directly from D.

Compiling a Grimoire script and getting it to run is as easy as this:
```d
import std.stdio: writeln;

// Some basic functions are provided by the default library.
GrLibrary stdlib = grLoadStdLibrary(); 

GrCompiler compiler = new GrCompiler;

// We add the default library.
compiler.addLibrary(stdlib);

// We compile the file.
GrBytecode bytecode = compiler.compileFile("script.gr");

if(bytecode) {
    // Compilation successful, we setup the VM
	GrEngine engine = new GrEngine;

	// Adding the default library to the runtime
	engine.addLibrary(stdlib);

	// Loading the generated bytecode
	engine.load(bytecode);

	// We call an event named `main`
	if(engine.hasEvent("main"))
		engine.callEvent("main");

	// The VM will run until all the passes are done
	while(engine.hasTasks)
    	engine.process();

	// An unrecoverable error made the whole VM to stop
	if(engine.isPanicking)
    	writeln("unhandled error: " ~ engine.panicMessage);
}
else {
    // An error occurred while compiling
    writeln(compiler.getError().prettify());
}
```

* * *

## Sommaire

- Basics:
  - [Basic syntax](#syntax)
  - [First program](#first-program)
  - [Importing files](#importing-files)
  - [What's a variable ?](#variables)
  - [Control flow](#control-flow)

- Functions:
  - [Creating a function](#functions)
  - [Task, Grimoire's coroutine](#tasks)
  - [Template functions/tasks](#template-functions)
  - [Anonymous function/task](#anonymous-functions)
  - [Event function, or how to call a function from D](#event-functions)
  - [Type casting](#type-casting)
  - [Operators](#operators)

- Compound types:
  - [Lists](#lists)
  - [Enumerations](#enumerations)
  - [Classes](#classes)
  - [Channels](#channels)
  - [Type aliases](#type-aliases)

- Errors:
  - [Error handling](#error-handling)
  - [Deferring code](#deferring-code)

- API Implementation:
  - [Variables](#variables-api)
  - [Enumerations](#enumerations-api)
  - [Primitives](#primitives-api)
  - [Casting](#casting-api)
  - [Operators](#operators-api)
  - [Classes](#classes-api)
  - [Type aliases](#type-aliases-api)
  - [Foreign types](#foreign-types-api)

* * *

# Syntax

## Identifier

An identifier is a name used to identify something like a variable, a function, a type, etc.

It must not be reserved word, it can use any alphanumeric character, lower and upper cases, or underscores be it can't start with a digit.

Exemple of valid identifiers:
`_myVariable`
`MyVAR1__23`

`?` can be added to an identifier *only* if it's put at the end:
`empty?`

## Reserved words

The following are keyword used by the language, they cannot be used as identifier (variables, functions, etc):
`import`, `public`, `alias`, `event`, `class`, `enum`, `template`, `if`, `unless`, `else`, `switch`, `select`, `case`, `while`, `do`, `until`, `for`, `loop`, `return`, `self`, `die`, `exit`, `yield`, `break`, `continue`, `as`, `try`, `catch`, `throw`, `defer`, `void`, `task`, `function`, `int`, `real`, `bool`, `string`, `array`, `channel`, `new`, `let`, `true`, `false`, `null`, `not`, `and`, `or`, `bit_not`, `bit_and`, `bit_or`, `bit_xor`.

## Comments

Comments are text that are entierly ignored by the compiler, they serve as note for you.

```cpp
// Everything after those 2 slashes is ignored until the end of the line.

/*
Everything between / * and * / are ignored
/* Nested comments works too */
*/
```

## Numbers

Numbers can either be integers or floating point values.

An integer is defined by digits from 0 to 9.
A real is similar but must either:
- Have a decimal part separated by a `.` dot : `5.678`, `.123`, `60.`
- Have a `f` at the end of the number : `1f`, `.25f`, `2.f`

You can also use underscores `_` inside the number (not in front) to make it more readable: `100_000`
The underscores won't be parsed by the compiler.

* * *

# First Program

Starting with the traditionnal "Hello World" :
```cpp
event main {
  print("Hello World!");
}
```
The code is composed of the keyword **event**, which allow use to declare a task that can be called from D. Here we name that event `main`.

Then we have a left curly brace `{` with a right curly brace `}` some lines after.
Those curly braces delimit the scope of the statement (here, the **main**).

Everything inside those curly braces (called a **block**) will be executed when `main` is run.

The whole `print("Hello World!");` form a single expression terminated by a semicolon.
We pass the "Hello World!" string to the **print** primitive which will then display: `Hello World!`.

# Importing files

You can separate a script between multiple files.
To import them, use the `import` keyword with your file paths.
```cpp
import "foo/myscript.gr"

// With {} you can specify multiple paths.
import {
	"../lib/myotherscript.gr"
	"C:/MyScripts/script.gr"
}
```

The path is relative to the file importing it.
Two import with the same absolute path (i.e. the same file) will be included only once.

* * *

# Variables

Variable can store a value that can be used later.
A variable is defined by its type and must be declared before use.

`int a = 0;`
Here we created a variable **a** of type **int** initialized with the value **0**.

If we print the content of the variable with 'print(a)'. The prompt will display **0**.

All variables are initialized, if you don't assign anything, it'll have its default value.

## Basic Types
They're only a handful of basic type recognised by grimoire.
* Integer declared with **int** ex: 2 (Default value: 0)
* Realing number declared with **real** ex: 2.35f (Default value: 0f)
* Boolean declared with **bool** ex: true, false (Default value: false)
* String declared with **string** ex: "Hello" (Default value: "")
* [List](#lists) (Default value: [])
* [Function](#functions) (Default value: empty function)
* [Task](#tasks) (Default value: empty task)
* [Channel](#channels) (Default value: size 1 channel)
* [Class](#classes) (Default value: null)
* [Foreign](#foreign-types) (Default value: null)
* [Enumerations](#enumerations) (Default value: the first value)

### Auto Type
**let** is a special keyword that let the compiler automatically infer the type of a declared variable.
Example:
```cpp
event main {
  let a = 3.2; //'a' is inferred to be a real type.
  print(a);
}
```
let can only be used on variable declaration and cannot be part of a function signature because it's not a type !

Variables declared this way **must** be initialized.

## Scope
A variable can either be local or global.
* A global variable is declared outside of any function/task/etc and is accessible in everywhere in every file.
* A local variable is only accessible inside the function/task/etc where it was declared.

Example:
```cpp
int globalVar; //Declared outside of any scope, accessible everywhere.

event main {
  int localVar; //Declared inside the main, only accessible within the main.
}
```

### Public or private
A global variable is only visible from its own file by default.
To access it from another file, you have to declare it as public with the keyword "public".
```cpp
public int globalVar; //Now you can use it from another file.
```

The same is true for declared types.
```cpp
public class A {} //The class is visible globally.
```

## Declaration List

You can also declare multiple variables at once separating each identifier with a comma.
> `int a, b;`

Initialization will be done in the same order:
> `int a, b = 2, 3;`
Here *a = 2* and *b = 3*.

If there is not enough values to assign, the other variable will be assigned the last value:
> `int a, b, c = 2, 3;`
Here *a = 2*, *b = 3*, *c = 3*.

You can skip one or more values by leaving a blank comma, it'll then copy the last value:

> `int a, b, c = 12,, 5;`
Both *a* and *b* are equal to *12* while *c* is equal to 5.

> `int a, b, c, d = 12,,, 5;`
Both *a*, *b*, and *c* are equal to *12* while *c* is equal to 5.

The first value cannot be blank, you **can't** do this:
> `int a, b, c = , 5, 2;`


Every variable on the same initialization list must be of the same type.
Ex: `int a, b = 2, "Hi"` will raise an error because *b* is expected to be **int** and you are passing a **string**.

But you can use **let** to initialize automatically different types :
> `let a, b, c, d = 1, 2.3, "Hi!";`

Here:
* *a = 1* and is of type **int**,
* *b = 2.3* and is of type **real**,
* *c = "Hi!"* and is of type **string**,
* *d = "Hi!"* and is of type **string**.

# Control flow

## If/Else/Unless

`if` is a keyword that allows you to runs a portion of code only if its condition is true, `unless` do the opposite.
You can combine it with optionals `else if` or `else unless` to do the same thing, only if the previous ones aren't run.
Finally you can add an optional `else` that is run *only* if others are not run.

Exemple:
```cpp
event main {
	if(5 < 2) {
		//This code won't run because 5 is never less than 2.
		print("5 is less than 2 !");
	}

	unless(5 < 2) {
		//This one will, because unless do the opposite of if
		//It's the same thing as if(not 5 < 2) {}
		print("5 is not less than 2...");
	}
}
```
Another one:
```cpp
event main {
	let i = 5;
	if(i > 10) {
		print("i is more than 10");
	}
	else if(i >= 5) {
		print("i is 5 or more but less than 10");
	}
	else unless(i < 2) {
		print("i is 2 or more, but less than 5");
	}
	else { //else must always be put at the end of the (if/unless)/else (if/unless)/else serie, but is optional.
		print("i is 2 or less");
	}
}
```

## Switch statement

`switch` let us do comparisons a bit like `if`, but in a more concise manner.

```cpp
let i = "Hello";
switch(i)
case() { // Default case if others aren't valid.
	print("I don't know what he said");
}
case("Hey") {
	print("He said hey");
}
case("Hello") {
	print("He said hello");
}
```

Contrary to `if` statement, cases can be put in any order, and will check equality between the switch value and each cases value.

A `case` without value is considered to be a default case like the `else` above, you can only have one default case per switch statement.

## Select statement

A select is syntaxically like a switch, but differs in that it doesn't do value comparison, it checks each case for an operation that can process whithout blocking.

```cpp
select
case( /* channel operation  */ ) {

}
case() {
	/* run if the one above is blocked */
}
```

Each case contains a potentially blocking operation, the first non-blocking operation case is run.
The default case is optional, but without one, the select statement will be a blocking operation, otherwise the default case will execute when others are blocked.

```cpp
select
case(myValue = <- myChannel) { // Receive operation
	print("Received " ~ myValue);
}
case(myOtherChannel <- "Hello") { // Send operation
	print("Sent Hello");
}
case() {
	// Run if no one else can run.
	// If it's not present, select will blocking until one of the case is non-blocking.
	print("Did nothing");
}
```

## Loops

A loop is a structure that can be executed several time, there are two type of loops.

### Infinite loops

Infinite loops are infinite:
```cpp
loop {
	print("Hello !");
}
```
This script will prompt *"Hello !"* infinitely until the process is killed, be cautious with it.
You may want to add either a `yield` to interrupt the loop each time or add an exit condition.

### Finite loops

Finite loops, on the other hand, have a finite number of time they will run.
Contrary to the infinite one, they take an int as a parameter, which indicate the number of loops:
```cpp
loop(10) {
	// "I loop 10 times !" will only be printed times.
	print("I loop 10 times !");
}
```

You can also specify an iterator, which must be of type `int`.
```cpp
loop(i, 10)
	print(i); // Prints from 0 to 9

// Same as above, but we declare i.
loop(int i, 10)
	print(i);

// Also valid.
loop(let i, 10)
	print(i);
```

## While/Do While

`while` and `do while` are, akin to loops, statements that can execute their code several time.
The difference is, they do not have a finite number of loop, instead, they have a condition (like `if` statements).
```cpp
int i = 0;
while(i < 10) {
	print(i); // Here, the output is 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9.
	i ++;
}
```
`do while` is the same as `while` but the condition is checked after having run the code one time.
```cpp
int i = 11;
do { //This is garanteed to run at least once, even if the condition is not met.
	print(i); //Will print "11"
}
while(i < 10)
```

## For

`for` loops are yet another kind of loop that will automatically iterate on an list of values.
For instance:
```cpp
for(i, [1, 2, 3, 4]) {
	print(i);
}
```
Here, the for statement will take each value of the list, then assign them to the variable "i" specified.

The variable can be already declared, or declared inside the for statement like this:

```cpp
int i;
for(i, [1, 2]) {}
```
Or,
```cpp
for(int i, [1, 2]) {}
```
If no type is specified, or declared as let, the variable will be automatically declared as `var`.

The variable type must be convertible from the list's values, or it will raise a runtime error.

### Iterators

`for` can also iterate on special object or foreign called iterators.
In grimoire, an iterator is defined by the fact that a function that satisfies this signature exists:
> `function next(Iterator) (bool, VALUE)`

A function `next` must exists that takes the iterator and returns a `bool` and the current value.
The `bool` must be false when the iterator has finished iterating, true otherwise.

```cpp
// The each() function takes the string and return
// an IterString object that iterate over the string
for(i, "Hello World":each) {
	i:print;
}
```

* * *

# Functions

Like any other language, functions behave the same. They are declared like this:
```cpp
function myFunction() {}
```
Here, the function myFunction takes no parameter, returns nothing and do nothing, which is boring..

Here is a function that takes 2 int, and returns the sum of them
```cpp
function add(int a, int b) (int) {
  return a + b;
}
```
The return type is always put after the parenthesis inside another pair of parenthesis. If there is no return type, you can put empty parenthesis `()` or nothing.
If there is no return value, you can use return alone to exit the function anywhere.
```cpp
function foo(int n) {
  if(n == 0) {
    print("n is equal to 0");
    return
  }
  print("n is different from 0");
}
```

A function can have multiple return values, the types returned must correspond to the signature of the function.
```cpp
function foo() (int, string, bool) {
	return 5, "Hello", false;
}
```

* * *

# Tasks

Task are Grimoire's implementation of coroutines. They are syntaxically similar to function except from a few points:
* A task have no return type and can't return anything (You'll be able to do so with channels).
* When called, a task will not execute immediately and will not interrupt the caller's flow.
* A task will only be executed if other tasks are killed or on yield.

Syntax:
```cpp
task doThing() {
  print("3");
  yield
  print("5");
}

event main {
  print("1");
  doThing();
  print("2");
  yield
  print("4");
}
```
Here, the main will print 1, spawn the doThing task, print 2 then yield to the doThing task which will print 3 then yield again to the main which will print 4. Then the main will die so the doThing task will resume and print 5.

To interrupt the flow of execution of the task and let other task continue, you can use the keyword **yield**.
The task will run again after all other tasks have run once.

You can also delete the task with the keyword **die**. Also be aware that inside the scope of a task, the keyword **return** will behave the same as **die**.

There is also **exit** which simply kills all running tasks.

* * *

# Template functions

Global functions and tasks can be defined with generic types:
```cpp
function<T> add(T a, T b)(T) {
    return a + b;
}
```
Here, `T` is a generic type that will be replaced with the actual type when generating the function.

To generate the function, you need to instanciate it with the `template` statement:
```cpp
template<int> add;
template<real> add;
```
Now, `add(int, int)(int)` and `add(real, real)(real)` have been generated and can now be called.

You can also have multiple template variables:
```cpp
public template<int, real> add;
public function<A, B> add(A a, B b)(B) {
    return a as B + b;
}
```

Operators can also be templated:
```cpp
template<int> <=>;
template<real> <=>;
function<T> operator<=>(T a, T b)(int) {
	if(a < b)
		return -1;
	else if(a > b)
		return 1;
    return 0;
}
```

* * *

# Anonymous functions

You can declare a function or a task inside another function (or task).
Like this:

```cpp
event main {
	let f = function() {};
	let t = task() {};
}
```

You can also decide to just run it immediately:
```cpp
event main {
	int a = 7;
	int b = function(int c) (int) {
		return c * 2;
	}(a);
	print(b); //Prints 14
}
```

The type of a function/task is the same as its declaration without the parameters' name:
```cpp
event main {
	function(int, real) (string, int) myFunction = function(int a, real b) (string, int) { return "Hey", 2; };
}
```

You can use a global function/task as an anonymous by getting its address.
You can do so by using the & operator.
The operator & does not require the function type, except when it has no way to know it at compilation time, like when declaring with let.

```cpp
function square(int i) (int) {
	return i * i;
};

event main {
	let f1 = &square; //Error, & has no way to know the type at during compilation (square could be overloaded).
	let f2 = &(function(int) (int))square; //Valid, an explicit type prevent this problem.
	f2 = &square; //Now valid, because it's now typed by the previous assignment.

	function(int) (int) f3 = &square; //Error, can't know the type of f3 since f3 doesn't exist at the time of declaration.
	f3 = &square; //Valid, since f3 is already declared with a type.
}
```

## Self

If you want to refer to the current function, but you're inside an anonymous function you can't because the function has no name.

Except `self`. Self is used to refers to the current function/task/etc even anonymous ones.

It allows you to do things like this anonymous recursive fibonacci:
```cpp
function(int n) (int) {
    if(n < 2) return n;
    return self(n - 1) + self(n - 2);
}(10):print;
```

* * *

# Event functions

Events are like tasks that can only be spawned from D.

They are declared like tasks and can only be global:
```cpp
event foo(string msg) {
	print(msg);
}
```

To spawn this one from D:
```d
auto mangledName = grMangleComposite("foo", [grString]);
if(vm.hasEvent(mangledName)) {
    GrContext context = vm.spawnEvent(mangledName);
	context.setString("Hello World!");
}
```
Here the process is a little bit special.
First, we need to know the mangled name (name + signature) of the event with "grMangleComposite".
Then, we call it.
If the event has parameters, you absolutely ***must*** push those values to the new context, else the VM will crash.

* * *

# Type casting

You can explicitly cast a value to any type with the keyword `as`, it must be followed by the desired type like this: `real a = 5 as real;`.

## Custom casting

You can define your own cast by naming a function with `as`.
It must only have one input and one output.

```cpp
class MyClass {}

event main {
    let obj = new MyClass;
    print(obj as string); // Prints "Hello"
}

function as(MyClass a) (string) {
    return "Hello";
}
```

Note that if a default convertion exists, it'll call this one instead.

# Operators

Much like custom convertions, you can define your own operators by naming it accordingly.
You also have to respect the number of inputs the operator uses (1 or 2).

```cpp
event main {
    print(3.5 + 2);
}

function operator+(real a, int b) (real) {
    return a + b as real;
}
```

Overridable operators are:

| Operator | Symbol | Note |
| --- | --- | --- |
| `+` | Plus | Prefix unary operator |
| `-` | Minus | Prefix unary operator |
| `+` | Add | Binary operator |
| `-` | Substract | Binary operator |
| `*` | Multiply | Binary operator |
| `/` | Divide | Binary operator |
| `~` | Concatenate | Binary operator |
| `%` | Remainder | Binary operator |
| `**` | Power | Binary operator |
| `==` | Equal | Binary operator |
| `===` | Double Equal | Binary operator |
| `<=>` | Three Way Comparison | Binary operator |
| `!=` | Not Equal | Binary operator |
| `>=` | Greater or Equal | Binary operator |
| `>` | Greater | Binary operator |
| `<=` | Lesser or Equal | Binary operator |
| `<` | Lesser | Binary operator |
| `<<` | Left Shift | Binary operator |
| `>>` | Right Shift | Binary operator |
| `->` | Interval | Binary operator |
| `=>` | Arrow | Binary operator |
| `<-` | Receive | Prefix unary operator |
| `<-` | Send | Binary operator |
| `&`, `bit_and` | Bitwise And | Binary operator |
| `|`, `bit_or` | Bitwise Or | Binary operator |
| `^`, `bit_xor` | Bitwise Xor | Binary operator |
| `~`, `bit_not` | Bitwise Not | Prefix unary operator |
| `&&`, `and` | Logical And | Binary operator |
| `||`, `or` | Logical Or | Binary operator |
| `!`, `not` | Logical Not | Prefix unary operator |

* * *

# Lists

List are a collection of a single type of value.

The type of an list is `list()` with the type of its content inside the parenthesis:
```cpp
list(int) myCollection = [1, 2, 3];
```

By default, a new list has the type of its first element.
So, `[1, 2, 3]` will be an `list(int)`.

You can write it explicitly by preceding the list with its type: `list(int)[1, 2, 3]`

If your new list is empty `[]`, you **have** to write the type explicitly else compilation will fail: `list(string)[]`.

To access an list element, the list index (from 0) in written between brackets:
```cpp
let a = [10, 20, 30][1]; //New list, then immediately take the index 1 of [10, 20, 30], which is 20

let b = [[1, 2, 3], [11, 12, 13], [21, 22, 23]]; //New list
let c = b[1][2]; //Here we access the element at index 1 -> [21, 22, 23], the element at index 2 -> 23
let d = b[1, 2]; //Same as above in a nicer syntax
```

When accessing an list element, you can also modify it:
```cpp
let a = [11, 12, 13];
a[0] = 9; //a now has [9, 12, 13]
```

List and list indexes are passed by references, that mean manipulating list do not make copies.
```cpp
let a = [1, 2, [3, 4]];
let b = a[2]; //b is now a reference to the 3rd value of a
b[0] = 9;

print(a); //Prints [1, 2, [9, 4]]
```

You can concatenate values into an list by using the concatenation operator ~
```cpp
let a = 1 ~ [2, 3, 4] ~ [5, 6] ~ 7; //a is now [1, 2, 3, 4, 5, 6, 7]
```

* * *

# Enumerations

Enumerations (or enum) are a set of named constants defined inside a single type.
They can only be compared between them and can't do any arithmetic operation.

## Definition

They are declared with the keyword enum:
```cpp
enum Color {
	red;
	green;
	blue;
}
```

## Accessing a field

To access a value, just type the name of the enum with
the name of the field you want separated with a dot:
```cpp
event main {
	Color myColor = Color.red;

	switch(myColor)
	case(Color.red) "The color is red !":print;
	case(Color.green) "The color is green !":print;
	case(Color.blue) "The color is blue !":print;
}
```

* * *

# Classes

Classes are types that can hold fields of different types.

## Definition

Declaration is made with the `class` keyword.
```cpp
class MyClass {
    int foo;
    string bar;
}
```

## New

To create an instance of that class (i.e. an object), you use the `new` keyword followed by the class type.
```cpp
MyClass obj = new MyClass;
```

By default, all fields will be initialized with its default value, to change that, you need to use the constructor notation.

```cpp
MyClass obj = new MyClass {
	foo = 5;
	bar = "Hello";
};
```
Unspecified fields in the constructor will still be initialized by default.

## Accessing a field

To access a field, use the `.` notation.
```cpp
obj.foo = 5;
obj.bar = "Hello";
print(obj.bar);
```

By default, all fields are only visible to the file that declared it.
To make them visible to all files, you need to specify them as public with the "public" keyword:
```cpp
class A {
	public int a; // Visible globally
	int b; // Visible only to the current file
}
```

## Null

An uninitialized class variable will be initialized to null.

Like foreign types, you can assign "null" to a class type variable.

```cpp
MyClass obj = null;
if(!obj)
	"Obj is null":print;
```

Trying to access a null object's field will raise an error.

## Inheritance

You can inherit fields from another class:
```cpp
class MyClass : ParentClass {

}
```

## Template

In grimoire, you can define generic types for classes like this:
```cpp
class MyClass<T, A> : ParentClass<T, int> {
	T myValue;
	A myOtherValue;
}
```

* * *

# Channels

Channels are a concept that allow synchronised communication between tasks.
If you know them from Go, it's roughly the same.

Channels are created like this:
```cpp
channel(int) c = channel(int, 5);
```
Here, we create a channel that will hold up to 5 int values.
The size (5) of the channel is optional, by default, it's 1.

To pass a value around, you need to use the <- operator
```cpp
let c = channel(int);
c <- 1; //We send the value 1 through the channel
int value = <-c; //We receive the value from the channel
```

But a send or receive operation is blocking, you can't do it on the same task.

```cpp
task foo(channel(int) c) {
	print(<-c);
}
event main {
	let c = channel(int);
	foo(c);
	c <- "Hello World !";
}
```
Here, foo will be blocked until something is written on the channel, then it'll print it.

* * *

# Type Aliases

A type alias allow types to be named differently, making long signatures shorter.

```cpp
function square(int i) (int) {
	return i * i;
};

alias MyFunc = function(int) (int);

event main {
    MyFunc myFunc = &(MyFunc) square;
	10:myFunc:print;
}
```

* * *

# Error Handling

Error handling in Grimoire is done by throwing and catching errors

To raise an error, simply write:
```cpp
throw "Error";
```
If you do nothing about it, the entire VM will panic, because the current task does nothing to catch it.

So we should probably catch it:
```cpp
event main {
	try {
		throw "Error";
	}
	catch(e) {
		print("I caught " ~ e);
	}
}
```
And everything is fine.

* * *

# Deferred statements

Code put inside a defer statement, is *garanteed* to be executed at the end of the function/task,
even if an error is thrown before the end of the scope.

```cpp
event main {
	defer { print("Inside defer !"); }
	print("Before defer");
	throw "Error";
}
```
Here, the prompt will show "Before defer", then "Inside defer !", even if we raise an error before the end of the scope.
It's useful for handling resources that need to be freed.

* * *

# API Implementation

Everything you need to declare new types and values is contained in a GrLibrary.
```d
GrLibrary library = new GrLibrary;
//Then add your types inside lib
```

After creating a GrLibrary and adding your custom types inside it, add it to your compiler before compilation.
```d
compiler.addLibrary(library);
```

Then, add it to your runtime.
```d
engine.addLibrary(library);
```

**Important:** All the libraries must be included in both the compiler **and** the engine and in the **same order**

* * *

## Variables API

You can declare global variables from a library using addVariable():
```d
library.addVariable("pi", grReal, 3.141592f, true); 
```

To access the variable in runtime, you can use the getXVariable() of GrCall or GrEngine:
```d
float value = engine.getRealVariable("PI");
```

To modify it, use the setXVariable() ones:
```d
engine.setRealVariable("PI", 3f);
```

* * *

## Primitives API

In this language, a primitive is a function declared in D accessible from a script.
`print` for instance, is a primitive.

They must be declared before the compilation anb remain unchanged in the VM.

* * *

### Primitive declaration

To declare your primitive use `addFunction`.
This function takes a callback to your primitive, the name which your primitive will be known as inside scripts,
the parameters and, optionally, the return types.
Exemple:
```d
//A function print that takes a string and returns nothing
library.addFunction(&print_a_string, "print", [grString]);
//Function mul() that takes 2 reals and returns one.
library.addFunction(&multiply, "mul", [grReal, grReal], [grReal]);
```

* * *

### Implementing the primitive

The callback takes a GrCall object and return nothing.
The GrCall object contains everything you need about the current running context.

It looks like this:
```d
void myPrimitive(GrCall call) {
	writeln(call.getReal(0));
    call.setInt(99);
}
```
Here, the primitive takes a real parameter at index 0 (first parameter), and prints it, then returns the int value 99.
getXXX methods fetch the parameters, the type must match the declaration, else they'll throw an exception.
setXXX methods returns a value on the stack, beware of the order in which you call setXXX functions.

* * *

### Applying genericity to a primitive

Grimoire provide a way to declare a primitive with generic types with `grAny`.
*grAny* takes two arguments:
- The name of the generic type,
- A predicate that checks if the provided type is correct.

The predicate takes 2 parameters:
- A `GrType` of the provided value,
- The context of the checker containing the defined generic types.

Exemple of a primitive that can define a `push` function for every type of list that uses integers.
It takes an list and a value that matches the type held by the list, and returns the list itself.
```d
library.addFunction(&_push, "push", [
    grAny("A",   // We declare a generic type called "A"
	(type, data) {
		if (type.baseType != GrBaseType.list_) // This type must be an list
			return false;
		const GrType subType = grUnmangle(type.mangledType); // The subType is mangled
		data.set("T", subType);  // We define the other generic type (called "T") with the subtype of the list
		return grIsKindOfInt(subType.baseType); // We check is the baseType is good for us.
	}), grAny("T")], // "T" is already defined above, so the types must match.
	[grAny("A")]   // "A" is already defined above, it must be of the same type. Putting any predicate here is useless.
);
```

If no predicate is given to a *grAny*, the type is always validated.
The predicate of return types won't be checked, only the input signature is validated.

* * *

### Casting API

You can define a cast function inside a library
```d
library.addCast(&myCast, myObjType, grString);
```

Then, define the function itself:
```d
void myCast(GrCall call) {
    auto myObj = call.getObject(0);
    call.setString("Hello");
}
```

* * *

### Operators API

Like addCast, but using addOperator instead.
```d
library.addOperator(&myOperator, GrLibrary.Operator.add, [grReal, grInt], grReal);
// Or
library.addOperator(&myOperator, "+", [grReal, grInt], grReal);
```

Then writing the function itself.
```d
void myOperator(GrCall call) {
    call.setReal(call.getReal(0) + cast(int) call.getInt(1));
}
```

Note that if a default operation exists, it'll be used instead,
so overloading a `+` operator between 2 integers is going to be ignored.

* * *

## Classes API

You declare a class by calling addClass() from the GrLibrary:
```d
library.addClass("MyClass", ["foo", "bar"], [grInt, grString]);
```

There are more optional parameters for inheritance and templating:
```d
library.addClass("MyClass", [], [], ["T"], "ParentClass", [grAny("T")]);
```
This is equal to MyClass<T> inheriting from ParentClass<T>.
The `grAny("T")` ensures that the template variable "T" from MyClass is used for the parent class.

Instanciating a class is done with `createObject()` from GrCall or GrEngine:
```d
GrObject obj = call.createObject("MyClass");
```

You can then set or get fields from the GrObject with their respective set/get methods:
```d
obj.setInt("foo", 5);
string value = obj.getString("bar");
```

* * *

## Type Aliases API

Type aliases can be declared by calling `addTypeAlias` from GrLibrary:
```d
library.addTypeAlias("MyInt", grInt);
```

* * *

## Foreign types API

Foreign types are opaque pointers used by D, grimoire doesn't have access to their content.
As such, they can only be declared from D.
```d
library.addForeign("MyType");
```

Like classes, they can inherit from another foreign type.
```d
library.addForeign("MyType", [], "ParentType", []);
```

The second and fourth parameters are the template variable of the defined and the parent class.
```d
library.addForeign("MyType", ["T"], "ParentType", [grAny("T")]);
```
Roughly means that MyType<T> inherits from ParentType<T>

* * *

## Enumerations API

Enums can be created by calling `addEnum` from GrLibrary:
```d
library.addEnum("Color", ["red", "green", "blue"]);
```

